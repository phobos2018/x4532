var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
(function e(t, n, r) { function s(o, u) { if (!n[o]) {
    if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a)
            return a(o, !0);
        if (i)
            return i(o, !0);
        var f = new Error("Cannot find module '" + o + "'");
        throw f.code = "MODULE_NOT_FOUND", f;
    }
    var l = n[o] = { exports: {} };
    t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e); }, l, l.exports, e, t, n, r);
} return n[o].exports; } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)
    s(r[o]); return s; })({ 1: [function (require, module, exports) {
            window.ccxt = require('./ccxt');
        }, { "./ccxt": 2 }], 2: [function (require, module, exports) {
            "use strict";
            "use strict";
            var Exchange = require('./js/base/Exchange'), functions = require('./js/base/functions'), errors = require('./js/base/errors');
            var version = '1.11.41';
            Exchange.ccxtVersion = version;
            var exchanges = {
                '_1broker': require('./js/_1broker.js'),
                '_1btcxe': require('./js/_1btcxe.js'),
                'acx': require('./js/acx.js'),
                'allcoin': require('./js/allcoin.js'),
                'anxpro': require('./js/anxpro.js'),
                'bibox': require('./js/bibox.js'),
                'binance': require('./js/binance.js'),
                'bit2c': require('./js/bit2c.js'),
                'bitbay': require('./js/bitbay.js'),
                'bitcoincoid': require('./js/bitcoincoid.js'),
                'bitfinex': require('./js/bitfinex.js'),
                'bitfinex2': require('./js/bitfinex2.js'),
                'bitflyer': require('./js/bitflyer.js'),
                'bithumb': require('./js/bithumb.js'),
                'bitlish': require('./js/bitlish.js'),
                'bitmarket': require('./js/bitmarket.js'),
                'bitmex': require('./js/bitmex.js'),
                'bitso': require('./js/bitso.js'),
                'bitstamp': require('./js/bitstamp.js'),
                'bitstamp1': require('./js/bitstamp1.js'),
                'bittrex': require('./js/bittrex.js'),
                'bitz': require('./js/bitz.js'),
                'bl3p': require('./js/bl3p.js'),
                'bleutrade': require('./js/bleutrade.js'),
                'braziliex': require('./js/braziliex.js'),
                'btcbox': require('./js/btcbox.js'),
                'btcchina': require('./js/btcchina.js'),
                'btcexchange': require('./js/btcexchange.js'),
                'btcmarkets': require('./js/btcmarkets.js'),
                'btctradeim': require('./js/btctradeim.js'),
                'btctradeua': require('./js/btctradeua.js'),
                'btcturk': require('./js/btcturk.js'),
                'btcx': require('./js/btcx.js'),
                'bxinth': require('./js/bxinth.js'),
                'ccex': require('./js/ccex.js'),
                'cex': require('./js/cex.js'),
                'chbtc': require('./js/chbtc.js'),
                'chilebit': require('./js/chilebit.js'),
                'cobinhood': require('./js/cobinhood.js'),
                'coincheck': require('./js/coincheck.js'),
                'coinegg': require('./js/coinegg.js'),
                'coinexchange': require('./js/coinexchange.js'),
                'coinfloor': require('./js/coinfloor.js'),
                'coingi': require('./js/coingi.js'),
                'coinmarketcap': require('./js/coinmarketcap.js'),
                'coinmate': require('./js/coinmate.js'),
                'coinsecure': require('./js/coinsecure.js'),
                'coinspot': require('./js/coinspot.js'),
                'coolcoin': require('./js/coolcoin.js'),
                'cryptopia': require('./js/cryptopia.js'),
                'dsx': require('./js/dsx.js'),
                'exmo': require('./js/exmo.js'),
                'flowbtc': require('./js/flowbtc.js'),
                'foxbit': require('./js/foxbit.js'),
                'fybse': require('./js/fybse.js'),
                'fybsg': require('./js/fybsg.js'),
                'gatecoin': require('./js/gatecoin.js'),
                'gateio': require('./js/gateio.js'),
                'gdax': require('./js/gdax.js'),
                'gemini': require('./js/gemini.js'),
                'getbtc': require('./js/getbtc.js'),
                'hitbtc': require('./js/hitbtc.js'),
                'hitbtc2': require('./js/hitbtc2.js'),
                'huobi': require('./js/huobi.js'),
                'huobicny': require('./js/huobicny.js'),
                'huobipro': require('./js/huobipro.js'),
                'independentreserve': require('./js/independentreserve.js'),
                'itbit': require('./js/itbit.js'),
                'jubi': require('./js/jubi.js'),
                'kraken': require('./js/kraken.js'),
                'kucoin': require('./js/kucoin.js'),
                'kuna': require('./js/kuna.js'),
                'lakebtc': require('./js/lakebtc.js'),
                'liqui': require('./js/liqui.js'),
                'livecoin': require('./js/livecoin.js'),
                'luno': require('./js/luno.js'),
                'lykke': require('./js/lykke.js'),
                'mercado': require('./js/mercado.js'),
                'mixcoins': require('./js/mixcoins.js'),
                'nova': require('./js/nova.js'),
                'okcoincny': require('./js/okcoincny.js'),
                'okcoinusd': require('./js/okcoinusd.js'),
                'okex': require('./js/okex.js'),
                'paymium': require('./js/paymium.js'),
                'poloniex': require('./js/poloniex.js'),
                'qryptos': require('./js/qryptos.js'),
                'quadrigacx': require('./js/quadrigacx.js'),
                'quoinex': require('./js/quoinex.js'),
                'southxchange': require('./js/southxchange.js'),
                'surbitcoin': require('./js/surbitcoin.js'),
                'therock': require('./js/therock.js'),
                'tidex': require('./js/tidex.js'),
                'urdubit': require('./js/urdubit.js'),
                'vaultoro': require('./js/vaultoro.js'),
                'vbtc': require('./js/vbtc.js'),
                'virwox': require('./js/virwox.js'),
                'wex': require('./js/wex.js'),
                'xbtce': require('./js/xbtce.js'),
                'yobit': require('./js/yobit.js'),
                'yunbi': require('./js/yunbi.js'),
                'zaif': require('./js/zaif.js'),
                'zb': require('./js/zb.js'),
            };
            module.exports = Object.assign({ version: version, Exchange: Exchange, exchanges: Object.keys(exchanges) }, exchanges, functions, errors);
        }, { "./js/_1broker.js": 3, "./js/_1btcxe.js": 4, "./js/acx.js": 5, "./js/allcoin.js": 6, "./js/anxpro.js": 7, "./js/base/Exchange": 8, "./js/base/errors": 10, "./js/base/functions": 11, "./js/bibox.js": 22, "./js/binance.js": 23, "./js/bit2c.js": 24, "./js/bitbay.js": 25, "./js/bitcoincoid.js": 26, "./js/bitfinex.js": 27, "./js/bitfinex2.js": 28, "./js/bitflyer.js": 29, "./js/bithumb.js": 30, "./js/bitlish.js": 31, "./js/bitmarket.js": 32, "./js/bitmex.js": 33, "./js/bitso.js": 34, "./js/bitstamp.js": 35, "./js/bitstamp1.js": 36, "./js/bittrex.js": 37, "./js/bitz.js": 38, "./js/bl3p.js": 39, "./js/bleutrade.js": 40, "./js/braziliex.js": 41, "./js/btcbox.js": 42, "./js/btcchina.js": 43, "./js/btcexchange.js": 44, "./js/btcmarkets.js": 45, "./js/btctradeim.js": 46, "./js/btctradeua.js": 47, "./js/btcturk.js": 48, "./js/btcx.js": 49, "./js/bxinth.js": 50, "./js/ccex.js": 51, "./js/cex.js": 52, "./js/chbtc.js": 53, "./js/chilebit.js": 54, "./js/cobinhood.js": 55, "./js/coincheck.js": 56, "./js/coinegg.js": 57, "./js/coinexchange.js": 58, "./js/coinfloor.js": 59, "./js/coingi.js": 60, "./js/coinmarketcap.js": 61, "./js/coinmate.js": 62, "./js/coinsecure.js": 63, "./js/coinspot.js": 64, "./js/coolcoin.js": 65, "./js/cryptopia.js": 66, "./js/dsx.js": 67, "./js/exmo.js": 68, "./js/flowbtc.js": 69, "./js/foxbit.js": 70, "./js/fybse.js": 71, "./js/fybsg.js": 72, "./js/gatecoin.js": 73, "./js/gateio.js": 74, "./js/gdax.js": 75, "./js/gemini.js": 76, "./js/getbtc.js": 77, "./js/hitbtc.js": 78, "./js/hitbtc2.js": 79, "./js/huobi.js": 80, "./js/huobicny.js": 81, "./js/huobipro.js": 82, "./js/independentreserve.js": 83, "./js/itbit.js": 84, "./js/jubi.js": 85, "./js/kraken.js": 86, "./js/kucoin.js": 87, "./js/kuna.js": 88, "./js/lakebtc.js": 89, "./js/liqui.js": 90, "./js/livecoin.js": 91, "./js/luno.js": 92, "./js/lykke.js": 93, "./js/mercado.js": 94, "./js/mixcoins.js": 95, "./js/nova.js": 96, "./js/okcoincny.js": 97, "./js/okcoinusd.js": 98, "./js/okex.js": 99, "./js/paymium.js": 100, "./js/poloniex.js": 101, "./js/qryptos.js": 102, "./js/quadrigacx.js": 103, "./js/quoinex.js": 104, "./js/southxchange.js": 105, "./js/surbitcoin.js": 106, "./js/therock.js": 107, "./js/tidex.js": 108, "./js/urdubit.js": 109, "./js/vaultoro.js": 110, "./js/vbtc.js": 111, "./js/virwox.js": 112, "./js/wex.js": 113, "./js/xbtce.js": 114, "./js/yobit.js": 115, "./js/yunbi.js": 116, "./js/zaif.js": 117, "./js/zb.js": 118 }], 3: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, NotSupported = _a.NotSupported;
            module.exports = (function (_super) {
                __extends(_1broker, _super);
                function _1broker() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                _1broker.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': '_1broker',
                        'name': '1Broker',
                        'countries': 'US',
                        'rateLimit': 1500,
                        'version': 'v2',
                        'has': {
                            'publicAPI': false,
                            'CORS': true,
                            'fetchTrades': false,
                            'fetchOHLCV': true,
                        },
                        'timeframes': {
                            '1m': '60',
                            '15m': '900',
                            '1h': '3600',
                            '1d': '86400',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766021-420bd9fc-5ecb-11e7-8ed6-56d0081efed2.jpg',
                            'api': 'https://1broker.com/api',
                            'www': 'https://1broker.com',
                            'doc': 'https://1broker.com/?c=en/content/api-documentation',
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': false,
                        },
                        'api': {
                            'private': {
                                'get': [
                                    'market/bars',
                                    'market/categories',
                                    'market/details',
                                    'market/list',
                                    'market/quotes',
                                    'market/ticks',
                                    'order/cancel',
                                    'order/create',
                                    'order/open',
                                    'position/close',
                                    'position/close_cancel',
                                    'position/edit',
                                    'position/history',
                                    'position/open',
                                    'position/shared/get',
                                    'social/profile_statistics',
                                    'social/profile_trades',
                                    'user/bitcoin_deposit_address',
                                    'user/details',
                                    'user/overview',
                                    'user/quota_status',
                                    'user/transaction_log',
                                ],
                            },
                        },
                    });
                };
                _1broker.prototype.fetchCategories = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, categories, result, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetMarketCategories()];
                                case 1:
                                    response = _a.sent();
                                    categories = response['response'];
                                    result = [];
                                    for (i = 0; i < categories.length; i++) {
                                        if (categories[i])
                                            result.push(categories[i]);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                _1broker.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var this_, categories, result, c, category, markets, p, market, id, symbol, base, quote, parts;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this_ = this;
                                    return [4, this.fetchCategories()];
                                case 1:
                                    categories = _a.sent();
                                    result = [];
                                    c = 0;
                                    _a.label = 2;
                                case 2:
                                    if (!(c < categories.length)) return [3, 5];
                                    category = categories[c];
                                    return [4, this_.privateGetMarketList({
                                            'category': category.toLowerCase(),
                                        })];
                                case 3:
                                    markets = _a.sent();
                                    for (p = 0; p < markets['response'].length; p++) {
                                        market = markets['response'][p];
                                        id = market['symbol'];
                                        symbol = undefined;
                                        base = undefined;
                                        quote = undefined;
                                        if ((category === 'FOREX') || (category === 'CRYPTO')) {
                                            symbol = market['name'];
                                            parts = symbol.split('/');
                                            base = parts[0];
                                            quote = parts[1];
                                        }
                                        else {
                                            base = id;
                                            quote = 'USD';
                                            symbol = base + '/' + quote;
                                        }
                                        base = this_.commonCurrencyCode(base);
                                        quote = this_.commonCurrencyCode(quote);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    _a.label = 4;
                                case 4:
                                    c++;
                                    return [3, 2];
                                case 5: return [2, result];
                            }
                        });
                    });
                };
                _1broker.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balance, response, result, currencies, c, currency, total;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetUserOverview()];
                                case 2:
                                    balance = _a.sent();
                                    response = balance['response'];
                                    result = {
                                        'info': response,
                                    };
                                    currencies = Object.keys(this.currencies);
                                    for (c = 0; c < currencies.length; c++) {
                                        currency = currencies[c];
                                        result[currency] = this.account();
                                    }
                                    total = parseFloat(response['balance']);
                                    result['BTC']['free'] = total;
                                    result['BTC']['total'] = total;
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                _1broker.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderbook, timestamp, bidPrice, askPrice, bid, ask;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetMarketQuotes(this.extend({
                                            'symbols': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['response'][0];
                                    timestamp = this.parse8601(orderbook['updated']);
                                    bidPrice = parseFloat(orderbook['bid']);
                                    askPrice = parseFloat(orderbook['ask']);
                                    bid = [bidPrice, undefined];
                                    ask = [askPrice, undefined];
                                    return [2, {
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'bids': [bid],
                                            'asks': [ask],
                                        }];
                            }
                        });
                    });
                };
                _1broker.prototype.fetchTrades = function (symbol) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new NotSupported(this.id + ' fetchTrades () method not implemented yet');
                        });
                    });
                };
                _1broker.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var result, ticker, timestamp, open, close, change;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetMarketBars(this.extend({
                                            'symbol': this.marketId(symbol),
                                            'resolution': 60,
                                            'limit': 1,
                                        }, params))];
                                case 2:
                                    result = _a.sent();
                                    ticker = result['response'][0];
                                    timestamp = this.parse8601(ticker['date']);
                                    open = parseFloat(ticker['o']);
                                    close = parseFloat(ticker['c']);
                                    change = close - open;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['h']),
                                            'low': parseFloat(ticker['l']),
                                            'bid': undefined,
                                            'ask': undefined,
                                            'vwap': undefined,
                                            'open': open,
                                            'close': close,
                                            'last': close,
                                            'previousClose': undefined,
                                            'change': change,
                                            'percentage': change / open * 100,
                                            'average': undefined,
                                            'baseVolume': undefined,
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                _1broker.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        this.parse8601(ohlcv['date']),
                        parseFloat(ohlcv['o']),
                        parseFloat(ohlcv['h']),
                        parseFloat(ohlcv['l']),
                        parseFloat(ohlcv['c']),
                        undefined,
                    ];
                };
                _1broker.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'resolution': this.timeframes[timeframe],
                                    };
                                    if (typeof since !== 'undefined')
                                        request['date_start'] = this.iso8601(since);
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.privateGetMarketBars(this.extend(request, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, this.parseOHLCVs(result['response'], market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                _1broker.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'symbol': this.marketId(symbol),
                                        'margin': amount,
                                        'direction': (side === 'sell') ? 'short' : 'long',
                                        'leverage': 1,
                                        'type': side,
                                    };
                                    if (type === 'limit')
                                        order['price'] = price;
                                    else
                                        order['type'] += '_market';
                                    return [4, this.privateGetOrderCreate(this.extend(order, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result['response']['order_id'],
                                        }];
                            }
                        });
                    });
                };
                _1broker.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrderCancel({ 'order_id': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                _1broker.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    this.checkRequiredCredentials();
                    var url = this.urls['api'] + '/' + this.version + '/' + path + '.php';
                    var query = this.extend({ 'token': this.apiKey }, params);
                    url += '?' + this.urlencode(query);
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                _1broker.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('warning' in response)
                                        if (response['warning'])
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    if ('error' in response)
                                        if (response['error'])
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return _1broker;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 4: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(_1btcxe, _super);
                function _1btcxe() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                _1btcxe.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': '_1btcxe',
                        'name': '1BTCXE',
                        'countries': 'PA',
                        'comment': 'Crypto Capital API',
                        'has': {
                            'CORS': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1d': '1year',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766049-2b294408-5ecc-11e7-85cc-adaff013dc1a.jpg',
                            'api': 'https://1btcxe.com/api',
                            'www': 'https://1btcxe.com',
                            'doc': 'https://1btcxe.com/api-docs.php',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'stats',
                                    'historical-prices',
                                    'order-book',
                                    'transactions',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balances-and-info',
                                    'open-orders',
                                    'user-transactions',
                                    'btc-deposit-address/get',
                                    'btc-deposit-address/new',
                                    'deposits/get',
                                    'withdrawals/get',
                                    'orders/new',
                                    'orders/edit',
                                    'orders/cancel',
                                    'orders/status',
                                    'withdrawals/new',
                                ],
                            },
                        },
                    });
                };
                _1btcxe.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2, [
                                    { 'id': 'USD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                                    { 'id': 'EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                                    { 'id': 'CNY', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY' },
                                    { 'id': 'RUB', 'symbol': 'BTC/RUB', 'base': 'BTC', 'quote': 'RUB' },
                                    { 'id': 'CHF', 'symbol': 'BTC/CHF', 'base': 'BTC', 'quote': 'CHF' },
                                    { 'id': 'JPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
                                    { 'id': 'GBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
                                    { 'id': 'CAD', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD' },
                                    { 'id': 'AUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
                                    { 'id': 'AED', 'symbol': 'BTC/AED', 'base': 'BTC', 'quote': 'AED' },
                                    { 'id': 'BGN', 'symbol': 'BTC/BGN', 'base': 'BTC', 'quote': 'BGN' },
                                    { 'id': 'CZK', 'symbol': 'BTC/CZK', 'base': 'BTC', 'quote': 'CZK' },
                                    { 'id': 'DKK', 'symbol': 'BTC/DKK', 'base': 'BTC', 'quote': 'DKK' },
                                    { 'id': 'HKD', 'symbol': 'BTC/HKD', 'base': 'BTC', 'quote': 'HKD' },
                                    { 'id': 'HRK', 'symbol': 'BTC/HRK', 'base': 'BTC', 'quote': 'HRK' },
                                    { 'id': 'HUF', 'symbol': 'BTC/HUF', 'base': 'BTC', 'quote': 'HUF' },
                                    { 'id': 'ILS', 'symbol': 'BTC/ILS', 'base': 'BTC', 'quote': 'ILS' },
                                    { 'id': 'INR', 'symbol': 'BTC/INR', 'base': 'BTC', 'quote': 'INR' },
                                    { 'id': 'MUR', 'symbol': 'BTC/MUR', 'base': 'BTC', 'quote': 'MUR' },
                                    { 'id': 'MXN', 'symbol': 'BTC/MXN', 'base': 'BTC', 'quote': 'MXN' },
                                    { 'id': 'NOK', 'symbol': 'BTC/NOK', 'base': 'BTC', 'quote': 'NOK' },
                                    { 'id': 'NZD', 'symbol': 'BTC/NZD', 'base': 'BTC', 'quote': 'NZD' },
                                    { 'id': 'PLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                                    { 'id': 'RON', 'symbol': 'BTC/RON', 'base': 'BTC', 'quote': 'RON' },
                                    { 'id': 'SEK', 'symbol': 'BTC/SEK', 'base': 'BTC', 'quote': 'SEK' },
                                    { 'id': 'SGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
                                    { 'id': 'THB', 'symbol': 'BTC/THB', 'base': 'BTC', 'quote': 'THB' },
                                    { 'id': 'TRY', 'symbol': 'BTC/TRY', 'base': 'BTC', 'quote': 'TRY' },
                                    { 'id': 'ZAR', 'symbol': 'BTC/ZAR', 'base': 'BTC', 'quote': 'ZAR' },
                                ]];
                        });
                    });
                };
                _1btcxe.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balance, result, currencies, i, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostBalancesAndInfo()];
                                case 1:
                                    response = _a.sent();
                                    balance = response['balances-and-info'];
                                    result = { 'info': balance };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        account = this.account();
                                        account['free'] = this.safeFloat(balance['available'], currency, 0.0);
                                        account['used'] = this.safeFloat(balance['on_hold'], currency, 0.0);
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                _1btcxe.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetOrderBook(this.extend({
                                        'currency': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseOrderBook(response['order-book'], undefined, 'bid', 'ask', 'price', 'order_amount')];
                            }
                        });
                    });
                };
                _1btcxe.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, ticker, last;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetStats(this.extend({
                                        'currency': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    ticker = response['stats'];
                                    last = parseFloat(ticker['last_price']);
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': undefined,
                                            'datetime': undefined,
                                            'high': parseFloat(ticker['max']),
                                            'low': parseFloat(ticker['min']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': undefined,
                                            'open': parseFloat(ticker['open']),
                                            'close': last,
                                            'last': last,
                                            'previousClose': undefined,
                                            'change': parseFloat(ticker['daily_change']),
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': undefined,
                                            'quoteVolume': parseFloat(ticker['total_btc_traded']),
                                        }];
                            }
                        });
                    });
                };
                _1btcxe.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1d'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        this.parse8601(ohlcv['date'] + ' 00:00:00'),
                        undefined,
                        undefined,
                        undefined,
                        parseFloat(ohlcv['price']),
                        undefined,
                    ];
                };
                _1btcxe.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1d'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ohlcvs;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetHistoricalPrices(this.extend({
                                            'currency': market['id'],
                                            'timeframe': this.timeframes[timeframe],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    ohlcvs = this.omit(response['historical-prices'], 'request_currency');
                                    return [2, this.parseOHLCVs(ohlcvs, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                _1btcxe.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(trade['timestamp']) * 1000;
                    return {
                        'id': trade['id'],
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'order': undefined,
                        'type': undefined,
                        'side': trade['maker_type'],
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                _1btcxe.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetTransactions(this.extend({
                                            'currency': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    trades = this.omit(response['transactions'], 'request_currency');
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                _1btcxe.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    order = {
                                        'side': side,
                                        'type': type,
                                        'currency': this.marketId(symbol),
                                        'amount': amount,
                                    };
                                    if (type === 'limit')
                                        order['limit_price'] = price;
                                    return [4, this.privatePostOrdersNew(this.extend(order, params))];
                                case 1:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result,
                                        }];
                            }
                        });
                    });
                };
                _1btcxe.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostOrdersCancel({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                _1btcxe.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostWithdrawalsNew(this.extend({
                                            'currency': currency,
                                            'amount': parseFloat(amount),
                                            'address': address,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['result']['uuid'],
                                        }];
                            }
                        });
                    });
                };
                _1btcxe.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    if (this.id === 'cryptocapital')
                        throw new ExchangeError(this.id + ' is an abstract base API for _1btcxe');
                    var url = this.urls['api'] + '/' + path;
                    if (api === 'public') {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var query = this.extend({
                            'api_key': this.apiKey,
                            'nonce': this.nonce(),
                        }, params);
                        var request = this.json(query);
                        query['signature'] = this.hmac(this.encode(request), this.encode(this.secret));
                        body = this.json(query);
                        headers = { 'Content-Type': 'application/json' };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                _1btcxe.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, errors, e, error;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('errors' in response) {
                                        errors = [];
                                        for (e = 0; e < response['errors'].length; e++) {
                                            error = response['errors'][e];
                                            errors.push(error['code'] + ': ' + error['message']);
                                        }
                                        errors = errors.join(' ');
                                        throw new ExchangeError(this.id + ' ' + errors);
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return _1btcxe;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 5: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound;
            module.exports = (function (_super) {
                __extends(acx, _super);
                function acx() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                acx.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'acx',
                        'name': 'ACX',
                        'countries': 'AU',
                        'rateLimit': 1000,
                        'version': 'v2',
                        'has': {
                            'CORS': true,
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1m': '1',
                            '5m': '5',
                            '15m': '15',
                            '30m': '30',
                            '1h': '60',
                            '2h': '120',
                            '4h': '240',
                            '12h': '720',
                            '1d': '1440',
                            '3d': '4320',
                            '1w': '10080',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/30247614-1fe61c74-9621-11e7-9e8c-f1a627afa279.jpg',
                            'extension': '.json',
                            'api': 'https://acx.io/api',
                            'www': 'https://acx.io',
                            'doc': 'https://acx.io/documents/api_v2',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'markets',
                                    'tickers',
                                    'tickers/{market}',
                                    'trades',
                                    'order_book',
                                    'depth',
                                    'k',
                                    'k_with_pending_trades',
                                    'timestamp',
                                ],
                            },
                            'private': {
                                'get': [
                                    'members/me',
                                    'deposits',
                                    'deposit',
                                    'deposit_address',
                                    'orders',
                                    'order',
                                    'trades/my',
                                    'withdraws',
                                    'withdraw',
                                ],
                                'post': [
                                    'orders',
                                    'orders/multi',
                                    'orders/clear',
                                    'order/delete',
                                    'withdraw',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'maker': 0.2 / 100,
                                'taker': 0.2 / 100,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': true,
                                'withdraw': {},
                            },
                        },
                        'exceptions': {
                            '2002': InsufficientFunds,
                            '2003': OrderNotFound,
                        },
                    });
                };
                acx.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, symbol, _a, base, quote;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetMarkets()];
                                case 1:
                                    markets = _c.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['id'];
                                        symbol = market['name'];
                                        _a = __read(symbol.split('/'), 2), base = _a[0], quote = _a[1];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                acx.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, uppercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetMembersMe()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['accounts'];
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        uppercase = currency.toUpperCase();
                                        account = {
                                            'free': parseFloat(balance['balance']),
                                            'used': parseFloat(balance['locked']),
                                            'total': 0.0,
                                        };
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[uppercase] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                acx.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, orderbook, timestamp, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'market': market['id'],
                                    };
                                    if (typeof limit === 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetDepth(this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = orderbook['timestamp'] * 1000;
                                    result = this.parseOrderBook(orderbook, timestamp);
                                    result['bids'] = this.sortBy(result['bids'], 0, true);
                                    result['asks'] = this.sortBy(result['asks'], 0);
                                    return [2, result];
                            }
                        });
                    });
                };
                acx.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['at'] * 1000;
                    ticker = ticker['ticker'];
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high', undefined),
                        'low': this.safeFloat(ticker, 'low', undefined),
                        'bid': this.safeFloat(ticker, 'buy', undefined),
                        'ask': this.safeFloat(ticker, 'sell', undefined),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last', undefined),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'vol', undefined),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                acx.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, ids, result, i, id, market, symbol, base, quote, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickers(params)];
                                case 2:
                                    tickers = _a.sent();
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = undefined;
                                        symbol = id;
                                        if (id in this.markets_by_id) {
                                            market = this.markets_by_id[id];
                                            symbol = market['symbol'];
                                        }
                                        else {
                                            base = id.slice(0, 3);
                                            quote = id.slice(3, 6);
                                            base = base.toUpperCase();
                                            quote = quote.toUpperCase();
                                            base = this.commonCurrencyCode(base);
                                            quote = this.commonCurrencyCode(quote);
                                            symbol = base + '/' + quote;
                                        }
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                acx.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTickersMarket(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTicker(response, market)];
                            }
                        });
                    });
                };
                acx.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(trade['created_at']);
                    return {
                        'id': trade['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': this.safeFloat(trade, 'price'),
                        'amount': this.safeFloat(trade, 'volume'),
                        'cost': this.safeFloat(trade, 'funds'),
                        'info': trade,
                    };
                };
                acx.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrades(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                acx.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv[0] * 1000,
                        ohlcv[1],
                        ohlcv[2],
                        ohlcv[3],
                        ohlcv[4],
                        ohlcv[5],
                    ];
                };
                acx.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    if (!limit)
                                        limit = 500;
                                    request = {
                                        'market': market['id'],
                                        'period': this.timeframes[timeframe],
                                        'limit': limit,
                                    };
                                    if (typeof since !== 'undefined')
                                        request['timestamp'] = since;
                                    return [4, this.publicGetK(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                acx.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    else {
                        var marketId = order['market'];
                        symbol = this.markets_by_id[marketId]['symbol'];
                    }
                    var timestamp = this.parse8601(order['created_at']);
                    var state = order['state'];
                    var status = undefined;
                    if (state === 'done') {
                        status = 'closed';
                    }
                    else if (state === 'wait') {
                        status = 'open';
                    }
                    else if (state === 'cancel') {
                        status = 'canceled';
                    }
                    return {
                        'id': order['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': status,
                        'symbol': symbol,
                        'type': order['ord_type'],
                        'side': order['side'],
                        'price': parseFloat(order['price']),
                        'amount': parseFloat(order['volume']),
                        'filled': parseFloat(order['executed_volume']),
                        'remaining': parseFloat(order['remaining_volume']),
                        'trades': undefined,
                        'fee': undefined,
                        'info': order,
                    };
                };
                acx.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'market': this.marketId(symbol),
                                        'side': side,
                                        'volume': amount.toString(),
                                        'ord_type': type,
                                    };
                                    if (type === 'limit') {
                                        order['price'] = price.toString();
                                    }
                                    return [4, this.privatePostOrders(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    market = this.markets_by_id[response['market']];
                                    return [2, this.parseOrder(response, market)];
                            }
                        });
                    });
                };
                acx.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var result, order, status;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrderDelete({ 'id': id })];
                                case 2:
                                    result = _a.sent();
                                    order = this.parseOrder(result);
                                    status = order['status'];
                                    if (status === 'closed' || status === 'canceled') {
                                        throw new OrderNotFound(this.id + ' ' + this.json(order));
                                    }
                                    return [2, order];
                            }
                        });
                    });
                };
                acx.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostWithdraw(this.extend({
                                            'currency': currency.toLowerCase(),
                                            'sum': amount,
                                            'address': address,
                                        }, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                acx.prototype.nonce = function () {
                    return this.milliseconds();
                };
                acx.prototype.encodeParams = function (params) {
                    if ('orders' in params) {
                        var orders = params['orders'];
                        var query = this.urlencode(this.keysort(this.omit(params, 'orders')));
                        for (var i = 0; i < orders.length; i++) {
                            var order = orders[i];
                            var keys = Object.keys(order);
                            for (var k = 0; k < keys.length; k++) {
                                var key = keys[k];
                                var value = order[key];
                                query += '&orders%5B%5D%5B' + key + '%5D=' + value.toString();
                            }
                        }
                        return query;
                    }
                    return this.urlencode(this.keysort(params));
                };
                acx.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var request = '/api' + '/' + this.version + '/' + this.implodeParams(path, params);
                    if ('extension' in this.urls)
                        request += this.urls['extension'];
                    var query = this.omit(params, this.extractParams(path));
                    var url = this.urls['api'] + request;
                    if (api === 'public') {
                        if (Object.keys(query).length) {
                            url += '?' + this.urlencode(query);
                        }
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var query_1 = this.encodeParams(this.extend({
                            'access_key': this.apiKey,
                            'tonce': nonce,
                        }, params));
                        var auth = method + '|' + request + '|' + query_1;
                        var signature = this.hmac(this.encode(auth), this.encode(this.secret));
                        var suffix = query_1 + '&signature=' + signature;
                        if (method === 'GET') {
                            url += '?' + suffix;
                        }
                        else {
                            body = suffix;
                            headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
                        }
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                acx.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code === 400) {
                        var response = JSON.parse(body);
                        var error = this.safeValue(response, 'error');
                        var errorCode = this.safeString(error, 'code');
                        var feedback = this.id + ' ' + this.json(response);
                        var exceptions = this.exceptions;
                        if (errorCode in exceptions) {
                            throw new exceptions[errorCode](feedback);
                        }
                    }
                };
                return acx;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 6: [function (require, module, exports) {
            'use strict';
            var okcoinusd = require('./okcoinusd.js');
            module.exports = (function (_super) {
                __extends(allcoin, _super);
                function allcoin() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                allcoin.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'allcoin',
                        'name': 'Allcoin',
                        'countries': 'CA',
                        'has': {
                            'CORS': false,
                        },
                        'extension': '',
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/31561809-c316b37c-b061-11e7-8d5a-b547b4d730eb.jpg',
                            'api': {
                                'web': 'https://www.allcoin.com',
                                'public': 'https://api.allcoin.com/api',
                                'private': 'https://api.allcoin.com/api',
                            },
                            'www': 'https://www.allcoin.com',
                            'doc': 'https://www.allcoin.com/About/APIReference',
                        },
                        'api': {
                            'web': {
                                'get': [
                                    'Home/MarketOverViewDetail/',
                                ],
                            },
                            'public': {
                                'get': [
                                    'depth',
                                    'kline',
                                    'ticker',
                                    'trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    'batch_trade',
                                    'cancel_order',
                                    'order_history',
                                    'order_info',
                                    'orders_info',
                                    'repayment',
                                    'trade',
                                    'trade_history',
                                    'userinfo',
                                ],
                            },
                        },
                        'markets': undefined,
                    });
                };
                allcoin.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var result, response, coins, j, markets, k, market, base, quote, id, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    result = [];
                                    return [4, this.webGetHomeMarketOverViewDetail()];
                                case 1:
                                    response = _a.sent();
                                    coins = response['marketCoins'];
                                    for (j = 0; j < coins.length; j++) {
                                        markets = coins[j]['Markets'];
                                        for (k = 0; k < markets.length; k++) {
                                            market = markets[k]['Market'];
                                            base = market['Primary'];
                                            quote = market['Secondary'];
                                            id = base.toLowerCase() + '_' + quote.toLowerCase();
                                            symbol = base + '/' + quote;
                                            result.push({
                                                'id': id,
                                                'symbol': symbol,
                                                'base': base,
                                                'quote': quote,
                                                'type': 'spot',
                                                'spot': true,
                                                'future': false,
                                                'info': market,
                                            });
                                        }
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                allcoin.prototype.parseOrderStatus = function (status) {
                    if (status === -1)
                        return 'canceled';
                    if (status === 0)
                        return 'open';
                    if (status === 1)
                        return 'open';
                    if (status === 2)
                        return 'closed';
                    if (status === 10)
                        return 'canceled';
                    return status;
                };
                allcoin.prototype.getCreateDateField = function () {
                    return 'create_data';
                };
                allcoin.prototype.getOrdersField = function () {
                    return 'order';
                };
                return allcoin;
            }(okcoinusd));
        }, { "./okcoinusd.js": 98 }], 7: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(anxpro, _super);
                function anxpro() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                anxpro.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'anxpro',
                        'name': 'ANXPro',
                        'countries': ['JP', 'SG', 'HK', 'NZ'],
                        'version': '2',
                        'rateLimit': 1500,
                        'has': {
                            'CORS': false,
                            'fetchOHLCV': false,
                            'fetchTrades': false,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27765983-fd8595da-5ec9-11e7-82e3-adb3ab8c2612.jpg',
                            'api': 'https://anxpro.com/api',
                            'www': 'https://anxpro.com',
                            'doc': [
                                'http://docs.anxv2.apiary.io',
                                'https://anxpro.com/pages/api',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    '{currency_pair}/money/ticker',
                                    '{currency_pair}/money/depth/full',
                                    '{currency_pair}/money/trade/fetch',
                                ],
                            },
                            'private': {
                                'post': [
                                    '{currency_pair}/money/order/add',
                                    '{currency_pair}/money/order/cancel',
                                    '{currency_pair}/money/order/quote',
                                    '{currency_pair}/money/order/result',
                                    '{currency_pair}/money/orders',
                                    'money/{currency}/address',
                                    'money/{currency}/send_simple',
                                    'money/info',
                                    'money/trade/list',
                                    'money/wallet/history',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/USD': { 'id': 'BTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'multiplier': 100000 },
                            'BTC/HKD': { 'id': 'BTCHKD', 'symbol': 'BTC/HKD', 'base': 'BTC', 'quote': 'HKD', 'multiplier': 100000 },
                            'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'multiplier': 100000 },
                            'BTC/CAD': { 'id': 'BTCCAD', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD', 'multiplier': 100000 },
                            'BTC/AUD': { 'id': 'BTCAUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD', 'multiplier': 100000 },
                            'BTC/SGD': { 'id': 'BTCSGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD', 'multiplier': 100000 },
                            'BTC/JPY': { 'id': 'BTCJPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY', 'multiplier': 100000 },
                            'BTC/GBP': { 'id': 'BTCGBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP', 'multiplier': 100000 },
                            'BTC/NZD': { 'id': 'BTCNZD', 'symbol': 'BTC/NZD', 'base': 'BTC', 'quote': 'NZD', 'multiplier': 100000 },
                            'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'multiplier': 100000 },
                            'STR/BTC': { 'id': 'STRBTC', 'symbol': 'STR/BTC', 'base': 'STR', 'quote': 'BTC', 'multiplier': 100000000 },
                            'XRP/BTC': { 'id': 'XRPBTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'multiplier': 100000000 },
                            'DOGE/BTC': { 'id': 'DOGEBTC', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC', 'multiplier': 100000000 },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.3 / 100,
                                'taker': 0.6 / 100,
                            },
                        },
                    });
                };
                anxpro.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balance, currencies, result, c, currency, account, wallet;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostMoneyInfo()];
                                case 1:
                                    response = _a.sent();
                                    balance = response['data'];
                                    currencies = Object.keys(balance['Wallets']);
                                    result = { 'info': balance };
                                    for (c = 0; c < currencies.length; c++) {
                                        currency = currencies[c];
                                        account = this.account();
                                        if (currency in balance['Wallets']) {
                                            wallet = balance['Wallets'][currency];
                                            account['free'] = parseFloat(wallet['Available_Balance']['value']);
                                            account['total'] = parseFloat(wallet['Balance']['value']);
                                            account['used'] = account['total'] - account['free'];
                                        }
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                anxpro.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderbook, t, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetCurrencyPairMoneyDepthFull(this.extend({
                                        'currency_pair': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    orderbook = response['data'];
                                    t = parseInt(orderbook['dataUpdateTime']);
                                    timestamp = parseInt(t / 1000);
                                    return [2, this.parseOrderBook(orderbook, timestamp, 'bids', 'asks', 'price', 'amount')];
                            }
                        });
                    });
                };
                anxpro.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, ticker, t, timestamp, bid, ask, baseVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetCurrencyPairMoneyTicker(this.extend({
                                        'currency_pair': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    ticker = response['data'];
                                    t = parseInt(ticker['dataUpdateTime']);
                                    timestamp = parseInt(t / 1000);
                                    bid = this.safeFloat(ticker['buy'], 'value');
                                    ask = this.safeFloat(ticker['sell'], 'value');
                                    baseVolume = parseFloat(ticker['vol']['value']);
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']['value']),
                                            'low': parseFloat(ticker['low']['value']),
                                            'bid': bid,
                                            'ask': ask,
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']['value']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': parseFloat(ticker['avg']['value']),
                                            'baseVolume': baseVolume,
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                anxpro.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new ExchangeError(this.id + ' switched off the trades endpoint, see their docs at http://docs.anxv2.apiary.io/reference/market-data/currencypairmoneytradefetch-disabled');
                        });
                    });
                };
                anxpro.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, order, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    order = {
                                        'currency_pair': market['id'],
                                        'amount_int': parseInt(amount * 100000000),
                                    };
                                    if (type === 'limit') {
                                        order['price_int'] = parseInt(price * market['multiplier']);
                                    }
                                    order['type'] = (side === 'buy') ? 'bid' : 'ask';
                                    return [4, this.privatePostCurrencyPairMoneyOrderAdd(this.extend(order, params))];
                                case 1:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result['data'],
                                        }];
                            }
                        });
                    });
                };
                anxpro.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCurrencyPairMoneyOrderCancel({ 'oid': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                anxpro.prototype.getAmountMultiplier = function (currency) {
                    if (currency === 'BTC') {
                        return 100000000;
                    }
                    else if (currency === 'LTC') {
                        return 100000000;
                    }
                    else if (currency === 'STR') {
                        return 100000000;
                    }
                    else if (currency === 'XRP') {
                        return 100000000;
                    }
                    else if (currency === 'DOGE') {
                        return 100000000;
                    }
                    return 100;
                };
                anxpro.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var multiplier, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    multiplier = this.getAmountMultiplier(currency);
                                    return [4, this.privatePostMoneyCurrencySendSimple(this.extend({
                                            'currency': currency,
                                            'amount_int': parseInt(amount * multiplier),
                                            'address': address,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['data']['transactionId'],
                                        }];
                            }
                        });
                    });
                };
                anxpro.prototype.nonce = function () {
                    return this.milliseconds();
                };
                anxpro.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var request = this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    var url = this.urls['api'] + '/' + this.version + '/' + request;
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({ 'nonce': nonce }, query));
                        var secret = this.base64ToBinary(this.secret);
                        var auth = request + '\0' + body;
                        var signature = this.hmac(this.encode(auth), secret, 'sha512', 'base64');
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Rest-Key': this.apiKey,
                            'Rest-Sign': this.decode(signature),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                anxpro.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('result' in response)
                                        if (response['result'] === 'success')
                                            return [2, response];
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                return anxpro;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 8: [function (require, module, exports) {
            (function (process) {
                "use strict";
                var functions = require('./functions'), Market = require('./Market');
                var isNode = functions.isNode, keys = functions.keys, values = functions.values, deepExtend = functions.deepExtend, extend = functions.extend, flatten = functions.flatten, unique = functions.unique, indexBy = functions.indexBy, sortBy = functions.sortBy, groupBy = functions.groupBy, aggregate = functions.aggregate, uuid = functions.uuid, unCamelCase = functions.unCamelCase, precisionFromString = functions.precisionFromString, throttle = functions.throttle, capitalize = functions.capitalize, now = functions.now, sleep = functions.sleep, timeout = functions.timeout, TimedOut = functions.TimedOut, buildOHLCVC = functions.buildOHLCVC;
                var _a = require('./errors'), ExchangeError = _a.ExchangeError, InvalidAddress = _a.InvalidAddress, NotSupported = _a.NotSupported, AuthenticationError = _a.AuthenticationError, DDoSProtection = _a.DDoSProtection, RequestTimeout = _a.RequestTimeout, ExchangeNotAvailable = _a.ExchangeNotAvailable;
                var defaultFetch = isNode ? require('fetch-ponyfill')().fetch : fetch;
                var journal = undefined;
                module.exports = (function () {
                    function Exchange(userConfig) {
                        if (userConfig === void 0) { userConfig = {}; }
                        var _this = this;
                        Object.assign(this, functions, { encode: function (string) { return string; }, decode: function (string) { return string; } });
                        if (isNode)
                            this.nodeVersion = process.version.match(/\d+\.\d+.\d+/)[0];
                        this.options = {};
                        this.userAgents = {
                            'chrome': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36',
                            'chrome39': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                        };
                        this.headers = {};
                        this.proxy = '';
                        this.origin = '*';
                        this.iso8601 = function (timestamp) { return ((typeof timestamp === 'undefined') ? timestamp : new Date(timestamp).toISOString()); };
                        this.parse8601 = function (x) { return Date.parse(((x.indexOf('+') >= 0) || (x.slice(-1) === 'Z')) ? x : (x + 'Z')); };
                        this.parseDate = function (x) {
                            if (typeof x === 'undefined')
                                return x;
                            return ((x.indexOf('GMT') >= 0) ?
                                Date.parse(x) :
                                _this.parse8601(x));
                        };
                        this.microseconds = function () { return now() * 1000; };
                        this.seconds = function () { return Math.floor(now() / 1000); };
                        this.minFundingAddressLength = 10;
                        this.substituteCommonCurrencyCodes = true;
                        this.fetchImplementation = defaultFetch;
                        this.timeout = 10000;
                        this.verbose = false;
                        this.debug = false;
                        this.journal = 'debug.json';
                        this.userAgent = undefined;
                        this.twofa = false;
                        this.apiKey = undefined;
                        this.secret = undefined;
                        this.uid = undefined;
                        this.login = undefined;
                        this.password = undefined;
                        this.balance = {};
                        this.orderbooks = {};
                        this.tickers = {};
                        this.orders = {};
                        this.trades = {};
                        this.last_http_response = undefined;
                        this.last_json_response = undefined;
                        this.last_response_headers = undefined;
                        this.arrayConcat = function (a, b) { return a.concat(b); };
                        var unCamelCaseProperties = function (obj) {
                            if (obj === void 0) { obj = _this; }
                            if (obj !== null) {
                                try {
                                    for (var _a = __values(Object.getOwnPropertyNames(obj)), _c = _a.next(); !_c.done; _c = _a.next()) {
                                        var k = _c.value;
                                        _this[unCamelCase(k)] = _this[k];
                                    }
                                }
                                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                                finally {
                                    try {
                                        if (_c && !_c.done && (_d = _a.return)) _d.call(_a);
                                    }
                                    finally { if (e_1) throw e_1.error; }
                                }
                                unCamelCaseProperties(Object.getPrototypeOf(obj));
                            }
                            var e_1, _d;
                        };
                        unCamelCaseProperties();
                        var config = deepExtend(this.describe(), userConfig);
                        try {
                            for (var _a = __values(Object.entries(config)), _c = _a.next(); !_c.done; _c = _a.next()) {
                                var _d = __read(_c.value, 2), property = _d[0], value = _d[1];
                                this[property] = deepExtend(this[property], value);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_e = _a.return)) _e.call(_a);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        for (var k in this.has) {
                            this['has' + capitalize(k)] = !!this.has[k];
                        }
                        if (this.api)
                            this.defineRestApi(this.api, 'request');
                        this.initRestRateLimiter();
                        if (this.markets)
                            this.setMarkets(this.markets);
                        if (this.debug && journal) {
                            journal(function () { return _this.journal; }, this, Object.keys(this.has));
                        }
                        var e_2, _e;
                    }
                    Exchange.prototype.getMarket = function (symbol) {
                        if (!this.marketClasses)
                            this.marketClasses = {};
                        var marketClass = this.marketClasses[symbol];
                        if (marketClass)
                            return marketClass;
                        marketClass = new Market(this, symbol);
                        this.marketClasses[symbol] = marketClass;
                        return marketClass;
                    };
                    Exchange.prototype.describe = function () {
                        return {
                            'id': undefined,
                            'name': undefined,
                            'countries': undefined,
                            'enableRateLimit': false,
                            'rateLimit': 2000,
                            'has': {
                                'CORS': false,
                                'publicAPI': true,
                                'privateAPI': true,
                                'cancelOrder': true,
                                'cancelOrders': false,
                                'createDepositAddress': false,
                                'createOrder': true,
                                'createMarketOrder': true,
                                'createLimitOrder': true,
                                'deposit': false,
                                'editOrder': 'emulated',
                                'fetchBalance': true,
                                'fetchBidsAsks': false,
                                'fetchClosedOrders': false,
                                'fetchCurrencies': false,
                                'fetchDepositAddress': false,
                                'fetchFundingFees': false,
                                'fetchL2OrderBook': true,
                                'fetchMarkets': true,
                                'fetchMyTrades': false,
                                'fetchOHLCV': 'emulated',
                                'fetchOpenOrders': false,
                                'fetchOrder': false,
                                'fetchOrderBook': true,
                                'fetchOrderBooks': false,
                                'fetchOrders': false,
                                'fetchTicker': true,
                                'fetchTickers': false,
                                'fetchTrades': true,
                                'withdraw': false,
                            },
                            'urls': {
                                'logo': undefined,
                                'api': undefined,
                                'www': undefined,
                                'doc': undefined,
                                'fees': undefined,
                            },
                            'api': undefined,
                            'requiredCredentials': {
                                'apiKey': true,
                                'secret': true,
                                'uid': false,
                                'login': false,
                                'password': false,
                            },
                            'markets': undefined,
                            'currencies': {},
                            'timeframes': undefined,
                            'fees': {
                                'trading': {
                                    'tierBased': undefined,
                                    'percentage': undefined,
                                    'taker': undefined,
                                    'maker': undefined,
                                },
                                'funding': {
                                    'tierBased': undefined,
                                    'percentage': undefined,
                                    'withdraw': {},
                                    'deposit': {},
                                },
                            },
                            'parseJsonResponse': true,
                            'skipJsonOnStatusCodes': [],
                            'exceptions': undefined,
                            'dontGetUsedBalanceFromStaleCache': false,
                        };
                    };
                    Exchange.prototype.defaults = function () {
                        return {};
                    };
                    Exchange.prototype.nonce = function () {
                        return this.seconds();
                    };
                    Exchange.prototype.milliseconds = function () {
                        return now();
                    };
                    Exchange.prototype.encodeURIComponent = function () {
                        var args = [];
                        for (var _a = 0; _a < arguments.length; _a++) {
                            args[_a] = arguments[_a];
                        }
                        return encodeURIComponent.apply(void 0, __spread(args));
                    };
                    Exchange.prototype.checkRequiredCredentials = function () {
                        var _this = this;
                        Object.keys(this.requiredCredentials).map(function (key) {
                            if (_this.requiredCredentials[key] && !_this[key])
                                throw new AuthenticationError(_this.id + ' requires `' + key + '`');
                        });
                    };
                    Exchange.prototype.checkAddress = function (address) {
                        if (typeof address === 'undefined')
                            throw new InvalidAddress(this.id + ' address is undefined');
                        if ((unique(address).length < 2) || address.length < this.minFundingAddressLength || address.includes(' '))
                            throw new InvalidAddress(this.id + ' address is invalid or has less than ' + this.minFundingAddressLength.toString() + ' characters: "' + address.toString() + '"');
                        return address;
                    };
                    Exchange.prototype.initRestRateLimiter = function () {
                        var fetchImplementation = this.fetchImplementation;
                        if (this.rateLimit === undefined)
                            throw new Error(this.id + '.rateLimit property is not configured');
                        this.tokenBucket = this.extend({
                            refillRate: 1 / this.rateLimit,
                            delay: 1,
                            capacity: 1,
                            defaultCost: 1,
                            maxCapacity: 1000,
                        }, this.tokenBucket);
                        this.throttle = throttle(this.tokenBucket);
                        this.executeRestRequest = function (url, method, headers, body) {
                            var _this = this;
                            if (method === void 0) { method = 'GET'; }
                            if (headers === void 0) { headers = undefined; }
                            if (body === void 0) { body = undefined; }
                            var promise = fetchImplementation(url, { method: method, headers: headers, body: body, 'agent': this.agent || null, timeout: this.timeout })
                                .catch(function (e) {
                                if (isNode)
                                    throw new ExchangeNotAvailable([_this.id, method, url, e.type, e.message].join(' '));
                                throw e;
                            })
                                .then(function (response) { return _this.handleRestResponse(response, url, method, headers, body); });
                            return timeout(this.timeout, promise).catch(function (e) {
                                if (e instanceof TimedOut)
                                    throw new RequestTimeout(_this.id + ' ' + method + ' ' + url + ' request timed out (' + _this.timeout + ' ms)');
                                throw e;
                            });
                        };
                    };
                    Exchange.prototype.defineRestApi = function (api, methodName, options) {
                        var _this = this;
                        if (options === void 0) { options = {}; }
                        var _loop_1 = function (type) {
                            try {
                                for (var _a = __values(Object.keys(api[type])), _c = _a.next(); !_c.done; _c = _a.next()) {
                                    var httpMethod = _c.value;
                                    var paths = api[type][httpMethod];
                                    var _loop_2 = function (i) {
                                        var path = paths[i].trim();
                                        var splitPath = path.split(/[^a-zA-Z0-9]/);
                                        var uppercaseMethod = httpMethod.toUpperCase();
                                        var lowercaseMethod = httpMethod.toLowerCase();
                                        var camelcaseMethod = this_1.capitalize(lowercaseMethod);
                                        var camelcaseSuffix = splitPath.map(this_1.capitalize).join('');
                                        var underscoreSuffix = splitPath.map(function (x) { return x.trim().toLowerCase(); }).filter(function (x) { return x.length > 0; }).join('_');
                                        var camelcase = type + camelcaseMethod + this_1.capitalize(camelcaseSuffix);
                                        var underscore = type + '_' + lowercaseMethod + '_' + underscoreSuffix;
                                        if ('suffixes' in options) {
                                            if ('camelcase' in options['suffixes'])
                                                camelcase += options['suffixes']['camelcase'];
                                            if ('underscore' in options.suffixes)
                                                underscore += options['suffixes']['underscore'];
                                        }
                                        if ('underscore_suffix' in options)
                                            underscore += options.underscoreSuffix;
                                        if ('camelcase_suffix' in options)
                                            camelcase += options.camelcaseSuffix;
                                        var partial = function (params) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                            return [2, this[methodName](path, type, uppercaseMethod, params || {})];
                                        }); }); };
                                        this_1[camelcase] = partial;
                                        this_1[underscore] = partial;
                                    };
                                    for (var i = 0; i < paths.length; i++) {
                                        _loop_2(i);
                                    }
                                }
                            }
                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_d = _a.return)) _d.call(_a);
                                }
                                finally { if (e_3) throw e_3.error; }
                            }
                            var e_3, _d;
                        };
                        var this_1 = this;
                        try {
                            for (var _a = __values(Object.keys(api)), _c = _a.next(); !_c.done; _c = _a.next()) {
                                var type = _c.value;
                                _loop_1(type);
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _a.return)) _d.call(_a);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        var e_4, _d;
                    };
                    Exchange.prototype.fetch = function (url, method, headers, body) {
                        if (method === void 0) { method = 'GET'; }
                        if (headers === void 0) { headers = undefined; }
                        if (body === void 0) { body = undefined; }
                        if (isNode && this.userAgent) {
                            if (typeof this.userAgent === 'string')
                                headers = extend({ 'User-Agent': this.userAgent }, headers);
                            else if ((typeof this.userAgent === 'object') && ('User-Agent' in this.userAgent))
                                headers = extend(this.userAgent, headers);
                        }
                        if (typeof this.proxy === 'function') {
                            url = this.proxy(url);
                            if (isNode)
                                headers = extend({ 'Origin': this.origin }, headers);
                        }
                        else if (typeof this.proxy === 'string') {
                            if (this.proxy.length)
                                if (isNode)
                                    headers = extend({ 'Origin': this.origin }, headers);
                            url = this.proxy + url;
                        }
                        headers = extend(this.headers, headers);
                        if (this.verbose)
                            console.log("fetch:\n", this.id, method, url, "\nRequest:\n", headers, "\n", body, "\n");
                        return this.executeRestRequest(url, method, headers, body);
                    };
                    Exchange.prototype.fetch2 = function (path, type, method, params, headers, body) {
                        if (type === void 0) { type = 'public'; }
                        if (method === void 0) { method = 'GET'; }
                        if (params === void 0) { params = {}; }
                        if (headers === void 0) { headers = undefined; }
                        if (body === void 0) { body = undefined; }
                        return __awaiter(this, void 0, void 0, function () {
                            var request;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!this.enableRateLimit) return [3, 2];
                                        return [4, this.throttle()];
                                    case 1:
                                        _a.sent();
                                        _a.label = 2;
                                    case 2:
                                        request = this.sign(path, type, method, params, headers, body);
                                        return [2, this.fetch(request.url, request.method, request.headers, request.body)];
                                }
                            });
                        });
                    };
                    Exchange.prototype.request = function (path, type, method, params, headers, body) {
                        if (type === void 0) { type = 'public'; }
                        if (method === void 0) { method = 'GET'; }
                        if (params === void 0) { params = {}; }
                        if (headers === void 0) { headers = undefined; }
                        if (body === void 0) { body = undefined; }
                        return this.fetch2(path, type, method, params, headers, body);
                    };
                    Exchange.prototype.parseJson = function (response, responseBody, url, method) {
                        try {
                            return (responseBody.length > 0) ? JSON.parse(responseBody) : {};
                        }
                        catch (e) {
                            if (this.verbose)
                                console.log('parseJson:\n', this.id, method, url, response.status, 'error', e, "response body:\n'" + responseBody + "'\n");
                            var title = undefined;
                            var match = responseBody.match(/<title>([^<]+)/i);
                            if (match)
                                title = match[1].trim();
                            var maintenance = responseBody.match(/offline|busy|retry|wait|unavailable|maintain|maintenance|maintenancing/i);
                            var ddosProtection = responseBody.match(/cloudflare|incapsula|overload|ddos/i);
                            if (e instanceof SyntaxError) {
                                var error = ExchangeNotAvailable;
                                var details = 'not accessible from this location at the moment';
                                if (maintenance)
                                    details = 'offline, on maintenance or unreachable from this location at the moment';
                                if (ddosProtection)
                                    error = DDoSProtection;
                                throw new error([this.id, method, url, response.status, title, details].join(' '));
                            }
                            throw e;
                        }
                    };
                    Exchange.prototype.handleErrors = function (statusCode, statusText, url, method, requestHeaders, responseBody, json) {
                    };
                    Exchange.prototype.defaultErrorHandler = function (response, responseBody, url, method) {
                        var code = response.status, reason = response.statusText;
                        if ((code >= 200) && (code <= 299))
                            return;
                        var error = undefined;
                        var details = responseBody;
                        var match = responseBody.match(/<title>([^<]+)/i);
                        if (match)
                            details = match[1].trim();
                        if ([418, 429].includes(code)) {
                            error = DDoSProtection;
                        }
                        else if ([404, 409, 500, 501, 502, 520, 521, 522, 525].includes(code)) {
                            error = ExchangeNotAvailable;
                        }
                        else if ([400, 403, 405, 503, 530].includes(code)) {
                            var ddosProtection = responseBody.match(/cloudflare|incapsula/i);
                            if (ddosProtection) {
                                error = DDoSProtection;
                            }
                            else {
                                error = ExchangeNotAvailable;
                                details += ' (possible reasons: ' + [
                                    'invalid API keys',
                                    'bad or old nonce',
                                    'exchange is down or offline',
                                    'on maintenance',
                                    'DDoS protection',
                                    'rate-limiting',
                                ].join(', ') + ')';
                            }
                        }
                        else if ([408, 504].includes(code)) {
                            error = RequestTimeout;
                        }
                        else if ([401, 511].includes(code)) {
                            error = AuthenticationError;
                        }
                        else {
                            error = ExchangeError;
                        }
                        throw new error([this.id, method, url, code, reason, details].join(' '));
                    };
                    Exchange.prototype.handleRestResponse = function (response, url, method, requestHeaders, requestBody) {
                        var _this = this;
                        if (method === void 0) { method = 'GET'; }
                        if (requestHeaders === void 0) { requestHeaders = undefined; }
                        if (requestBody === void 0) { requestBody = undefined; }
                        return response.text().then(function (responseBody) {
                            var jsonRequired = _this.parseJsonResponse && !_this.skipJsonOnStatusCodes.includes(response.status);
                            var json = jsonRequired ? _this.parseJson(response, responseBody, url, method) : undefined;
                            var responseHeaders = {};
                            response.headers.forEach(function (value, key) {
                                key = key.split('-').map(function (word) { return capitalize(word); }).join('-');
                                responseHeaders[key] = value;
                            });
                            _this.last_response_headers = responseHeaders;
                            _this.last_http_response = responseBody;
                            _this.last_json_response = json;
                            if (_this.verbose)
                                console.log("handleRestResponse:\n", _this.id, method, url, response.status, response.statusText, "\nResponse:\n", responseHeaders, "\n", responseBody, "\n");
                            var args = [response.status, response.statusText, url, method, responseHeaders, responseBody, json];
                            _this.handleErrors.apply(_this, __spread(args));
                            _this.defaultErrorHandler(response, responseBody, url, method);
                            return jsonRequired ? json : responseBody;
                        });
                    };
                    Exchange.prototype.setMarkets = function (markets, currencies) {
                        var _this = this;
                        if (currencies === void 0) { currencies = undefined; }
                        var values = Object.values(markets).map(function (market) { return deepExtend({
                            'limits': _this.limits,
                            'precision': _this.precision,
                        }, _this.fees['trading'], market); });
                        this.markets = deepExtend(this.markets, indexBy(values, 'symbol'));
                        this.marketsById = indexBy(markets, 'id');
                        this.markets_by_id = this.marketsById;
                        this.symbols = Object.keys(this.markets).sort();
                        this.ids = Object.keys(this.markets_by_id).sort();
                        if (currencies) {
                            this.currencies = deepExtend(currencies, this.currencies);
                        }
                        else {
                            var baseCurrencies = values.filter(function (market) { return 'base' in market; })
                                .map(function (market) { return ({
                                id: market.baseId || market.base,
                                code: market.base,
                                precision: market.precision ? (market.precision.base || market.precision.amount) : 8,
                            }); });
                            var quoteCurrencies = values.filter(function (market) { return 'quote' in market; })
                                .map(function (market) { return ({
                                id: market.quoteId || market.quote,
                                code: market.quote,
                                precision: market.precision ? (market.precision.quote || market.precision.price) : 8,
                            }); });
                            var allCurrencies = baseCurrencies.concat(quoteCurrencies);
                            var groupedCurrencies_1 = groupBy(allCurrencies, 'code');
                            var currencies_1 = Object.keys(groupedCurrencies_1).map(function (code) {
                                return groupedCurrencies_1[code].reduce(function (previous, current) {
                                    return ((previous.precision > current.precision) ? previous : current);
                                }, groupedCurrencies_1[code][0]);
                            });
                            var sortedCurrencies = sortBy(flatten(currencies_1), 'code');
                            this.currencies = deepExtend(indexBy(sortedCurrencies, 'code'), this.currencies);
                        }
                        this.currencies_by_id = indexBy(this.currencies, 'id');
                        return this.markets;
                    };
                    Exchange.prototype.loadMarkets = function (reload) {
                        if (reload === void 0) { reload = false; }
                        return __awaiter(this, void 0, void 0, function () {
                            var markets, currencies;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!reload && this.markets) {
                                            if (!this.markets_by_id) {
                                                return [2, this.setMarkets(this.markets)];
                                            }
                                            return [2, this.markets];
                                        }
                                        return [4, this.fetchMarkets()];
                                    case 1:
                                        markets = _a.sent();
                                        currencies = undefined;
                                        if (!this.has.fetchCurrencies) return [3, 3];
                                        return [4, this.fetchCurrencies()];
                                    case 2:
                                        currencies = _a.sent();
                                        _a.label = 3;
                                    case 3: return [2, this.setMarkets(markets, currencies)];
                                }
                            });
                        });
                    };
                    Exchange.prototype.fetchBidsAsks = function (symbols, params) {
                        if (symbols === void 0) { symbols = undefined; }
                        if (params === void 0) { params = {}; }
                        throw new NotSupported(this.id + ' fetchBidsAsks not supported yet');
                    };
                    Exchange.prototype.fetchOHLCV = function (symbol, timeframe, since, limits, params) {
                        if (timeframe === void 0) { timeframe = '1m'; }
                        if (since === void 0) { since = undefined; }
                        if (limits === void 0) { limits = undefined; }
                        if (params === void 0) { params = {}; }
                        return __awaiter(this, void 0, void 0, function () {
                            var trades, ohlcvc;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!this.has['fetchTrades'])
                                            throw new NotSupported(this.id + ' fetchOHLCV() not supported yet');
                                        return [4, this.loadMarkets()];
                                    case 1:
                                        _a.sent();
                                        return [4, this.fetchTrades(symbol, since, limits, params)];
                                    case 2:
                                        trades = _a.sent();
                                        ohlcvc = buildOHLCVC(trades, timeframe, since, limits);
                                        return [2, ohlcvc.map(function (c) { return c.slice(0, -1); })];
                                }
                            });
                        });
                    };
                    Exchange.prototype.fetchTickers = function (symbols, params) {
                        if (symbols === void 0) { symbols = undefined; }
                        if (params === void 0) { params = {}; }
                        throw new NotSupported(this.id + ' fetchTickers not supported yet');
                    };
                    Exchange.prototype.purgeCachedOrders = function (before) {
                        var orders = Object
                            .values(this.orders)
                            .filter(function (order) {
                            return (order.status === 'open') ||
                                (order.timestamp >= before);
                        });
                        this.orders = indexBy(orders, 'id');
                        return this.orders;
                    };
                    Exchange.prototype.fetchOrder = function (id, symbol, params) {
                        if (symbol === void 0) { symbol = undefined; }
                        if (params === void 0) { params = {}; }
                        throw new NotSupported(this.id + ' fetchOrder not supported yet');
                    };
                    Exchange.prototype.fetchOrders = function (symbol, since, limit, params) {
                        if (symbol === void 0) { symbol = undefined; }
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        if (params === void 0) { params = {}; }
                        throw new NotSupported(this.id + ' fetchOrders not supported yet');
                    };
                    Exchange.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                        if (symbol === void 0) { symbol = undefined; }
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        if (params === void 0) { params = {}; }
                        throw new NotSupported(this.id + ' fetchOpenOrders not supported yet');
                    };
                    Exchange.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                        if (symbol === void 0) { symbol = undefined; }
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        if (params === void 0) { params = {}; }
                        throw new NotSupported(this.id + ' fetchClosedOrders not supported yet');
                    };
                    Exchange.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                        if (symbol === void 0) { symbol = undefined; }
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        if (params === void 0) { params = {}; }
                        throw new NotSupported(this.id + ' fetchMyTrades not supported yet');
                    };
                    Exchange.prototype.fetchCurrencies = function () {
                        throw new NotSupported(this.id + ' fetchCurrencies not supported yet');
                    };
                    Exchange.prototype.fetchMarkets = function () {
                        var _this = this;
                        return new Promise(function (resolve, reject) { return resolve(_this.markets); });
                    };
                    Exchange.prototype.fetchOrderStatus = function (id, market) {
                        if (market === void 0) { market = undefined; }
                        return __awaiter(this, void 0, void 0, function () {
                            var order;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4, this.fetchOrder(id, market)];
                                    case 1:
                                        order = _a.sent();
                                        return [2, order['status']];
                                }
                            });
                        });
                    };
                    Exchange.prototype.account = function () {
                        return {
                            'free': 0.0,
                            'used': 0.0,
                            'total': 0.0,
                        };
                    };
                    Exchange.prototype.commonCurrencyCode = function (currency) {
                        if (!this.substituteCommonCurrencyCodes)
                            return currency;
                        if (currency === 'XBT')
                            return 'BTC';
                        if (currency === 'BCC')
                            return 'BCH';
                        if (currency === 'DRK')
                            return 'DASH';
                        return currency;
                    };
                    Exchange.prototype.currency = function (code) {
                        if (typeof this.currencies === 'undefined')
                            return new ExchangeError(this.id + ' currencies not loaded');
                        if ((typeof code === 'string') && (code in this.currencies))
                            return this.currencies[code];
                        throw new ExchangeError(this.id + ' does not have currency code ' + code);
                    };
                    Exchange.prototype.findMarket = function (string) {
                        if (typeof this.markets === 'undefined')
                            return new ExchangeError(this.id + ' markets not loaded');
                        if (typeof string === 'string') {
                            if (string in this.markets_by_id)
                                return this.markets_by_id[string];
                            if (string in this.markets)
                                return this.markets[string];
                        }
                        return string;
                    };
                    Exchange.prototype.findSymbol = function (string, market) {
                        if (market === void 0) { market = undefined; }
                        if (typeof market === 'undefined')
                            market = this.findMarket(string);
                        if (typeof market === 'object')
                            return market['symbol'];
                        return string;
                    };
                    Exchange.prototype.market = function (symbol) {
                        if (typeof this.markets === 'undefined')
                            return new ExchangeError(this.id + ' markets not loaded');
                        if ((typeof symbol === 'string') && (symbol in this.markets))
                            return this.markets[symbol];
                        throw new ExchangeError(this.id + ' does not have market symbol ' + symbol);
                    };
                    Exchange.prototype.marketId = function (symbol) {
                        var market = this.market(symbol);
                        return (typeof market !== 'undefined' ? market['id'] : symbol);
                    };
                    Exchange.prototype.marketIds = function (symbols) {
                        var _this = this;
                        return symbols.map(function (symbol) { return _this.marketId(symbol); });
                    };
                    Exchange.prototype.symbol = function (symbol) {
                        return this.market(symbol).symbol || symbol;
                    };
                    Exchange.prototype.extractParams = function (string) {
                        var re = /{([\w-]+)}/g;
                        var matches = [];
                        var match = re.exec(string);
                        while (match) {
                            matches.push(match[1]);
                            match = re.exec(string);
                        }
                        return matches;
                    };
                    Exchange.prototype.implodeParams = function (string, params) {
                        for (var property in params)
                            string = string.replace('{' + property + '}', params[property]);
                        return string;
                    };
                    Exchange.prototype.url = function (path, params) {
                        if (params === void 0) { params = {}; }
                        var result = this.implodeParams(path, params);
                        var query = this.omit(params, this.extractParams(path));
                        if (Object.keys(query).length)
                            result += '?' + this.urlencode(query);
                        return result;
                    };
                    Exchange.prototype.parseBidAsk = function (bidask, priceKey, amountKey) {
                        if (priceKey === void 0) { priceKey = 0; }
                        if (amountKey === void 0) { amountKey = 1; }
                        var price = parseFloat(bidask[priceKey]);
                        var amount = parseFloat(bidask[amountKey]);
                        return [price, amount];
                    };
                    Exchange.prototype.parseBidsAsks = function (bidasks, priceKey, amountKey) {
                        var _this = this;
                        if (priceKey === void 0) { priceKey = 0; }
                        if (amountKey === void 0) { amountKey = 1; }
                        return Object.values(bidasks || []).map(function (bidask) { return _this.parseBidAsk(bidask, priceKey, amountKey); });
                    };
                    Exchange.prototype.fetchL2OrderBook = function (symbol, limit, params) {
                        if (limit === void 0) { limit = undefined; }
                        if (params === void 0) { params = {}; }
                        return __awaiter(this, void 0, void 0, function () {
                            var orderbook;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4, this.fetchOrderBook(symbol, limit, params)];
                                    case 1:
                                        orderbook = _a.sent();
                                        return [2, extend(orderbook, {
                                                'bids': sortBy(aggregate(orderbook.bids), 0, true),
                                                'asks': sortBy(aggregate(orderbook.asks), 0),
                                            })];
                                }
                            });
                        });
                    };
                    Exchange.prototype.parseOrderBook = function (orderbook, timestamp, bidsKey, asksKey, priceKey, amountKey) {
                        if (timestamp === void 0) { timestamp = undefined; }
                        if (bidsKey === void 0) { bidsKey = 'bids'; }
                        if (asksKey === void 0) { asksKey = 'asks'; }
                        if (priceKey === void 0) { priceKey = 0; }
                        if (amountKey === void 0) { amountKey = 1; }
                        timestamp = timestamp || this.milliseconds();
                        return {
                            'bids': sortBy((bidsKey in orderbook) ? this.parseBidsAsks(orderbook[bidsKey], priceKey, amountKey) : [], 0, true),
                            'asks': sortBy((asksKey in orderbook) ? this.parseBidsAsks(orderbook[asksKey], priceKey, amountKey) : [], 0),
                            'timestamp': timestamp,
                            'datetime': this.iso8601(timestamp),
                        };
                    };
                    Exchange.prototype.getCurrencyUsedOnOpenOrders = function (currency) {
                        var _this = this;
                        return Object.values(this.orders).filter(function (order) { return (order['status'] === 'open'); }).reduce(function (total, order) {
                            var symbol = order['symbol'];
                            var market = _this.markets[symbol];
                            var remaining = order['remaining'];
                            if (currency === market['base'] && order['side'] === 'sell') {
                                return total + remaining;
                            }
                            else if (currency === market['quote'] && order['side'] === 'buy') {
                                return total + (order['price'] * remaining);
                            }
                            else {
                                return total;
                            }
                        }, 0);
                    };
                    Exchange.prototype.parseBalance = function (balance) {
                        var _this = this;
                        var currencies = Object.keys(this.omit(balance, 'info'));
                        currencies.forEach(function (currency) {
                            if (typeof balance[currency].used === 'undefined') {
                                if (_this.dontGetUsedBalanceFromStaleCache && ('open_orders' in balance['info'])) {
                                    var exchangeOrdersCount = balance['info']['open_orders'];
                                    var cachedOrdersCount = Object.values(_this.orders).filter(function (order) { return (order['status'] === 'open'); }).length;
                                    if (cachedOrdersCount === exchangeOrdersCount) {
                                        balance[currency].used = _this.getCurrencyUsedOnOpenOrders(currency);
                                        balance[currency].total = balance[currency].used + balance[currency].free;
                                    }
                                }
                                else {
                                    balance[currency].used = _this.getCurrencyUsedOnOpenOrders(currency);
                                    balance[currency].total = balance[currency].used + balance[currency].free;
                                }
                            }
                            ['free', 'used', 'total'].forEach(function (account) {
                                balance[account] = balance[account] || {};
                                balance[account][currency] = balance[currency][account];
                            });
                        });
                        return balance;
                    };
                    Exchange.prototype.fetchPartialBalance = function (part, params) {
                        if (params === void 0) { params = {}; }
                        return __awaiter(this, void 0, void 0, function () {
                            var balance;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4, this.fetchBalance(params)];
                                    case 1:
                                        balance = _a.sent();
                                        return [2, balance[part]];
                                }
                            });
                        });
                    };
                    Exchange.prototype.fetchFreeBalance = function (params) {
                        if (params === void 0) { params = {}; }
                        return this.fetchPartialBalance('free', params);
                    };
                    Exchange.prototype.fetchUsedBalance = function (params) {
                        if (params === void 0) { params = {}; }
                        return this.fetchPartialBalance('used', params);
                    };
                    Exchange.prototype.fetchTotalBalance = function (params) {
                        if (params === void 0) { params = {}; }
                        return this.fetchPartialBalance('total', params);
                    };
                    Exchange.prototype.filterBySinceLimit = function (array, since, limit) {
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        if (typeof since !== 'undefined')
                            array = array.filter(function (entry) { return entry.timestamp >= since; });
                        if (typeof limit !== 'undefined')
                            array = array.slice(0, limit);
                        return array;
                    };
                    Exchange.prototype.filterBySymbolSinceLimit = function (array, symbol, since, limit) {
                        if (symbol === void 0) { symbol = undefined; }
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        var symbolIsDefined = typeof symbol !== 'undefined';
                        var sinceIsDefined = typeof since !== 'undefined';
                        if (symbolIsDefined || sinceIsDefined)
                            array = array.filter(function (entry) {
                                return ((symbolIsDefined ? (entry.symbol === symbol) : true) &&
                                    (sinceIsDefined ? (entry.timestamp >= since) : true));
                            });
                        if (typeof limit !== 'undefined')
                            array = array.slice(0, limit);
                        return array;
                    };
                    Exchange.prototype.parseTrades = function (trades, market, since, limit) {
                        var _this = this;
                        if (market === void 0) { market = undefined; }
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        var result = Object.values(trades || []).map(function (trade) { return _this.parseTrade(trade, market); });
                        result = sortBy(result, 'timestamp');
                        var symbol = (typeof market !== 'undefined') ? market['symbol'] : undefined;
                        return this.filterBySymbolSinceLimit(result, symbol, since, limit);
                    };
                    Exchange.prototype.parseOrders = function (orders, market, since, limit) {
                        var _this = this;
                        if (market === void 0) { market = undefined; }
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        var result = Object.values(orders).map(function (order) { return _this.parseOrder(order, market); });
                        result = sortBy(result, 'timestamp');
                        var symbol = (typeof market !== 'undefined') ? market['symbol'] : undefined;
                        return this.filterBySymbolSinceLimit(result, symbol, since, limit);
                    };
                    Exchange.prototype.filterBySymbol = function (array, symbol) {
                        if (symbol === void 0) { symbol = undefined; }
                        return ((typeof symbol !== 'undefined') ? array.filter(function (entry) { return entry.symbol === symbol; }) : array);
                    };
                    Exchange.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                        if (market === void 0) { market = undefined; }
                        if (timeframe === void 0) { timeframe = '1m'; }
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        return Array.isArray(ohlcv) ? ohlcv.slice(0, 6) : ohlcv;
                    };
                    Exchange.prototype.parseOHLCVs = function (ohlcvs, market, timeframe, since, limit) {
                        if (market === void 0) { market = undefined; }
                        if (timeframe === void 0) { timeframe = '1m'; }
                        if (since === void 0) { since = undefined; }
                        if (limit === void 0) { limit = undefined; }
                        ohlcvs = Object.values(ohlcvs);
                        var result = [];
                        for (var i = 0; i < ohlcvs.length; i++) {
                            if (limit && (result.length >= limit))
                                break;
                            var ohlcv = this.parseOHLCV(ohlcvs[i], market, timeframe, since, limit);
                            if (since && (ohlcv[0] < since))
                                continue;
                            result.push(ohlcv);
                        }
                        return result;
                    };
                    Exchange.prototype.editLimitBuyOrder = function (id, symbol) {
                        var args = [];
                        for (var _a = 2; _a < arguments.length; _a++) {
                            args[_a - 2] = arguments[_a];
                        }
                        return this.editLimitOrder.apply(this, __spread([id, symbol, 'buy'], args));
                    };
                    Exchange.prototype.editLimitSellOrder = function (id, symbol) {
                        var args = [];
                        for (var _a = 2; _a < arguments.length; _a++) {
                            args[_a - 2] = arguments[_a];
                        }
                        return this.editLimitOrder.apply(this, __spread([id, symbol, 'sell'], args));
                    };
                    Exchange.prototype.editLimitOrder = function (id, symbol) {
                        var args = [];
                        for (var _a = 2; _a < arguments.length; _a++) {
                            args[_a - 2] = arguments[_a];
                        }
                        return this.editOrder.apply(this, __spread([id, symbol, 'limit'], args));
                    };
                    Exchange.prototype.editOrder = function (id, symbol) {
                        var args = [];
                        for (var _a = 2; _a < arguments.length; _a++) {
                            args[_a - 2] = arguments[_a];
                        }
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        if (!this.enableRateLimit)
                                            throw new ExchangeError(this.id + ' editOrder() requires enableRateLimit = true');
                                        return [4, this.cancelOrder(id, symbol)];
                                    case 1:
                                        _c.sent();
                                        return [2, this.createOrder.apply(this, __spread([symbol], args))];
                                }
                            });
                        });
                    };
                    Exchange.prototype.createLimitOrder = function (symbol) {
                        var args = [];
                        for (var _a = 1; _a < arguments.length; _a++) {
                            args[_a - 1] = arguments[_a];
                        }
                        return this.createOrder.apply(this, __spread([symbol, 'limit'], args));
                    };
                    Exchange.prototype.createMarketOrder = function (symbol) {
                        var args = [];
                        for (var _a = 1; _a < arguments.length; _a++) {
                            args[_a - 1] = arguments[_a];
                        }
                        return this.createOrder.apply(this, __spread([symbol, 'market'], args));
                    };
                    Exchange.prototype.createLimitBuyOrder = function (symbol) {
                        var args = [];
                        for (var _a = 1; _a < arguments.length; _a++) {
                            args[_a - 1] = arguments[_a];
                        }
                        return this.createOrder.apply(this, __spread([symbol, 'limit', 'buy'], args));
                    };
                    Exchange.prototype.createLimitSellOrder = function (symbol) {
                        var args = [];
                        for (var _a = 1; _a < arguments.length; _a++) {
                            args[_a - 1] = arguments[_a];
                        }
                        return this.createOrder.apply(this, __spread([symbol, 'limit', 'sell'], args));
                    };
                    Exchange.prototype.createMarketBuyOrder = function (symbol, amount, params) {
                        if (params === void 0) { params = {}; }
                        return this.createOrder(symbol, 'market', 'buy', amount, undefined, params);
                    };
                    Exchange.prototype.createMarketSellOrder = function (symbol, amount, params) {
                        if (params === void 0) { params = {}; }
                        return this.createOrder(symbol, 'market', 'sell', amount, undefined, params);
                    };
                    Exchange.prototype.costToPrecision = function (symbol, cost) {
                        return parseFloat(cost).toFixed(this.markets[symbol].precision.price);
                    };
                    Exchange.prototype.priceToPrecision = function (symbol, price) {
                        return parseFloat(price).toFixed(this.markets[symbol].precision.price);
                    };
                    Exchange.prototype.amountToPrecision = function (symbol, amount) {
                        return this.truncate(amount, this.markets[symbol].precision.amount);
                    };
                    Exchange.prototype.amountToString = function (symbol, amount) {
                        return this.truncate_to_string(amount, this.markets[symbol].precision.amount);
                    };
                    Exchange.prototype.amountToLots = function (symbol, amount) {
                        var lot = this.markets[symbol].lot;
                        return this.amountToPrecision(symbol, Math.floor(amount / lot) * lot);
                    };
                    Exchange.prototype.feeToPrecision = function (symbol, fee) {
                        return parseFloat(fee).toFixed(this.markets[symbol].precision.price);
                    };
                    Exchange.prototype.calculateFee = function (symbol, type, side, amount, price, takerOrMaker, params) {
                        if (takerOrMaker === void 0) { takerOrMaker = 'taker'; }
                        if (params === void 0) { params = {}; }
                        var market = this.markets[symbol];
                        var rate = market[takerOrMaker];
                        var cost = parseFloat(this.costToPrecision(symbol, amount * price));
                        return {
                            'type': takerOrMaker,
                            'currency': market['quote'],
                            'rate': rate,
                            'cost': parseFloat(this.feeToPrecision(symbol, rate * cost)),
                        };
                    };
                    Exchange.prototype.ymd = function (timestamp, infix) {
                        if (infix === void 0) { infix = ' '; }
                        var date = new Date(timestamp);
                        var Y = date.getUTCFullYear();
                        var m = date.getUTCMonth() + 1;
                        var d = date.getUTCDate();
                        m = m < 10 ? ('0' + m) : m;
                        d = d < 10 ? ('0' + d) : d;
                        return Y + '-' + m + '-' + d;
                    };
                    Exchange.prototype.ymdhms = function (timestamp, infix) {
                        if (infix === void 0) { infix = ' '; }
                        var date = new Date(timestamp);
                        var Y = date.getUTCFullYear();
                        var m = date.getUTCMonth() + 1;
                        var d = date.getUTCDate();
                        var H = date.getUTCHours();
                        var M = date.getUTCMinutes();
                        var S = date.getUTCSeconds();
                        m = m < 10 ? ('0' + m) : m;
                        d = d < 10 ? ('0' + d) : d;
                        H = H < 10 ? ('0' + H) : H;
                        M = M < 10 ? ('0' + M) : M;
                        S = S < 10 ? ('0' + S) : S;
                        return Y + '-' + m + '-' + d + infix + H + ':' + M + ':' + S;
                    };
                    return Exchange;
                }());
            }).call(this, require('_process'));
        }, { "./Market": 9, "./errors": 10, "./functions": 11, "_process": 154, "fetch-ponyfill": 153 }], 9: [function (require, module, exports) {
            "use strict";
            module.exports = (function () {
                function Market(exchange, symbol) {
                    this.exchange = exchange;
                    this.symbol = symbol;
                    this.market = exchange.markets[symbol];
                }
                Market.prototype.amountToPrecision = function (amount) {
                    return this.exchange.amountToPrecision(this.symbol, amount);
                };
                Market.prototype.createLimitBuyOrder = function (amount, price) {
                    return this.exchange.createLimitBuyOrder(this.symbol, amount, price);
                };
                Market.prototype.createLimitSellOrder = function (amount, price) {
                    return this.exchange.createLimitSellOrder(this.symbol, amount, price);
                };
                return Market;
            }());
        }, {}], 10: [function (require, module, exports) {
            'use strict';
            module.exports = subclass(Error, { 'BaseError': { 'ExchangeError': { 'NotSupported': {},
                        'AuthenticationError': {},
                        'InsufficientFunds': {},
                        'InvalidAddress': {},
                        'InvalidOrder': { 'OrderNotFound': {},
                            'OrderNotCached': {},
                            'CancelPending': {}
                        },
                        'NetworkError': { 'DDoSProtection': {},
                            'RequestTimeout': {},
                            'ExchangeNotAvailable': {},
                            'InvalidNonce': {}
                        }
                    }
                }
            });
            function subclass(BaseClass, classes, namespace) {
                if (namespace === void 0) { namespace = {}; }
                var _loop_3 = function ($class, subclasses) {
                    var Class = Object.assign(namespace, (_a = {},
                        _a[$class] = (function (_super) {
                            __extends(class_1, _super);
                            function class_1(message) {
                                var _this = _super.call(this, message) || this;
                                _this.constructor = Class;
                                _this.__proto__ = Class.prototype;
                                _this.message = message;
                                return _this;
                            }
                            return class_1;
                        }(BaseClass)),
                        _a))[$class];
                    subclass(Class, subclasses, namespace);
                    var _a;
                };
                try {
                    for (var _a = __values(Object.entries(classes)), _c = _a.next(); !_c.done; _c = _a.next()) {
                        var _d = __read(_c.value, 2), $class = _d[0], subclasses = _d[1];
                        _loop_3($class, subclasses);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_e = _a.return)) _e.call(_a);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                return namespace;
                var e_5, _e;
            }
        }, {}], 11: [function (require, module, exports) {
            'use strict';
            var unCamelCase = require('./functions/string').unCamelCase;
            var unCamelCasePropertyNames = function (x) {
                for (var k in x)
                    x[unCamelCase(k)] = x[k];
                return x;
            };
            module.exports = unCamelCasePropertyNames(Object.assign({}, require('./functions/platform'), require('./functions/generic'), require('./functions/string'), require('./functions/type'), require('./functions/number'), require('./functions/encode'), require('./functions/crypto'), require('./functions/time'), require('./functions/throttle'), require('./functions/misc')));
        }, { "./functions/crypto": 12, "./functions/encode": 13, "./functions/generic": 14, "./functions/misc": 15, "./functions/number": 16, "./functions/platform": 17, "./functions/string": 18, "./functions/throttle": 19, "./functions/time": 20, "./functions/type": 21 }], 12: [function (require, module, exports) {
            "use strict";
            var CryptoJS = require('crypto-js');
            var capitalize = require('./string').capitalize;
            var _a = require('./encode'), stringToBase64 = _a.stringToBase64, utf16ToBase64 = _a.utf16ToBase64, urlencodeBase64 = _a.urlencodeBase64;
            var hash = function (request, hash, digest) {
                if (hash === void 0) { hash = 'md5'; }
                if (digest === void 0) { digest = 'hex'; }
                var result = CryptoJS[hash.toUpperCase()](request);
                return (digest === 'binary') ? result : result.toString(CryptoJS.enc[capitalize(digest)]);
            };
            var hmac = function (request, secret, hash, digest) {
                if (hash === void 0) { hash = 'sha256'; }
                if (digest === void 0) { digest = 'hex'; }
                var encoding = (digest === 'binary') ? 'Latin1' : capitalize(digest);
                return CryptoJS['Hmac' + hash.toUpperCase()](request, secret).toString(CryptoJS.enc[capitalize(encoding)]);
            };
            var jwt = function JSON_web_token(request, secret, alg, hash) {
                if (alg === void 0) { alg = 'HS256'; }
                if (hash === void 0) { hash = 'sha256'; }
                var encodedHeader = urlencodeBase64(stringToBase64(JSON.stringify({ 'alg': alg, 'typ': 'JWT' }))), encodedData = urlencodeBase64(stringToBase64(JSON.stringify(request))), token = [encodedHeader, encodedData].join('.'), signature = urlencodeBase64(utf16ToBase64(hmac(token, secret, hash, 'utf16')));
                return [token, signature].join('.');
            };
            module.exports = {
                hash: hash,
                hmac: hmac,
                jwt: jwt
            };
        }, { "./encode": 13, "./string": 18, "crypto-js": 127 }], 13: [function (require, module, exports) {
            "use strict";
            var CryptoJS = require('crypto-js');
            var qs = require('qs');
            module.exports =
                { json: function (data, params) {
                        if (params === void 0) { params = undefined; }
                        return JSON.stringify(data);
                    },
                    unjson: JSON.parse,
                    stringToBinary: function (str) {
                        var arr = new Uint8Array(str.length);
                        for (var i = 0; i < str.length; i++) {
                            arr[i] = str.charCodeAt(i);
                        }
                        return CryptoJS.lib.WordArray.create(arr);
                    },
                    stringToBase64: function (string) { return CryptoJS.enc.Latin1.parse(string).toString(CryptoJS.enc.Base64); },
                    utf16ToBase64: function (string) { return CryptoJS.enc.Utf16.parse(string).toString(CryptoJS.enc.Base64); },
                    base64ToBinary: function (string) { return CryptoJS.enc.Base64.parse(string); },
                    base64ToString: function (string) { return CryptoJS.enc.Base64.parse(string).toString(CryptoJS.enc.Utf8); },
                    binaryToString: function (string) { return string; },
                    binaryConcat: function () {
                        var args = [];
                        for (var _a = 0; _a < arguments.length; _a++) {
                            args[_a] = arguments[_a];
                        }
                        return args.reduce(function (a, b) { return a.concat(b); });
                    },
                    urlencode: function (object) { return qs.stringify(object); },
                    rawencode: function (object) { return qs.stringify(object, { encode: false }); },
                    urlencodeBase64: function (base64string) { return base64string.replace(/[=]+$/, '')
                        .replace(/\+/g, '-')
                        .replace(/\//g, '_'); }
                };
        }, { "crypto-js": 127, "qs": 156 }], 14: [function (require, module, exports) {
            "use strict";
            var _a = require('./type'), isObject = _a.isObject, isNumber = _a.isNumber, isDictionary = _a.isDictionary, isArray = _a.isArray;
            var keys = Object.keys, values = function (x) { return !isArray(x)
                ? Object.values(x)
                : x; }, index = function (x) { return new Set(values(x)); }, extend = function () {
                var args = [];
                for (var _a = 0; _a < arguments.length; _a++) {
                    args[_a] = arguments[_a];
                }
                return Object.assign.apply(Object, __spread([{}], args));
            }, clone = function (x) { return isArray(x)
                ? Array.from(x)
                : extend(x); };
            module.exports =
                { keys: keys,
                    values: values,
                    extend: extend,
                    clone: clone,
                    index: index,
                    ordered: function (x) { return x; },
                    unique: function (x) { return Array.from(index(x)); },
                    keysort: function (x, out) {
                        if (out === void 0) { out = {}; }
                        try {
                            for (var _a = __values(keys(x).sort()), _c = _a.next(); !_c.done; _c = _a.next()) {
                                var k = _c.value;
                                out[k] = x[k];
                            }
                        }
                        catch (e_6_1) { e_6 = { error: e_6_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _a.return)) _d.call(_a);
                            }
                            finally { if (e_6) throw e_6.error; }
                        }
                        return out;
                        var e_6, _d;
                    },
                    indexBy: function (x, k, out) {
                        if (out === void 0) { out = {}; }
                        try {
                            for (var _a = __values(values(x)), _c = _a.next(); !_c.done; _c = _a.next()) {
                                var v = _c.value;
                                if (k in v)
                                    out[v[k]] = v;
                            }
                        }
                        catch (e_7_1) { e_7 = { error: e_7_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _a.return)) _d.call(_a);
                            }
                            finally { if (e_7) throw e_7.error; }
                        }
                        return out;
                        var e_7, _d;
                    },
                    groupBy: function (x, k, out) {
                        if (out === void 0) { out = {}; }
                        try {
                            for (var _a = __values(values(x)), _c = _a.next(); !_c.done; _c = _a.next()) {
                                var v = _c.value;
                                if (k in v) {
                                    var p = v[k];
                                    out[p] = out[p] || [];
                                    out[p].push(v);
                                }
                            }
                        }
                        catch (e_8_1) { e_8 = { error: e_8_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _a.return)) _d.call(_a);
                            }
                            finally { if (e_8) throw e_8.error; }
                        }
                        return out;
                        var e_8, _d;
                    },
                    filterBy: function (x, k, value, out) {
                        if (value === void 0) { value = undefined; }
                        if (out === void 0) { out = []; }
                        try {
                            for (var _a = __values(values(x)), _c = _a.next(); !_c.done; _c = _a.next()) {
                                var v = _c.value;
                                if (v[k] === value)
                                    out.push(v);
                            }
                        }
                        catch (e_9_1) { e_9 = { error: e_9_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _a.return)) _d.call(_a);
                            }
                            finally { if (e_9) throw e_9.error; }
                        }
                        return out;
                        var e_9, _d;
                    },
                    sortBy: function (array, key, descending, direction) {
                        if (descending === void 0) { descending = false; }
                        if (direction === void 0) { direction = descending ? -1 : 1; }
                        return array.sort(function (a, b) {
                            return ((a[key] < b[key]) ? -direction :
                                ((a[key] > b[key]) ? direction : 0));
                        });
                    },
                    flatten: function flatten(x, out) {
                        if (out === void 0) { out = []; }
                        try {
                            for (var x_1 = __values(x), x_1_1 = x_1.next(); !x_1_1.done; x_1_1 = x_1.next()) {
                                var v = x_1_1.value;
                                if (isArray(v))
                                    flatten(v, out);
                                else
                                    out.push(v);
                            }
                        }
                        catch (e_10_1) { e_10 = { error: e_10_1 }; }
                        finally {
                            try {
                                if (x_1_1 && !x_1_1.done && (_a = x_1.return)) _a.call(x_1);
                            }
                            finally { if (e_10) throw e_10.error; }
                        }
                        return out;
                        var e_10, _a;
                    },
                    pluck: function (x, k) { return values(x)
                        .filter(function (v) { return k in v; })
                        .map(function (v) { return v[k]; }); },
                    omit: function (x) {
                        var args = [];
                        for (var _a = 1; _a < arguments.length; _a++) {
                            args[_a - 1] = arguments[_a];
                        }
                        var out = clone(x);
                        try {
                            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                                var k = args_1_1.value;
                                if (isArray(k))
                                    try {
                                        for (var k_1 = __values(k), k_1_1 = k_1.next(); !k_1_1.done; k_1_1 = k_1.next()) {
                                            var kk = k_1_1.value;
                                            delete out[kk];
                                        }
                                    }
                                    catch (e_11_1) { e_11 = { error: e_11_1 }; }
                                    finally {
                                        try {
                                            if (k_1_1 && !k_1_1.done && (_c = k_1.return)) _c.call(k_1);
                                        }
                                        finally { if (e_11) throw e_11.error; }
                                    }
                                else
                                    delete out[k];
                            }
                        }
                        catch (e_12_1) { e_12 = { error: e_12_1 }; }
                        finally {
                            try {
                                if (args_1_1 && !args_1_1.done && (_d = args_1.return)) _d.call(args_1);
                            }
                            finally { if (e_12) throw e_12.error; }
                        }
                        return out;
                        var e_12, _d, e_11, _c;
                    },
                    sum: function () {
                        var xs = [];
                        for (var _a = 0; _a < arguments.length; _a++) {
                            xs[_a] = arguments[_a];
                        }
                        var ns = xs.filter(isNumber);
                        return (ns.length > 0)
                            ? ns.reduce(function (a, b) { return a + b; }, 0)
                            : undefined;
                    },
                    deepExtend: function deepExtend() {
                        var xs = [];
                        for (var _a = 0; _a < arguments.length; _a++) {
                            xs[_a] = arguments[_a];
                        }
                        var out = undefined;
                        try {
                            for (var xs_1 = __values(xs), xs_1_1 = xs_1.next(); !xs_1_1.done; xs_1_1 = xs_1.next()) {
                                var x = xs_1_1.value;
                                if (isDictionary(x)) {
                                    if (!isObject(out))
                                        out = {};
                                    for (var k in x)
                                        out[k] = deepExtend(out[k], x[k]);
                                }
                                else
                                    out = x;
                            }
                        }
                        catch (e_13_1) { e_13 = { error: e_13_1 }; }
                        finally {
                            try {
                                if (xs_1_1 && !xs_1_1.done && (_c = xs_1.return)) _c.call(xs_1);
                            }
                            finally { if (e_13) throw e_13.error; }
                        }
                        return out;
                        var e_13, _c;
                    }
                };
        }, { "./type": 21 }], 15: [function (require, module, exports) {
            'use strict';
            var parseTimeframe = function (timeframe) {
                var amount = timeframe.slice(0, -1);
                var unit = timeframe.slice(-1);
                var scale = 60;
                if (unit === 'y') {
                    scale = 60 * 60 * 24 * 365;
                }
                else if (unit === 'M') {
                    scale = 60 * 60 * 24 * 30;
                }
                else if (unit === 'w') {
                    scale = 60 * 60 * 24 * 7;
                }
                else if (unit === 'd') {
                    scale = 60 * 60 * 24;
                }
                else if (unit === 'h') {
                    scale = 60 * 60;
                }
                return amount * scale;
            };
            var buildOHLCVC = function (trades, timeframe, since, limit) {
                if (timeframe === void 0) { timeframe = '1m'; }
                if (since === void 0) { since = -Infinity; }
                if (limit === void 0) { limit = Infinity; }
                var ms = parseTimeframe(timeframe) * 1000;
                var ohlcvs = [];
                var _a = __read([0, 1, 2, 3, 4, 5, 6], 7), timestamp = _a[0], high = _a[2], low = _a[3], close = _a[4], volume = _a[5], count = _a[6];
                var oldest = Math.min(trades.length - 1, limit);
                for (var i = oldest; i >= 0; i--) {
                    var trade = trades[i];
                    if (trade.timestamp < since)
                        continue;
                    var openingTime = Math.floor(trade.timestamp / ms) * ms;
                    var candle = ohlcvs.length - 1;
                    if (candle === -1 || openingTime >= ohlcvs[candle][timestamp] + ms) {
                        ohlcvs.push([
                            openingTime,
                            trade.price,
                            trade.price,
                            trade.price,
                            trade.price,
                            trade.amount,
                            1,
                        ]);
                    }
                    else {
                        ohlcvs[candle][high] = Math.max(ohlcvs[candle][high], trade.price);
                        ohlcvs[candle][low] = Math.min(ohlcvs[candle][low], trade.price);
                        ohlcvs[candle][close] = trade.price;
                        ohlcvs[candle][volume] += trade.amount;
                        ohlcvs[candle][count]++;
                    }
                }
                return ohlcvs;
            };
            module.exports = {
                aggregate: function (bidasks) {
                    var result = {};
                    try {
                        for (var bidasks_1 = __values(bidasks), bidasks_1_1 = bidasks_1.next(); !bidasks_1_1.done; bidasks_1_1 = bidasks_1.next()) {
                            var _a = __read(bidasks_1_1.value, 2), price = _a[0], volume = _a[1];
                            if (volume > 0)
                                result[price] = (result[price] || 0) + volume;
                        }
                    }
                    catch (e_14_1) { e_14 = { error: e_14_1 }; }
                    finally {
                        try {
                            if (bidasks_1_1 && !bidasks_1_1.done && (_c = bidasks_1.return)) _c.call(bidasks_1);
                        }
                        finally { if (e_14) throw e_14.error; }
                    }
                    return Object.keys(result).map(function (price) { return [parseFloat(price), parseFloat(result[price])]; });
                    var e_14, _c;
                },
                parseTimeframe: parseTimeframe,
                buildOHLCVC: buildOHLCVC,
            };
        }, {}], 16: [function (require, module, exports) {
            'use strict';
            function toFixed(x) {
                if (Math.abs(x) < 1.0) {
                    var e = parseInt(x.toString().split('e-')[1]);
                    if (e) {
                        x *= Math.pow(10, e - 1);
                        x = '0.' + (new Array(e)).join('0') + x.toString().substring(2);
                    }
                }
                else {
                    var e = parseInt(x.toString().split('+')[1]);
                    if (e > 20) {
                        e -= 20;
                        x /= Math.pow(10, e);
                        x += (new Array(e + 1)).join('0');
                    }
                }
                return x;
            }
            var truncate_regExpCache = [], truncate_to_string = function (num, precision) {
                if (precision === void 0) { precision = 0; }
                num = toFixed(num);
                if (precision > 0) {
                    var re = truncate_regExpCache[precision] || (truncate_regExpCache[precision] = new RegExp("([-]*\\d+\\.\\d{" + precision + "})(\\d)"));
                    var _a = __read(num.toString().match(re) || [null, num], 2), result = _a[1];
                    return result.toString();
                }
                return parseInt(num).toString();
            }, truncate = function (num, precision) {
                if (precision === void 0) { precision = 0; }
                return parseFloat(truncate_to_string(num, precision));
            };
            var precisionFromString = function (string) {
                var split = string.replace(/0+$/g, '').split('.');
                return (split.length > 1) ? (split[1].length) : 0;
            };
            module.exports = {
                toFixed: toFixed,
                truncate_to_string: truncate_to_string,
                truncate: truncate,
                precisionFromString: precisionFromString
            };
        }, {}], 17: [function (require, module, exports) {
            "use strict";
            module.exports = {
                isNode: (typeof window === 'undefined') &&
                    !((typeof WorkerGlobalScope !== 'undefined') && (self instanceof WorkerGlobalScope))
            };
        }, {}], 18: [function (require, module, exports) {
            "use strict";
            var uuid = function (a) { return a ? (a ^ Math.random() * 16 >> a / 4).toString(16)
                : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid); };
            module.exports =
                { uuid: uuid,
                    unCamelCase: function (s) { return s.replace(/[a-z0-9][A-Z]/g, function (x) { return x[0] + '_' + x[1]; }).toLowerCase(); },
                    capitalize: function (s) { return s.length
                        ? (s.charAt(0).toUpperCase() + s.slice(1))
                        : s; }
                };
        }, {}], 19: [function (require, module, exports) {
            "use strict";
            var _a = require('./time'), sleep = _a.sleep, now = _a.now;
            module.exports = {
                throttle: function throttle(cfg) {
                    var _this = this;
                    var lastTimestamp = now(), numTokens = (typeof cfg.numTokens !== 'undefined') ? cfg.numTokens : cfg.capacity, running = false, counter = 0;
                    var queue = [];
                    return Object.assign(function (cost) {
                        if (queue.length > cfg.maxCapacity)
                            throw new Error('Backlog is over max capacity of ' + cfg.maxCapacity);
                        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                            var hasEnoughTokens, _a, cost_1, resolve_1, reject_1, t, elapsed, e_15;
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        _c.trys.push([0, 5, , 6]);
                                        queue.push({ cost: cost, resolve: resolve, reject: reject });
                                        if (!!running) return [3, 4];
                                        running = true;
                                        _c.label = 1;
                                    case 1:
                                        if (!(queue.length > 0)) return [3, 3];
                                        hasEnoughTokens = cfg.capacity ? (numTokens > 0) : (numTokens >= 0);
                                        if (hasEnoughTokens) {
                                            if (queue.length > 0) {
                                                _a = queue[0], cost_1 = _a.cost, resolve_1 = _a.resolve, reject_1 = _a.reject;
                                                cost_1 = (cost_1 || cfg.defaultCost);
                                                if (numTokens >= Math.min(cost_1, cfg.capacity)) {
                                                    numTokens -= cost_1;
                                                    queue.shift();
                                                    resolve_1();
                                                }
                                            }
                                        }
                                        t = now(), elapsed = t - lastTimestamp;
                                        lastTimestamp = t;
                                        numTokens = Math.min(cfg.capacity, numTokens + elapsed * cfg.refillRate);
                                        return [4, sleep(cfg.delay)];
                                    case 2:
                                        _c.sent();
                                        return [3, 1];
                                    case 3:
                                        running = false;
                                        _c.label = 4;
                                    case 4: return [3, 6];
                                    case 5:
                                        e_15 = _c.sent();
                                        reject(e_15);
                                        return [3, 6];
                                    case 6: return [2];
                                }
                            });
                        }); });
                    }, cfg, { configure: function (newCfg) { return throttle(Object.assign({}, cfg, newCfg)); } });
                }
            };
        }, { "./time": 20 }], 20: [function (require, module, exports) {
            'use strict';
            var _this = this;
            var now = Date.now;
            var setTimeout_original = setTimeout;
            var setTimeout_safe = function (done, ms, setTimeout, targetTime) {
                if (setTimeout === void 0) { setTimeout = setTimeout_original; }
                if (targetTime === void 0) { targetTime = now() + ms; }
                var clearInnerTimeout = function () { };
                var active = true;
                var id = setTimeout(function () {
                    active = true;
                    var rest = targetTime - now();
                    if (rest > 0) {
                        clearInnerTimeout = setTimeout_safe(done, rest, setTimeout, targetTime);
                    }
                    else {
                        done();
                    }
                }, ms);
                return function clear() {
                    if (active) {
                        active = false;
                        clearTimeout(id);
                    }
                    clearInnerTimeout();
                };
            };
            var TimedOut = (function (_super) {
                __extends(TimedOut, _super);
                function TimedOut() {
                    var _this = this;
                    var message = 'timed out';
                    _this = _super.call(this, message) || this;
                    _this.constructor = TimedOut;
                    _this.__proto__ = TimedOut.prototype;
                    _this.message = message;
                    return _this;
                }
                return TimedOut;
            }(Error));
            module.exports =
                { now: now,
                    setTimeout_safe: setTimeout_safe,
                    sleep: function (ms) { return new Promise(function (resolve) { return setTimeout_safe(resolve, ms); }); },
                    TimedOut: TimedOut,
                    timeout: function (ms, promise) { return __awaiter(_this, void 0, void 0, function () {
                        var clear, expires;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    clear = function () { };
                                    expires = new Promise(function (resolve) { return (clear = setTimeout_safe(resolve, ms)); });
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 3, 4]);
                                    return [4, Promise.race([promise, expires.then(function () { throw new TimedOut(); })])];
                                case 2: return [2, _a.sent()];
                                case 3:
                                    clear();
                                    return [7];
                                case 4: return [2];
                            }
                        });
                    }); }
                };
        }, {}], 21: [function (require, module, exports) {
            "use strict";
            var isNumber = Number.isFinite, isArray = Array.isArray, isString = function (s) { return (typeof s === 'string'); }, isObject = function (o) { return (o !== null) && (typeof o === 'object'); }, isDictionary = function (o) { return (isObject(o) && !isArray(o)); }, isStringCoercible = function (x) { return (hasProps(x) && x.toString) || isNumber(x); };
            var hasProps = function (o) { return (o !== undefined) &&
                (o !== null); }, prop = function (o, k) { return isObject(o) ? o[k]
                : undefined; };
            var asFloat = function (x) { return (isNumber(x) || isString(x)) ? parseFloat(x) : NaN; }, asInteger = function (x) { return (isNumber(x) || isString(x)) ? parseInt(x, 10) : NaN; };
            module.exports =
                { isNumber: isNumber,
                    isArray: isArray,
                    isObject: isObject,
                    isString: isString,
                    isStringCoercible: isStringCoercible,
                    isDictionary: isDictionary,
                    hasProps: hasProps,
                    prop: prop,
                    asFloat: asFloat,
                    asInteger: asInteger,
                    safeFloat: function (o, k, $default, n) {
                        if (n === void 0) { n = asFloat(prop(o, k)); }
                        return isNumber(n) ? n : $default;
                    },
                    safeInteger: function (o, k, $default, n) {
                        if (n === void 0) { n = asInteger(prop(o, k)); }
                        return isNumber(n) ? n : $default;
                    },
                    safeValue: function (o, k, $default, x) {
                        if (x === void 0) { x = prop(o, k); }
                        return hasProps(x) ? x : $default;
                    },
                    safeString: function (o, k, $default, x) {
                        if (x === void 0) { x = prop(o, k); }
                        return isStringCoercible(x) ? String(x) : $default;
                    }
                };
        }, {}], 22: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError, DDoSProtection = _a.DDoSProtection, ExchangeNotAvailable = _a.ExchangeNotAvailable, InvalidOrder = _a.InvalidOrder, OrderNotFound = _a.OrderNotFound;
            module.exports = (function (_super) {
                __extends(bibox, _super);
                function bibox() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bibox.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bibox',
                        'name': 'Bibox',
                        'countries': ['CN', 'US', 'KR'],
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                            'publicAPI': false,
                            'fetchBalance': true,
                            'fetchCurrencies': true,
                            'fetchDepositAddress': true,
                            'fetchTickers': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'fetchMyTrades': true,
                            'fetchOHLCV': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1m': '1min',
                            '5m': '5min',
                            '15m': '15min',
                            '30m': '30min',
                            '1h': '1hour',
                            '8h': '12hour',
                            '1d': 'day',
                            '1w': 'week',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/34902611-2be8bf1a-f830-11e7-91a2-11b2f292e750.jpg',
                            'api': 'https://api.bibox.com',
                            'www': 'https://www.bibox.com',
                            'doc': [
                                'https://github.com/Biboxcom/api_reference/wiki/home_en',
                                'https://github.com/Biboxcom/api_reference/wiki/api_reference',
                            ],
                            'fees': 'https://bibox.zendesk.com/hc/en-us/articles/115004417013-Fee-Structure-on-Bibox',
                        },
                        'api': {
                            'public': {
                                'post': [
                                    'mdata',
                                ],
                                'get': [
                                    'mdata',
                                ],
                            },
                            'private': {
                                'post': [
                                    'user',
                                    'orderpending',
                                    'transfer',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'taker': 0.001,
                                'maker': 0.0,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {},
                                'deposit': {},
                            },
                        },
                    });
                };
                bibox.prototype.fetchMarkets = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, i, market, base, quote, symbol, id, precision;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMdata(this.extend({
                                        'cmd': 'marketAll',
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    markets = response['result'];
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        base = market['coin_symbol'];
                                        quote = market['currency_symbol'];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        id = base + '_' + quote;
                                        precision = {
                                            'amount': 8,
                                            'price': 8,
                                        };
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'active': undefined,
                                            'info': market,
                                            'lot': Math.pow(10, -precision['amount']),
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision['amount']),
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bibox.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.safeInteger(ticker, 'timestamp', this.seconds());
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    else {
                        symbol = ticker['coin_symbol'] + '/' + ticker['currency_symbol'];
                    }
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high'),
                        'low': this.safeFloat(ticker, 'low'),
                        'bid': this.safeFloat(ticker, 'buy'),
                        'ask': this.safeFloat(ticker, 'sell'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last'),
                        'change': undefined,
                        'percentage': this.safeString(ticker, 'percent'),
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'vol'),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                bibox.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMdata(this.extend({
                                            'cmd': 'ticker',
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTicker(response['result'], market)];
                            }
                        });
                    });
                };
                bibox.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, result, t, ticker, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMdata(this.extend({
                                        'cmd': 'marketAll',
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    tickers = response['result'];
                                    result = {};
                                    for (t = 0; t < tickers.length; t++) {
                                        ticker = this.parseTicker(tickers[t]);
                                        symbol = ticker['symbol'];
                                        if (symbols && (!(symbol in symbols))) {
                                            continue;
                                        }
                                        result[symbol] = ticker;
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bibox.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = trade['time'];
                    var side = this.safeInteger(trade, 'side');
                    side = this.safeInteger(trade, 'order_side', side);
                    side = (side === 1) ? 'buy' : 'sell';
                    if (typeof market === 'undefined') {
                        var marketId = this.safeString(trade, 'pair');
                        if (typeof marketId !== 'undefined')
                            if (marketId in this.markets_by_id)
                                market = this.markets_by_id[marketId];
                    }
                    var symbol = (typeof market !== 'undefined') ? market['symbol'] : undefined;
                    var fee = undefined;
                    if ('fee' in trade) {
                        fee = {
                            'cost': this.safeFloat(trade, 'fee'),
                            'currency': undefined,
                        };
                    }
                    return {
                        'id': undefined,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': 'limit',
                        'side': side,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                        'fee': fee,
                    };
                };
                bibox.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, size, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    size = (limit) ? limit : 200;
                                    return [4, this.publicGetMdata(this.extend({
                                            'cmd': 'deals',
                                            'pair': market['id'],
                                            'size': size,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['result'], market, since, limit)];
                            }
                        });
                    });
                };
                bibox.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = 200; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'cmd': 'depth',
                                        'pair': market['id'],
                                    };
                                    request['size'] = limit;
                                    return [4, this.publicGetMdata(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrderBook(response['result'], this.safeFloat(response['result'], 'update_time'), 'bids', 'asks', 'price', 'volume')];
                            }
                        });
                    });
                };
                bibox.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv['time'],
                        ohlcv['open'],
                        ohlcv['high'],
                        ohlcv['low'],
                        ohlcv['close'],
                        ohlcv['vol'],
                    ];
                };
                bibox.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 1000; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMdata(this.extend({
                                            'cmd': 'kline',
                                            'pair': market['id'],
                                            'period': this.timeframes[timeframe],
                                            'size': limit,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response['result'], market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                bibox.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, currencies, result, i, currency, id, code, precision, deposit, withdraw, active;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostTransfer({
                                        'cmd': 'transfer/coinList',
                                        'body': {},
                                    })];
                                case 1:
                                    response = _a.sent();
                                    currencies = response['result'];
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['symbol'];
                                        code = this.commonCurrencyCode(id);
                                        precision = 8;
                                        deposit = currency['enable_deposit'];
                                        withdraw = currency['enable_withdraw'];
                                        active = (deposit && withdraw);
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'info': currency,
                                            'name': currency['name'],
                                            'active': active,
                                            'status': 'ok',
                                            'fee': undefined,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': undefined,
                                                    'max': Math.pow(10, precision),
                                                },
                                            },
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bibox.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, indexed, keys, i, id, currency, account, balance, used, free, total;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostTransfer({
                                            'cmd': 'transfer/assets',
                                            'body': this.extend({
                                                'select': 1,
                                            }, params),
                                        })];
                                case 2:
                                    response = _a.sent();
                                    balances = response['result'];
                                    result = { 'info': balances };
                                    indexed = undefined;
                                    if ('assets_list' in balances) {
                                        indexed = this.indexBy(balances['assets_list'], 'coin_symbol');
                                    }
                                    else {
                                        indexed = {};
                                    }
                                    keys = Object.keys(indexed);
                                    for (i = 0; i < keys.length; i++) {
                                        id = keys[i];
                                        currency = this.commonCurrencyCode(id);
                                        account = this.account();
                                        balance = indexed[id];
                                        used = parseFloat(balance['freeze']);
                                        free = parseFloat(balance['balance']);
                                        total = this.sum(free, used);
                                        account['free'] = free;
                                        account['used'] = used;
                                        account['total'] = total;
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bibox.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderType, orderSide, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    orderType = (type === 'limit') ? 2 : 1;
                                    orderSide = (side === 'buy') ? 1 : 2;
                                    return [4, this.privatePostOrderpending({
                                            'cmd': 'orderpending/trade',
                                            'body': this.extend({
                                                'pair': market['id'],
                                                'account_type': 0,
                                                'order_type': orderType,
                                                'order_side': orderSide,
                                                'pay_bix': 0,
                                                'amount': amount,
                                                'price': price,
                                            }, params),
                                        })];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': this.safeString(response, 'result'),
                                        }];
                            }
                        });
                    });
                };
                bibox.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostOrderpending({
                                        'cmd': 'orderpending/cancelTrade',
                                        'body': this.extend({
                                            'orders_id': id,
                                        }, params),
                                    })];
                                case 1:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                bibox.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    else {
                        symbol = order['coin_symbol'] + '/' + order['currency_symbol'];
                    }
                    var type = (order['order_type'] === 1) ? 'market' : 'limit';
                    var timestamp = order['createdAt'];
                    var price = order['price'];
                    var filled = this.safeFloat(order, 'deal_amount');
                    var amount = this.safeFloat(order, 'amount');
                    var cost = this.safeFloat(order, 'money');
                    var remaining = undefined;
                    if (typeof filled !== 'undefined') {
                        if (typeof amount !== 'undefined')
                            remaining = amount - filled;
                        if (typeof cost === 'undefined')
                            cost = price * filled;
                    }
                    var side = (order['order_side'] === 1) ? 'buy' : 'sell';
                    var status = this.safeString(order, 'status');
                    if (typeof status !== 'undefined')
                        status = this.parseOrderStatus(status);
                    var result = {
                        'info': order,
                        'id': this.safeString(order, 'id'),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'cost': cost ? cost : parseFloat(price) * filled,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': this.safeFloat(order, 'fee'),
                    };
                    return result;
                };
                bibox.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        '1': 'pending',
                        '2': 'open',
                        '3': 'closed',
                        '4': 'canceled',
                        '5': 'canceled',
                        '6': 'canceled',
                    };
                    return this.safeString(statuses, status, status.toLowerCase());
                };
                bibox.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, pair, size, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = undefined;
                                    pair = undefined;
                                    if (!(typeof symbol !== 'undefined')) return [3, 2];
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    pair = market['id'];
                                    _a.label = 2;
                                case 2:
                                    size = (limit) ? limit : 200;
                                    return [4, this.privatePostOrderpending({
                                            'cmd': 'orderpending/orderPendingList',
                                            'body': this.extend({
                                                'pair': pair,
                                                'account_type': 0,
                                                'page': 1,
                                                'size': size,
                                            }, params),
                                        })];
                                case 3:
                                    response = _a.sent();
                                    orders = this.safeValue(response['result'], 'items', []);
                                    return [2, this.parseOrders(orders, market, since, limit)];
                            }
                        });
                    });
                };
                bibox.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 200; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof symbol === 'undefined')
                                        throw new ExchangeError(this.id + ' fetchClosedOrders requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostOrderpending({
                                            'cmd': 'orderpending/pendingHistoryList',
                                            'body': this.extend({
                                                'pair': market['id'],
                                                'account_type': 0,
                                                'page': 1,
                                                'size': limit,
                                            }, params),
                                        })];
                                case 2:
                                    response = _a.sent();
                                    orders = this.safeValue(response['result'], 'items', []);
                                    return [2, this.parseOrders(orders, market, since, limit)];
                            }
                        });
                    });
                };
                bibox.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, size, response, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchMyTrades requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    size = (limit) ? limit : 200;
                                    return [4, this.privatePostOrderpending({
                                            'cmd': 'orderpending/orderHistoryList',
                                            'body': this.extend({
                                                'pair': market['id'],
                                                'account_type': 0,
                                                'page': 1,
                                                'size': size,
                                            }, params),
                                        })];
                                case 2:
                                    response = _a.sent();
                                    trades = this.safeValue(response['result'], 'items', []);
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                bibox.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privatePostTransfer({
                                            'cmd': 'transfer/transferOutInfo',
                                            'body': this.extend({
                                                'coin_symbol': currency['id'],
                                            }, params),
                                        })];
                                case 2:
                                    response = _a.sent();
                                    result = {
                                        'info': response,
                                        'address': undefined,
                                    };
                                    return [2, result];
                            }
                        });
                    });
                };
                bibox.prototype.withdraw = function (code, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, body, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    if (typeof this.password === 'undefined')
                                        if (!('trade_pwd' in params))
                                            throw new ExchangeError(this.id + ' withdraw() requires this.password set on the exchange instance or a trade_pwd parameter');
                                    if (!('totp_code' in params))
                                        throw new ExchangeError(this.id + ' withdraw() requires a totp_code parameter for 2FA authentication');
                                    body = {
                                        'trade_pwd': this.password,
                                        'coin_symbol': currency['id'],
                                        'amount': amount,
                                        'addr': address,
                                    };
                                    if (typeof tag !== 'undefined')
                                        body['address_remark'] = tag;
                                    return [4, this.privatePostTransfer({
                                            'cmd': 'transfer/transferOut',
                                            'body': this.extend(body, params),
                                        })];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                bibox.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + path;
                    var cmds = this.json([params]);
                    if (api === 'public') {
                        if (method !== 'GET')
                            body = { 'cmds': cmds };
                        else if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        body = {
                            'cmds': cmds,
                            'apikey': this.apiKey,
                            'sign': this.hmac(this.encode(cmds), this.encode(this.secret), 'md5'),
                        };
                    }
                    if (typeof body !== 'undefined')
                        body = this.json(body, { 'convertArraysToObjects': true });
                    headers = { 'Content-Type': 'application/json' };
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bibox.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, message, code;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    message = this.id + ' ' + this.json(response);
                                    if ('error' in response) {
                                        if ('code' in response['error']) {
                                            code = response['error']['code'];
                                            if (code === '2033')
                                                throw new OrderNotFound(message);
                                            else if (code === '2068')
                                                throw new InvalidOrder(message);
                                            else if (code === '3012')
                                                throw new AuthenticationError(message);
                                            else if (code === '3025')
                                                throw new AuthenticationError(message);
                                            else if (code === '4000')
                                                throw new ExchangeNotAvailable(message);
                                            else if (code === '4003')
                                                throw new DDoSProtection(message);
                                        }
                                        throw new ExchangeError(message);
                                    }
                                    if (!('result' in response))
                                        throw new ExchangeError(message);
                                    if (method === 'GET') {
                                        return [2, response];
                                    }
                                    else {
                                        return [2, response['result'][0]];
                                    }
                                    return [2];
                            }
                        });
                    });
                };
                return bibox;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 23: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound, InvalidOrder = _a.InvalidOrder, DDoSProtection = _a.DDoSProtection, InvalidNonce = _a.InvalidNonce, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(binance, _super);
                function binance() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                binance.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'binance',
                        'name': 'Binance',
                        'countries': 'JP',
                        'rateLimit': 500,
                        'has': {
                            'fetchDepositAddress': true,
                            'CORS': false,
                            'fetchBidsAsks': true,
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                            'fetchMyTrades': true,
                            'fetchOrder': true,
                            'fetchOrders': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1m': '1m',
                            '3m': '3m',
                            '5m': '5m',
                            '15m': '15m',
                            '30m': '30m',
                            '1h': '1h',
                            '2h': '2h',
                            '4h': '4h',
                            '6h': '6h',
                            '8h': '8h',
                            '12h': '12h',
                            '1d': '1d',
                            '3d': '3d',
                            '1w': '1w',
                            '1M': '1M',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg',
                            'api': {
                                'web': 'https://www.binance.com',
                                'wapi': 'https://api.binance.com/wapi/v3',
                                'public': 'https://api.binance.com/api/v1',
                                'private': 'https://api.binance.com/api/v3',
                                'v3': 'https://api.binance.com/api/v3',
                                'v1': 'https://api.binance.com/api/v1',
                            },
                            'www': 'https://www.binance.com',
                            'doc': 'https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md',
                            'fees': [
                                'https://binance.zendesk.com/hc/en-us/articles/115000429332',
                                'https://support.binance.com/hc/en-us/articles/115000583311',
                            ],
                        },
                        'api': {
                            'web': {
                                'get': [
                                    'exchange/public/product',
                                ],
                            },
                            'wapi': {
                                'post': [
                                    'withdraw',
                                ],
                                'get': [
                                    'depositHistory',
                                    'withdrawHistory',
                                    'depositAddress',
                                    'accountStatus',
                                    'systemStatus',
                                ],
                            },
                            'v3': {
                                'get': [
                                    'ticker/price',
                                    'ticker/bookTicker',
                                ],
                            },
                            'public': {
                                'get': [
                                    'exchangeInfo',
                                    'ping',
                                    'time',
                                    'depth',
                                    'aggTrades',
                                    'klines',
                                    'ticker/24hr',
                                    'ticker/allPrices',
                                    'ticker/allBookTickers',
                                    'ticker/price',
                                    'ticker/bookTicker',
                                    'exchangeInfo',
                                ],
                                'put': ['userDataStream'],
                                'post': ['userDataStream'],
                                'delete': ['userDataStream'],
                            },
                            'private': {
                                'get': [
                                    'order',
                                    'openOrders',
                                    'allOrders',
                                    'account',
                                    'myTrades',
                                ],
                                'post': [
                                    'order',
                                    'order/test',
                                ],
                                'delete': [
                                    'order',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'taker': 0.001,
                                'maker': 0.001,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'ADA': 1.0,
                                    'ADX': 4.7,
                                    'AION': 1.9,
                                    'AMB': 11.4,
                                    'APPC': 6.5,
                                    'ARK': 0.1,
                                    'ARN': 3.1,
                                    'AST': 10.0,
                                    'BAT': 18.0,
                                    'BCD': 1.0,
                                    'BCH': 0.001,
                                    'BCPT': 10.2,
                                    'BCX': 1.0,
                                    'BNB': 0.7,
                                    'BNT': 1.5,
                                    'BQX': 1.6,
                                    'BRD': 6.4,
                                    'BTC': 0.001,
                                    'BTG': 0.001,
                                    'BTM': 5.0,
                                    'BTS': 1.0,
                                    'CDT': 67.0,
                                    'CMT': 37.0,
                                    'CND': 47.0,
                                    'CTR': 5.4,
                                    'DASH': 0.002,
                                    'DGD': 0.06,
                                    'DLT': 11.7,
                                    'DNT': 51.0,
                                    'EDO': 2.5,
                                    'ELF': 6.5,
                                    'ENG': 2.1,
                                    'ENJ': 42.0,
                                    'EOS': 1.0,
                                    'ETC': 0.01,
                                    'ETF': 1.0,
                                    'ETH': 0.01,
                                    'EVX': 2.5,
                                    'FUEL': 45.0,
                                    'FUN': 85.0,
                                    'GAS': 0,
                                    'GTO': 20.0,
                                    'GVT': 0.53,
                                    'GXS': 0.3,
                                    'HCC': 0.0005,
                                    'HSR': 0.0001,
                                    'ICN': 3.5,
                                    'ICX': 1.3,
                                    'INS': 1.5,
                                    'IOTA': 0.5,
                                    'KMD': 0.002,
                                    'KNC': 2.6,
                                    'LEND': 54.0,
                                    'LINK': 12.8,
                                    'LLT': 54.0,
                                    'LRC': 9.1,
                                    'LSK': 0.1,
                                    'LTC': 0.01,
                                    'LUN': 0.29,
                                    'MANA': 74.0,
                                    'MCO': 0.86,
                                    'MDA': 4.7,
                                    'MOD': 2.0,
                                    'MTH': 34.0,
                                    'MTL': 1.9,
                                    'NAV': 0.2,
                                    'NEBL': 0.01,
                                    'NEO': 0.0,
                                    'NULS': 2.1,
                                    'OAX': 8.3,
                                    'OMG': 0.57,
                                    'OST': 17.0,
                                    'POE': 88.0,
                                    'POWR': 8.6,
                                    'PPT': 0.25,
                                    'QSP': 21.0,
                                    'QTUM': 0.01,
                                    'RCN': 35.0,
                                    'RDN': 2.2,
                                    'REQ': 18.1,
                                    'RLC': 4.1,
                                    'SALT': 1.3,
                                    'SBTC': 1.0,
                                    'SNGLS': 42,
                                    'SNM': 29.0,
                                    'SNT': 32.0,
                                    'STORJ': 5.9,
                                    'STRAT': 0.1,
                                    'SUB': 7.4,
                                    'TNB': 82.0,
                                    'TNT': 47.0,
                                    'TRIG': 6.7,
                                    'TRX': 129.0,
                                    'USDT': 23.0,
                                    'VEN': 1.8,
                                    'VIB': 28.0,
                                    'VIBE': 7.2,
                                    'WABI': 3.5,
                                    'WAVES': 0.002,
                                    'WINGS': 9.3,
                                    'WTC': 0.5,
                                    'XLM': 0.01,
                                    'XMR': 0.04,
                                    'XRP': 0.25,
                                    'XVG': 0.1,
                                    'XZC': 0.02,
                                    'YOYOW': 39.0,
                                    'ZEC': 0.005,
                                    'ZRX': 5.7,
                                },
                                'deposit': {
                                    'ARK': 0,
                                    'AST': 0,
                                    'BCH': 0,
                                    'BNB': 0,
                                    'BNT': 0,
                                    'BQX': 0,
                                    'BTC': 0,
                                    'BTG': 0,
                                    'CTR': 0,
                                    'DASH': 0,
                                    'DNT': 0,
                                    'ENG': 0,
                                    'ENJ': 0,
                                    'EOS': 0,
                                    'ETC': 0,
                                    'ETH': 0,
                                    'EVX': 0,
                                    'FUN': 0,
                                    'GAS': 0,
                                    'HSR': 0,
                                    'ICN': 0,
                                    'IOTA': 0,
                                    'KNC': 0,
                                    'LINK': 0,
                                    'LRC': 0,
                                    'LTC': 0,
                                    'MCO': 0,
                                    'MDA': 0,
                                    'MOD': 0,
                                    'MTH': 0,
                                    'MTL': 0,
                                    'NEO': 0,
                                    'OAX': 0,
                                    'OMG': 0,
                                    'POWR': 0,
                                    'QTUM': 0,
                                    'REQ': 0,
                                    'SALT': 0,
                                    'SNGLS': 0,
                                    'SNM': 0,
                                    'SNT': 0,
                                    'STORJ': 0,
                                    'STRAT': 0,
                                    'SUB': 0,
                                    'TRX': 0,
                                    'USDT': 0,
                                    'VIB': 0,
                                    'WTC': 0,
                                    'XRP': 0,
                                    'XVG': 0,
                                    'YOYOW': 0,
                                    'ZRX': 0,
                                },
                            },
                        },
                        'options': {
                            'warnOnFetchOpenOrdersWithoutSymbol': true,
                            'recvWindow': 5 * 1000,
                            'timeDifference': 0,
                            'adjustForTimeDifference': false,
                        },
                        'exceptions': {
                            '-1013': InvalidOrder,
                            '-1021': InvalidNonce,
                            '-1100': InvalidOrder,
                            '-2010': InsufficientFunds,
                            '-2011': OrderNotFound,
                            '-2015': AuthenticationError,
                        },
                    });
                };
                binance.prototype.nonce = function () {
                    return this.milliseconds() - this.options['timeDifference'];
                };
                binance.prototype.loadTimeDifference = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, after;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTime()];
                                case 1:
                                    response = _a.sent();
                                    after = this.milliseconds();
                                    this.options['timeDifference'] = parseInt(after - response['serverTime']);
                                    return [2, this.options['timeDifference']];
                            }
                        });
                    });
                };
                binance.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, i, market, id, baseId, quoteId, base, quote, symbol, filters, precision, active, lot, entry, filter, filter;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetExchangeInfo()];
                                case 1:
                                    response = _a.sent();
                                    if (!this.options['adjustForTimeDifference']) return [3, 3];
                                    return [4, this.loadTimeDifference()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    markets = response['symbols'];
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        id = market['symbol'];
                                        if (id === '123456')
                                            continue;
                                        baseId = market['baseAsset'];
                                        quoteId = market['quoteAsset'];
                                        base = this.commonCurrencyCode(baseId);
                                        quote = this.commonCurrencyCode(quoteId);
                                        symbol = base + '/' + quote;
                                        filters = this.indexBy(market['filters'], 'filterType');
                                        precision = {
                                            'base': market['baseAssetPrecision'],
                                            'quote': market['quotePrecision'],
                                            'amount': market['baseAssetPrecision'],
                                            'price': market['quotePrecision'],
                                        };
                                        active = (market['status'] === 'TRADING');
                                        lot = -1 * Math.log10(precision['amount']);
                                        entry = {
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'info': market,
                                            'lot': lot,
                                            'active': active,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision['amount']),
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision['price']),
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': lot,
                                                    'max': undefined,
                                                },
                                            },
                                        };
                                        if ('PRICE_FILTER' in filters) {
                                            filter = filters['PRICE_FILTER'];
                                            entry['precision']['price'] = this.precisionFromString(filter['tickSize']);
                                            entry['limits']['price'] = {
                                                'min': parseFloat(filter['minPrice']),
                                                'max': parseFloat(filter['maxPrice']),
                                            };
                                        }
                                        if ('LOT_SIZE' in filters) {
                                            filter = filters['LOT_SIZE'];
                                            entry['precision']['amount'] = this.precisionFromString(filter['stepSize']);
                                            entry['lot'] = parseFloat(filter['stepSize']);
                                            entry['limits']['amount'] = {
                                                'min': parseFloat(filter['minQty']),
                                                'max': parseFloat(filter['maxQty']),
                                            };
                                        }
                                        if ('MIN_NOTIONAL' in filters) {
                                            entry['limits']['cost']['min'] = parseFloat(filters['MIN_NOTIONAL']['minNotional']);
                                        }
                                        result.push(entry);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                binance.prototype.calculateFee = function (symbol, type, side, amount, price, takerOrMaker, params) {
                    if (takerOrMaker === void 0) { takerOrMaker = 'taker'; }
                    if (params === void 0) { params = {}; }
                    var market = this.markets[symbol];
                    var key = 'quote';
                    var rate = market[takerOrMaker];
                    var cost = parseFloat(this.costToPrecision(symbol, amount * rate));
                    if (side === 'sell') {
                        cost *= price;
                    }
                    else {
                        key = 'base';
                    }
                    return {
                        'type': takerOrMaker,
                        'currency': market[key],
                        'rate': rate,
                        'cost': parseFloat(this.feeToPrecision(symbol, cost)),
                    };
                };
                binance.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, balances, i, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetAccount(params)];
                                case 2:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    balances = response['balances'];
                                    for (i = 0; i < balances.length; i++) {
                                        balance = balances[i];
                                        currency = balance['asset'];
                                        if (currency in this.currencies_by_id)
                                            currency = this.currencies_by_id[currency]['code'];
                                        account = {
                                            'free': parseFloat(balance['free']),
                                            'used': parseFloat(balance['locked']),
                                            'total': 0.0,
                                        };
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                binance.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetDepth(this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                binance.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.safeInteger(ticker, 'closeTime');
                    var iso8601 = (typeof timestamp === 'undefined') ? undefined : this.iso8601(timestamp);
                    var symbol = this.findSymbol(this.safeString(ticker, 'symbol'), market);
                    var last = this.safeFloat(ticker, 'lastPrice');
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': iso8601,
                        'high': this.safeFloat(ticker, 'highPrice'),
                        'low': this.safeFloat(ticker, 'lowPrice'),
                        'bid': this.safeFloat(ticker, 'bidPrice'),
                        'bidVolume': this.safeFloat(ticker, 'bidQty'),
                        'ask': this.safeFloat(ticker, 'askPrice'),
                        'askVolume': this.safeFloat(ticker, 'askQty'),
                        'vwap': this.safeFloat(ticker, 'weightedAvgPrice'),
                        'open': this.safeFloat(ticker, 'openPrice'),
                        'close': last,
                        'last': last,
                        'previousClose': this.safeFloat(ticker, 'prevClosePrice'),
                        'change': this.safeFloat(ticker, 'priceChange'),
                        'percentage': this.safeFloat(ticker, 'priceChangePercent'),
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'volume'),
                        'quoteVolume': this.safeFloat(ticker, 'quoteVolume'),
                        'info': ticker,
                    };
                };
                binance.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTicker24hr(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTicker(response, market)];
                            }
                        });
                    });
                };
                binance.prototype.parseTickers = function (rawTickers, symbols) {
                    if (symbols === void 0) { symbols = undefined; }
                    var tickers = [];
                    for (var i = 0; i < rawTickers.length; i++) {
                        tickers.push(this.parseTicker(rawTickers[i]));
                    }
                    var tickersBySymbol = this.indexBy(tickers, 'symbol');
                    if (typeof symbols === 'undefined')
                        return tickersBySymbol;
                    var result = {};
                    for (var i = 0; i < symbols.length; i++) {
                        var symbol = symbols[i];
                        if (symbol in tickersBySymbol)
                            result[symbol] = tickersBySymbol[symbol];
                    }
                    return result;
                };
                binance.prototype.fetchBidAsks = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var rawTickers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickerBookTicker(params)];
                                case 2:
                                    rawTickers = _a.sent();
                                    return [2, this.parseTickers(rawTickers, symbols)];
                            }
                        });
                    });
                };
                binance.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var rawTickers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker24hr(params)];
                                case 2:
                                    rawTickers = _a.sent();
                                    return [2, this.parseTickers(rawTickers, symbols)];
                            }
                        });
                    });
                };
                binance.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv[0],
                        parseFloat(ohlcv[1]),
                        parseFloat(ohlcv[2]),
                        parseFloat(ohlcv[3]),
                        parseFloat(ohlcv[4]),
                        parseFloat(ohlcv[5]),
                    ];
                };
                binance.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 500; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'interval': this.timeframes[timeframe],
                                        'limit': limit,
                                    };
                                    if (typeof since !== 'undefined')
                                        request['startTime'] = since;
                                    return [4, this.publicGetKlines(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                binance.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestampField = ('T' in trade) ? 'T' : 'time';
                    var timestamp = trade[timestampField];
                    var priceField = ('p' in trade) ? 'p' : 'price';
                    var price = parseFloat(trade[priceField]);
                    var amountField = ('q' in trade) ? 'q' : 'qty';
                    var amount = parseFloat(trade[amountField]);
                    var idField = ('a' in trade) ? 'a' : 'id';
                    var id = trade[idField].toString();
                    var side = undefined;
                    var order = undefined;
                    if ('orderId' in trade)
                        order = trade['orderId'].toString();
                    if ('m' in trade) {
                        side = trade['m'] ? 'sell' : 'buy';
                    }
                    else {
                        side = (trade['isBuyer']) ? 'buy' : 'sell';
                    }
                    var fee = undefined;
                    if ('commission' in trade) {
                        fee = {
                            'cost': parseFloat(trade['commission']),
                            'currency': this.commonCurrencyCode(trade['commissionAsset']),
                        };
                    }
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'id': id,
                        'order': order,
                        'type': undefined,
                        'side': side,
                        'price': price,
                        'cost': price * amount,
                        'amount': amount,
                        'fee': fee,
                    };
                };
                binance.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (typeof since !== 'undefined') {
                                        request['startTime'] = since;
                                        request['endTime'] = since + 3600000;
                                    }
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetAggTrades(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                binance.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        'NEW': 'open',
                        'PARTIALLY_FILLED': 'open',
                        'FILLED': 'closed',
                        'CANCELED': 'canceled',
                    };
                    return (status in statuses) ? statuses[status] : status.toLowerCase();
                };
                binance.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var status = this.safeValue(order, 'status');
                    if (typeof status !== 'undefined')
                        status = this.parseOrderStatus(status);
                    var symbol = this.findSymbol(this.safeString(order, 'symbol'), market);
                    var timestamp = undefined;
                    if ('time' in order)
                        timestamp = order['time'];
                    else if ('transactTime' in order)
                        timestamp = order['transactTime'];
                    else
                        throw new ExchangeError(this.id + ' malformed order: ' + this.json(order));
                    var price = parseFloat(order['price']);
                    var amount = parseFloat(order['origQty']);
                    var filled = this.safeFloat(order, 'executedQty', 0.0);
                    var remaining = Math.max(amount - filled, 0.0);
                    var cost = undefined;
                    if (typeof price !== 'undefined')
                        if (typeof filled !== 'undefined')
                            cost = price * filled;
                    var result = {
                        'info': order,
                        'id': order['orderId'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': order['type'].toLowerCase(),
                        'side': order['side'].toLowerCase(),
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': undefined,
                    };
                    return result;
                };
                binance.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    order = {
                                        'symbol': market['id'],
                                        'quantity': this.amountToString(symbol, amount),
                                        'type': type.toUpperCase(),
                                        'side': side.toUpperCase(),
                                    };
                                    if (type === 'limit') {
                                        order = this.extend(order, {
                                            'price': this.priceToPrecision(symbol, price),
                                            'timeInForce': 'GTC',
                                        });
                                    }
                                    return [4, this.privatePostOrder(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response)];
                            }
                        });
                    });
                };
                binance.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, origClientOrderId, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOrder requires a symbol param');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    origClientOrderId = this.safeValue(params, 'origClientOrderId');
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (typeof origClientOrderId !== 'undefined')
                                        request['origClientOrderId'] = origClientOrderId;
                                    else
                                        request['orderId'] = parseInt(id);
                                    return [4, this.privateGetOrder(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response, market)];
                            }
                        });
                    });
                };
                binance.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOrders requires a symbol param');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (limit)
                                        request['limit'] = limit;
                                    return [4, this.privateGetAllOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                binance.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, symbols, numSymbols, fetchOpenOrdersRateLimit, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (typeof symbol !== 'undefined') {
                                        market = this.market(symbol);
                                        request['symbol'] = market['id'];
                                    }
                                    else if (this.options['warnOnFetchOpenOrdersWithoutSymbol']) {
                                        symbols = this.symbols;
                                        numSymbols = symbols.length;
                                        fetchOpenOrdersRateLimit = parseInt(numSymbols / 2);
                                        throw new ExchangeError(this.id + ' fetchOpenOrders WARNING: fetching open orders without specifying a symbol is rate-limited to one call per ' + fetchOpenOrdersRateLimit.toString() + ' seconds. Do not call this method frequently to avoid ban. Set ' + this.id + '.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.');
                                    }
                                    return [4, this.privateGetOpenOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                binance.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.filterBy(orders, 'status', 'closed')];
                            }
                        });
                    });
                };
                binance.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' cancelOrder requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privateDeleteOrder(this.extend({
                                            'symbol': market['id'],
                                            'orderId': parseInt(id),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                binance.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchMyTrades requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (limit)
                                        request['limit'] = limit;
                                    return [4, this.privateGetMyTrades(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                binance.prototype.commonCurrencyCode = function (currency) {
                    var currencies = {
                        'YOYO': 'YOYOW',
                        'BCC': 'BCH',
                        'NANO': 'XRB',
                    };
                    if (currency in currencies)
                        return currencies[currency];
                    return currency;
                };
                binance.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, address, tag;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.wapiGetDepositAddress(this.extend({
                                            'asset': currency['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    if ('success' in response) {
                                        if (response['success']) {
                                            address = this.safeString(response, 'address');
                                            tag = this.safeString(response, 'addressTag');
                                            return [2, {
                                                    'currency': code,
                                                    'address': this.checkAddress(address),
                                                    'tag': tag,
                                                    'status': 'ok',
                                                    'info': response,
                                                }];
                                        }
                                    }
                                    throw new ExchangeError(this.id + ' fetchDepositAddress failed: ' + this.last_http_response);
                            }
                        });
                    });
                };
                binance.prototype.withdraw = function (code, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, name, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    name = address.slice(0, 20);
                                    request = {
                                        'asset': currency['id'],
                                        'address': address,
                                        'amount': parseFloat(amount),
                                        'name': name,
                                    };
                                    if (tag)
                                        request['addressTag'] = tag;
                                    return [4, this.wapiPostWithdraw(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': this.safeString(response, 'id'),
                                        }];
                            }
                        });
                    });
                };
                binance.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    url += '/' + path;
                    if (api === 'wapi')
                        url += '.html';
                    if (path === 'userDataStream') {
                        body = this.urlencode(params);
                        headers = {
                            'X-MBX-APIKEY': this.apiKey,
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    else if ((api === 'private') || (api === 'wapi')) {
                        this.checkRequiredCredentials();
                        var query = this.urlencode(this.extend({
                            'timestamp': this.nonce(),
                            'recvWindow': this.options['recvWindow'],
                        }, params));
                        var signature = this.hmac(this.encode(query), this.encode(this.secret));
                        query += '&' + 'signature=' + signature;
                        headers = {
                            'X-MBX-APIKEY': this.apiKey,
                        };
                        if ((method === 'GET') || (api === 'wapi')) {
                            url += '?' + query;
                        }
                        else {
                            body = query;
                            headers['Content-Type'] = 'application/x-www-form-urlencoded';
                        }
                    }
                    else {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                binance.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code < 300)
                        return;
                    if (code < 400)
                        return;
                    if ((code === 418) || (code === 429))
                        throw new DDoSProtection(this.id + ' ' + code.toString() + ' ' + reason + ' ' + body);
                    if (body.indexOf('Price * QTY is zero or less') >= 0)
                        throw new InvalidOrder(this.id + ' order cost = amount * price is zero or less ' + body);
                    if (body.indexOf('LOT_SIZE') >= 0)
                        throw new InvalidOrder(this.id + ' order amount should be evenly divisible by lot size, use this.amountToLots (symbol, amount) ' + body);
                    if (body.indexOf('PRICE_FILTER') >= 0)
                        throw new InvalidOrder(this.id + ' order price exceeds allowed price precision or invalid, use this.priceToPrecision (symbol, amount) ' + body);
                    if (body.indexOf('Order does not exist') >= 0)
                        throw new OrderNotFound(this.id + ' ' + body);
                    if (typeof body === 'string') {
                        if (body.length > 0) {
                            if (body[0] === '{') {
                                var response = JSON.parse(body);
                                var error = this.safeString(response, 'code');
                                if (typeof error !== 'undefined') {
                                    var exceptions = this.exceptions;
                                    if (error in exceptions) {
                                        throw new exceptions[error](this.id + ' ' + this.json(response));
                                    }
                                    else {
                                        throw new ExchangeError(this.id + ': unknown error code: ' + this.json(response));
                                    }
                                }
                            }
                        }
                    }
                };
                return binance;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 24: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            module.exports = (function (_super) {
                __extends(bit2c, _super);
                function bit2c() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bit2c.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bit2c',
                        'name': 'Bit2C',
                        'countries': 'IL',
                        'rateLimit': 3000,
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg',
                            'api': 'https://www.bit2c.co.il',
                            'www': 'https://www.bit2c.co.il',
                            'doc': [
                                'https://www.bit2c.co.il/home/api',
                                'https://github.com/OferE/bit2c',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'Exchanges/{pair}/Ticker',
                                    'Exchanges/{pair}/orderbook',
                                    'Exchanges/{pair}/trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    'Account/Balance',
                                    'Account/Balance/v2',
                                    'Merchant/CreateCheckout',
                                    'Order/AccountHistory',
                                    'Order/AddCoinFundsRequest',
                                    'Order/AddFund',
                                    'Order/AddOrder',
                                    'Order/AddOrderMarketPriceBuy',
                                    'Order/AddOrderMarketPriceSell',
                                    'Order/CancelOrder',
                                    'Order/MyOrders',
                                    'Payment/GetMyId',
                                    'Payment/Send',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/NIS': { 'id': 'BtcNis', 'symbol': 'BTC/NIS', 'base': 'BTC', 'quote': 'NIS' },
                            'BCH/NIS': { 'id': 'BchNis', 'symbol': 'BCH/NIS', 'base': 'BCH', 'quote': 'NIS' },
                            'LTC/NIS': { 'id': 'LtcNis', 'symbol': 'LTC/NIS', 'base': 'LTC', 'quote': 'NIS' },
                            'BTG/NIS': { 'id': 'BtgNis', 'symbol': 'BTG/NIS', 'base': 'BTG', 'quote': 'NIS' },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.5 / 100,
                                'taker': 0.5 / 100,
                            },
                        },
                    });
                };
                bit2c.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balance, result, currencies, i, currency, account, available;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostAccountBalanceV2()];
                                case 1:
                                    balance = _a.sent();
                                    result = { 'info': balance };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        account = this.account();
                                        if (currency in balance) {
                                            available = 'AVAILABLE_' + currency;
                                            account['free'] = balance[available];
                                            account['total'] = balance[currency];
                                            account['used'] = account['total'] - account['free'];
                                        }
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bit2c.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetExchangesPairOrderbook(this.extend({
                                        'pair': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                bit2c.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp, averagePrice, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetExchangesPairTicker(this.extend({
                                        'pair': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = this.milliseconds();
                                    averagePrice = parseFloat(ticker['av']);
                                    baseVolume = parseFloat(ticker['a']);
                                    quoteVolume = baseVolume * averagePrice;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': undefined,
                                            'low': undefined,
                                            'bid': parseFloat(ticker['h']),
                                            'ask': parseFloat(ticker['l']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['ll']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': averagePrice,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bit2c.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = parseInt(trade['date']) * 1000;
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'id': trade['tid'].toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'order': undefined,
                        'type': undefined,
                        'side': undefined,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                bit2c.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetExchangesPairTrades(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bit2c.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, order, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    method = 'privatePostOrderAddOrder';
                                    order = {
                                        'Amount': amount,
                                        'Pair': this.marketId(symbol),
                                    };
                                    if (type === 'market') {
                                        method += 'MarketPrice' + this.capitalize(side);
                                    }
                                    else {
                                        order['Price'] = price;
                                        order['Total'] = amount * price;
                                        order['IsBid'] = (side === 'buy');
                                    }
                                    return [4, this[method](this.extend(order, params))];
                                case 1:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result['NewOrder']['id'],
                                        }];
                            }
                        });
                    });
                };
                bit2c.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostOrderCancelOrder({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bit2c.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.implodeParams(path, params);
                    if (api === 'public') {
                        url += '.json';
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var query = this.extend({ 'nonce': nonce }, params);
                        body = this.urlencode(query);
                        var signature = this.hmac(this.encode(body), this.encode(this.secret), 'sha512', 'base64');
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'key': this.apiKey,
                            'sign': this.decode(signature),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return bit2c;
            }(Exchange));
        }, { "./base/Exchange": 8 }], 25: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), InvalidNonce = _a.InvalidNonce, InsufficientFunds = _a.InsufficientFunds, AuthenticationError = _a.AuthenticationError, InvalidOrder = _a.InvalidOrder, ExchangeError = _a.ExchangeError;
            module.exports = (function (_super) {
                __extends(bitbay, _super);
                function bitbay() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitbay.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitbay',
                        'name': 'BitBay',
                        'countries': ['PL', 'EU'],
                        'rateLimit': 1000,
                        'has': {
                            'CORS': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766132-978a7bd8-5ece-11e7-9540-bc96d1e9bbb8.jpg',
                            'www': 'https://bitbay.net',
                            'api': {
                                'public': 'https://bitbay.net/API/Public',
                                'private': 'https://bitbay.net/API/Trading/tradingApi.php',
                            },
                            'doc': [
                                'https://bitbay.net/public-api',
                                'https://bitbay.net/account/tab-api',
                                'https://github.com/BitBayNet/API',
                            ],
                            'fees': 'https://bitbay.net/en/fees',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    '{id}/all',
                                    '{id}/market',
                                    '{id}/orderbook',
                                    '{id}/ticker',
                                    '{id}/trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    'info',
                                    'trade',
                                    'cancel',
                                    'orderbook',
                                    'orders',
                                    'transfer',
                                    'withdraw',
                                    'history',
                                    'transactions',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/USD': { 'id': 'BTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'baseId': 'BTC', 'quoteId': 'USD' },
                            'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'baseId': 'BTC', 'quoteId': 'EUR' },
                            'BTC/PLN': { 'id': 'BTCPLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN', 'baseId': 'BTC', 'quoteId': 'PLN' },
                            'LTC/USD': { 'id': 'LTCUSD', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'baseId': 'LTC', 'quoteId': 'USD' },
                            'LTC/EUR': { 'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR', 'baseId': 'LTC', 'quoteId': 'EUR' },
                            'LTC/PLN': { 'id': 'LTCPLN', 'symbol': 'LTC/PLN', 'base': 'LTC', 'quote': 'PLN', 'baseId': 'LTC', 'quoteId': 'PLN' },
                            'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'LTC', 'quoteId': 'BTC' },
                            'ETH/USD': { 'id': 'ETHUSD', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'baseId': 'ETH', 'quoteId': 'USD' },
                            'ETH/EUR': { 'id': 'ETHEUR', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR', 'baseId': 'ETH', 'quoteId': 'EUR' },
                            'ETH/PLN': { 'id': 'ETHPLN', 'symbol': 'ETH/PLN', 'base': 'ETH', 'quote': 'PLN', 'baseId': 'ETH', 'quoteId': 'PLN' },
                            'ETH/BTC': { 'id': 'ETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'baseId': 'ETH', 'quoteId': 'BTC' },
                            'LSK/USD': { 'id': 'LSKUSD', 'symbol': 'LSK/USD', 'base': 'LSK', 'quote': 'USD', 'baseId': 'LSK', 'quoteId': 'USD' },
                            'LSK/EUR': { 'id': 'LSKEUR', 'symbol': 'LSK/EUR', 'base': 'LSK', 'quote': 'EUR', 'baseId': 'LSK', 'quoteId': 'EUR' },
                            'LSK/PLN': { 'id': 'LSKPLN', 'symbol': 'LSK/PLN', 'base': 'LSK', 'quote': 'PLN', 'baseId': 'LSK', 'quoteId': 'PLN' },
                            'LSK/BTC': { 'id': 'LSKBTC', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC', 'baseId': 'LSK', 'quoteId': 'BTC' },
                            'BCH/USD': { 'id': 'BCCUSD', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD', 'baseId': 'BCC', 'quoteId': 'USD' },
                            'BCH/EUR': { 'id': 'BCCEUR', 'symbol': 'BCH/EUR', 'base': 'BCH', 'quote': 'EUR', 'baseId': 'BCC', 'quoteId': 'EUR' },
                            'BCH/PLN': { 'id': 'BCCPLN', 'symbol': 'BCH/PLN', 'base': 'BCH', 'quote': 'PLN', 'baseId': 'BCC', 'quoteId': 'PLN' },
                            'BCH/BTC': { 'id': 'BCCBTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'baseId': 'BCC', 'quoteId': 'BTC' },
                            'BTG/USD': { 'id': 'BTGUSD', 'symbol': 'BTG/USD', 'base': 'BTG', 'quote': 'USD', 'baseId': 'BTG', 'quoteId': 'USD' },
                            'BTG/EUR': { 'id': 'BTGEUR', 'symbol': 'BTG/EUR', 'base': 'BTG', 'quote': 'EUR', 'baseId': 'BTG', 'quoteId': 'EUR' },
                            'BTG/PLN': { 'id': 'BTGPLN', 'symbol': 'BTG/PLN', 'base': 'BTG', 'quote': 'PLN', 'baseId': 'BTG', 'quoteId': 'PLN' },
                            'BTG/BTC': { 'id': 'BTGBTC', 'symbol': 'BTG/BTC', 'base': 'BTG', 'quote': 'BTC', 'baseId': 'BTG', 'quoteId': 'BTC' },
                            'DASH/USD': { 'id': 'DASHUSD', 'symbol': 'DASH/USD', 'base': 'DASH', 'quote': 'USD', 'baseId': 'DASH', 'quoteId': 'USD' },
                            'DASH/EUR': { 'id': 'DASHEUR', 'symbol': 'DASH/EUR', 'base': 'DASH', 'quote': 'EUR', 'baseId': 'DASH', 'quoteId': 'EUR' },
                            'DASH/PLN': { 'id': 'DASHPLN', 'symbol': 'DASH/PLN', 'base': 'DASH', 'quote': 'PLN', 'baseId': 'DASH', 'quoteId': 'PLN' },
                            'DASH/BTC': { 'id': 'DASHBTC', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC', 'baseId': 'DASH', 'quoteId': 'BTC' },
                            'GAME/USD': { 'id': 'GAMEUSD', 'symbol': 'GAME/USD', 'base': 'GAME', 'quote': 'USD', 'baseId': 'GAME', 'quoteId': 'USD' },
                            'GAME/EUR': { 'id': 'GAMEEUR', 'symbol': 'GAME/EUR', 'base': 'GAME', 'quote': 'EUR', 'baseId': 'GAME', 'quoteId': 'EUR' },
                            'GAME/PLN': { 'id': 'GAMEPLN', 'symbol': 'GAME/PLN', 'base': 'GAME', 'quote': 'PLN', 'baseId': 'GAME', 'quoteId': 'PLN' },
                            'GAME/BTC': { 'id': 'GAMEBTC', 'symbol': 'GAME/BTC', 'base': 'GAME', 'quote': 'BTC', 'baseId': 'GAME', 'quoteId': 'BTC' },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.3 / 100,
                                'taker': 0.0043,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.0009,
                                    'LTC': 0.005,
                                    'ETH': 0.00126,
                                    'LSK': 0.2,
                                    'BCH': 0.0006,
                                    'GAME': 0.005,
                                    'DASH': 0.001,
                                    'BTG': 0.0008,
                                    'PLN': 4,
                                    'EUR': 1.5,
                                },
                            },
                        },
                        'exceptions': {
                            '400': ExchangeError,
                            '401': InvalidOrder,
                            '402': InvalidOrder,
                            '403': InvalidOrder,
                            '404': InvalidOrder,
                            '405': InvalidOrder,
                            '406': InsufficientFunds,
                            '408': InvalidOrder,
                            '501': AuthenticationError,
                            '502': AuthenticationError,
                            '503': InvalidNonce,
                            '504': ExchangeError,
                            '505': AuthenticationError,
                            '506': AuthenticationError,
                            '509': ExchangeError,
                            '510': ExchangeError,
                        },
                    });
                };
                bitbay.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balance, result, codes, i, code, currency, id, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostInfo()];
                                case 1:
                                    response = _a.sent();
                                    if ('balances' in response) {
                                        balance = response['balances'];
                                        result = { 'info': balance };
                                        codes = Object.keys(this.currencies);
                                        for (i = 0; i < codes.length; i++) {
                                            code = codes[i];
                                            currency = this.currencies[code];
                                            id = currency['id'];
                                            account = this.account();
                                            if (id in balance) {
                                                account['free'] = parseFloat(balance[id]['available']);
                                                account['used'] = parseFloat(balance[id]['locked']);
                                                account['total'] = this.sum(account['free'], account['used']);
                                            }
                                            result[code] = account;
                                        }
                                        return [2, this.parseBalance(result)];
                                    }
                                    throw new ExchangeError(this.id + ' empty balance response ' + this.json(response));
                            }
                        });
                    });
                };
                bitbay.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetIdOrderbook(this.extend({
                                        'id': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                bitbay.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp, baseVolume, vwap, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetIdTicker(this.extend({
                                        'id': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = this.milliseconds();
                                    baseVolume = this.safeFloat(ticker, 'volume');
                                    vwap = this.safeFloat(ticker, 'vwap');
                                    quoteVolume = baseVolume * vwap;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': this.safeFloat(ticker, 'max'),
                                            'low': this.safeFloat(ticker, 'min'),
                                            'bid': this.safeFloat(ticker, 'bid'),
                                            'ask': this.safeFloat(ticker, 'ask'),
                                            'vwap': vwap,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': this.safeFloat(ticker, 'last'),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': this.safeFloat(ticker, 'average'),
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bitbay.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['date'] * 1000;
                    return {
                        'id': trade['tid'],
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['type'],
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                bitbay.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetIdTrades(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitbay.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market;
                        return __generator(this, function (_a) {
                            if (type !== 'limit')
                                throw new ExchangeError(this.id + ' allows limit orders only');
                            market = this.market(symbol);
                            return [2, this.privatePostTrade(this.extend({
                                    'type': side,
                                    'currency': market['baseId'],
                                    'amount': amount,
                                    'payment_currency': market['quoteId'],
                                    'rate': price,
                                }, params))];
                        });
                    });
                };
                bitbay.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancel({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitbay.prototype.isFiat = function (currency) {
                    var fiatCurrencies = {
                        'USD': true,
                        'EUR': true,
                        'PLN': true,
                    };
                    if (currency in fiatCurrencies)
                        return true;
                    return false;
                };
                bitbay.prototype.withdraw = function (code, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, currency, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = undefined;
                                    currency = this.currency(code);
                                    request = {
                                        'currency': currency['id'],
                                        'quantity': amount,
                                    };
                                    if (this.isFiat(code)) {
                                        method = 'privatePostWithdraw';
                                    }
                                    else {
                                        method = 'privatePostTransfer';
                                        request['address'] = address;
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                bitbay.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    if (api === 'public') {
                        url += '/' + this.implodeParams(path, params) + '.json';
                    }
                    else {
                        this.checkRequiredCredentials();
                        body = this.urlencode(this.extend({
                            'method': path,
                            'moment': this.nonce(),
                        }, params));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'API-Key': this.apiKey,
                            'API-Hash': this.hmac(this.encode(body), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bitbay.prototype.handleErrors = function (httpCode, reason, url, method, headers, body) {
                    if (typeof body !== 'string')
                        return;
                    if (body.length < 2)
                        return;
                    if ((body[0] === '{') || (body[0] === '[')) {
                        var response = JSON.parse(body);
                        if ('code' in response) {
                            var code = response['code'];
                            var feedback = this.id + ' ' + this.json(response);
                            var exceptions = this.exceptions;
                            if (code in this.exceptions) {
                                throw new exceptions[code](feedback);
                            }
                            else {
                                throw new ExchangeError(feedback);
                            }
                        }
                    }
                };
                return bitbay;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 26: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InsufficientFunds = _a.InsufficientFunds, InvalidOrder = _a.InvalidOrder, OrderNotFound = _a.OrderNotFound, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(bitcoincoid, _super);
                function bitcoincoid() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitcoincoid.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitcoincoid',
                        'name': 'Bitcoin.co.id',
                        'countries': 'ID',
                        'has': {
                            'CORS': false,
                            'createMarketOrder': false,
                            'fetchTickers': false,
                            'fetchOrder': true,
                            'fetchOrders': false,
                            'fetchClosedOrders': true,
                            'fetchOpenOrders': true,
                            'fetchMyTrades': false,
                            'fetchCurrencies': false,
                            'withdraw': false,
                        },
                        'version': '1.7',
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766138-043c7786-5ecf-11e7-882b-809c14f38b53.jpg',
                            'api': {
                                'public': 'https://vip.bitcoin.co.id/api',
                                'private': 'https://vip.bitcoin.co.id/tapi',
                            },
                            'www': 'https://www.bitcoin.co.id',
                            'doc': [
                                'https://vip.bitcoin.co.id/downloads/BITCOINCOID-API-DOCUMENTATION.pdf',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    '{pair}/ticker',
                                    '{pair}/trades',
                                    '{pair}/depth',
                                ],
                            },
                            'private': {
                                'post': [
                                    'getInfo',
                                    'transHistory',
                                    'trade',
                                    'tradeHistory',
                                    'getOrder',
                                    'openOrders',
                                    'cancelOrder',
                                    'orderHistory',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/IDR': { 'id': 'btc_idr', 'symbol': 'BTC/IDR', 'base': 'BTC', 'quote': 'IDR', 'baseId': 'btc', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 0.0001, 'max': undefined } } },
                            'BCH/IDR': { 'id': 'bch_idr', 'symbol': 'BCH/IDR', 'base': 'BCH', 'quote': 'IDR', 'baseId': 'bch', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 0.001, 'max': undefined } } },
                            'BTG/IDR': { 'id': 'btg_idr', 'symbol': 'BTG/IDR', 'base': 'BTG', 'quote': 'IDR', 'baseId': 'btg', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 0.01, 'max': undefined } } },
                            'ETH/IDR': { 'id': 'eth_idr', 'symbol': 'ETH/IDR', 'base': 'ETH', 'quote': 'IDR', 'baseId': 'eth', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 0.01, 'max': undefined } } },
                            'ETC/IDR': { 'id': 'etc_idr', 'symbol': 'ETC/IDR', 'base': 'ETC', 'quote': 'IDR', 'baseId': 'etc', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 0.1, 'max': undefined } } },
                            'IGNIS/IDR': { 'id': 'ignis_idr', 'symbol': 'IGNIS/IDR', 'base': 'IGNIS', 'quote': 'IDR', 'baseId': 'ignis', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 1, 'max': undefined } } },
                            'LTC/IDR': { 'id': 'ltc_idr', 'symbol': 'LTC/IDR', 'base': 'LTC', 'quote': 'IDR', 'baseId': 'ltc', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 0.01, 'max': undefined } } },
                            'NXT/IDR': { 'id': 'nxt_idr', 'symbol': 'NXT/IDR', 'base': 'NXT', 'quote': 'IDR', 'baseId': 'nxt', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 5, 'max': undefined } } },
                            'WAVES/IDR': { 'id': 'waves_idr', 'symbol': 'WAVES/IDR', 'base': 'WAVES', 'quote': 'IDR', 'baseId': 'waves', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 0.1, 'max': undefined } } },
                            'XRP/IDR': { 'id': 'xrp_idr', 'symbol': 'XRP/IDR', 'base': 'XRP', 'quote': 'IDR', 'baseId': 'xrp', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 10, 'max': undefined } } },
                            'XZC/IDR': { 'id': 'xzc_idr', 'symbol': 'XZC/IDR', 'base': 'XZC', 'quote': 'IDR', 'baseId': 'xzc', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 0.1, 'max': undefined } } },
                            'XLM/IDR': { 'id': 'str_idr', 'symbol': 'XLM/IDR', 'base': 'XLM', 'quote': 'IDR', 'baseId': 'str', 'quoteId': 'idr', 'limits': { 'amount': { 'min': 20, 'max': undefined } } },
                            'BTS/BTC': { 'id': 'bts_btc', 'symbol': 'BTS/BTC', 'base': 'BTS', 'quote': 'BTC', 'baseId': 'bts', 'quoteId': 'btc', 'limits': { 'amount': { 'min': 0.01, 'max': undefined } } },
                            'DASH/BTC': { 'id': 'drk_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC', 'baseId': 'drk', 'quoteId': 'btc', 'limits': { 'amount': { 'min': 0.01, 'max': undefined } } },
                            'DOGE/BTC': { 'id': 'doge_btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC', 'baseId': 'doge', 'quoteId': 'btc', 'limits': { 'amount': { 'min': 1, 'max': undefined } } },
                            'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'baseId': 'eth', 'quoteId': 'btc', 'limits': { 'amount': { 'min': 0.001, 'max': undefined } } },
                            'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'ltc', 'quoteId': 'btc', 'limits': { 'amount': { 'min': 0.01, 'max': undefined } } },
                            'NXT/BTC': { 'id': 'nxt_btc', 'symbol': 'NXT/BTC', 'base': 'NXT', 'quote': 'BTC', 'baseId': 'nxt', 'quoteId': 'btc', 'limits': { 'amount': { 'min': 0.01, 'max': undefined } } },
                            'XLM/BTC': { 'id': 'str_btc', 'symbol': 'XLM/BTC', 'base': 'XLM', 'quote': 'BTC', 'baseId': 'str', 'quoteId': 'btc', 'limits': { 'amount': { 'min': 0.01, 'max': undefined } } },
                            'XEM/BTC': { 'id': 'nem_btc', 'symbol': 'XEM/BTC', 'base': 'XEM', 'quote': 'BTC', 'baseId': 'nem', 'quoteId': 'btc', 'limits': { 'amount': { 'min': 1, 'max': undefined } } },
                            'XRP/BTC': { 'id': 'xrp_btc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'baseId': 'xrp', 'quoteId': 'btc', 'limits': { 'amount': { 'min': 0.01, 'max': undefined } } },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'maker': 0,
                                'taker': 0.003,
                            },
                        },
                    });
                };
                bitcoincoid.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balance, result, codes, i, code, currency, lowercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetInfo()];
                                case 2:
                                    response = _a.sent();
                                    balance = response['return'];
                                    result = { 'info': balance };
                                    codes = Object.keys(this.currencies);
                                    for (i = 0; i < codes.length; i++) {
                                        code = codes[i];
                                        currency = this.currencies[code];
                                        lowercase = currency['id'];
                                        account = this.account();
                                        account['free'] = this.safeFloat(balance['balance'], lowercase, 0.0);
                                        account['used'] = this.safeFloat(balance['balance_hold'], lowercase, 0.0);
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[code] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitcoincoid.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetPairDepth(this.extend({
                                            'pair': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'buy', 'sell')];
                            }
                        });
                    });
                };
                bitcoincoid.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ticker, timestamp, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetPairTicker(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['ticker'];
                                    timestamp = parseFloat(ticker['server_time']) * 1000;
                                    baseVolume = 'vol_' + market['baseId'].toLowerCase();
                                    quoteVolume = 'vol_' + market['quoteId'].toLowerCase();
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['buy']),
                                            'ask': parseFloat(ticker['sell']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker[baseVolume]),
                                            'quoteVolume': parseFloat(ticker[quoteVolume]),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bitcoincoid.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(trade['date']) * 1000;
                    return {
                        'id': trade['tid'],
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['type'],
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                bitcoincoid.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetPairTrades(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitcoincoid.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = undefined;
                    if ('type' in order)
                        side = order['type'];
                    var status = this.safeString(order, 'status', 'open');
                    if (status === 'filled') {
                        status = 'closed';
                    }
                    else if (status === 'calcelled') {
                        status = 'canceled';
                    }
                    var symbol = undefined;
                    var cost = undefined;
                    var price = this.safeFloat(order, 'price');
                    var amount = undefined;
                    var remaining = undefined;
                    var filled = undefined;
                    if (market) {
                        symbol = market['symbol'];
                        var quoteId = market['quoteId'];
                        var baseId = market['baseId'];
                        if ((market['quoteId'] === 'idr') && ('order_rp' in order))
                            quoteId = 'rp';
                        if ((market['baseId'] === 'idr') && ('remain_rp' in order))
                            baseId = 'rp';
                        cost = this.safeFloat(order, 'order_' + quoteId);
                        if (cost) {
                            amount = cost / price;
                            var remainingCost = this.safeFloat(order, 'remain_' + quoteId);
                            if (typeof remainingCost !== 'undefined') {
                                remaining = remainingCost / price;
                                filled = amount - remaining;
                            }
                        }
                        else {
                            amount = this.safeFloat(order, 'order_' + baseId);
                            cost = price * amount;
                            remaining = this.safeFloat(order, 'remain_' + baseId);
                            filled = amount - remaining;
                        }
                    }
                    var average = undefined;
                    if (filled)
                        average = cost / filled;
                    var timestamp = parseInt(order['submit_time']);
                    var fee = undefined;
                    var result = {
                        'info': order,
                        'id': order['order_id'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': 'limit',
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'average': average,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': fee,
                    };
                    return result;
                };
                bitcoincoid.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, orders, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOrder requires a symbol');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostGetOrder(this.extend({
                                            'pair': market['id'],
                                            'order_id': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = response['return'];
                                    order = this.parseOrder(this.extend({ 'id': id }, orders['order']), market);
                                    return [2, this.extend({ 'info': response }, order)];
                            }
                        });
                    });
                };
                bitcoincoid.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, rawOrders, marketIds, exchangeOrders, i, marketId, marketOrders, parsedOrders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['pair'] = market['id'];
                                    }
                                    return [4, this.privatePostOpenOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    rawOrders = response['return']['orders'];
                                    if (!rawOrders)
                                        return [2, []];
                                    if (typeof symbol !== 'undefined')
                                        return [2, this.parseOrders(rawOrders, market, since, limit)];
                                    marketIds = Object.keys(rawOrders);
                                    exchangeOrders = [];
                                    for (i = 0; i < marketIds.length; i++) {
                                        marketId = marketIds[i];
                                        marketOrders = rawOrders[marketId];
                                        market = this.markets_by_id[marketId];
                                        parsedOrders = this.parseOrders(marketOrders, market, since, limit);
                                        exchangeOrders = this.arrayConcat(exchangeOrders, parsedOrders);
                                    }
                                    return [2, exchangeOrders];
                            }
                        });
                    });
                };
                bitcoincoid.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOrders requires a symbol');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    market = undefined;
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['pair'] = market['id'];
                                    }
                                    return [4, this.privatePostOrderHistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response['return']['orders'], market, since, limit);
                                    orders = this.filterBy(orders, 'status', 'closed');
                                    if (symbol)
                                        return [2, this.filterBySymbol(orders, symbol)];
                                    return [2, orders];
                            }
                        });
                    });
                };
                bitcoincoid.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, order, currency, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type !== 'limit')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    order = {
                                        'pair': market['id'],
                                        'type': side,
                                        'price': price,
                                    };
                                    currency = market['baseId'];
                                    if (side === 'buy') {
                                        order[market['quoteId']] = amount * price;
                                    }
                                    else {
                                        order[market['baseId']] = amount;
                                    }
                                    order[currency] = amount;
                                    return [4, this.privatePostTrade(this.extend(order, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result['return']['order_id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                bitcoincoid.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var side, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof symbol === 'undefined')
                                        throw new ExchangeError(this.id + ' cancelOrder requires a symbol argument');
                                    side = this.safeValue(params, 'side');
                                    if (typeof side === 'undefined')
                                        throw new ExchangeError(this.id + ' cancelOrder requires an extra "side" param');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostCancelOrder(this.extend({
                                            'order_id': id,
                                            'pair': market['id'],
                                            'type': params['side'],
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitcoincoid.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    if (api === 'public') {
                        url += '/' + this.implodeParams(path, params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        body = this.urlencode(this.extend({
                            'method': path,
                            'nonce': this.nonce(),
                        }, params));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Key': this.apiKey,
                            'Sign': this.hmac(this.encode(body), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bitcoincoid.prototype.handleErrors = function (code, reason, url, method, headers, body, response) {
                    if (response === void 0) { response = undefined; }
                    if (typeof response === 'undefined')
                        if (body[0] === '{')
                            response = JSON.parse(body);
                    if (!('success' in response))
                        return;
                    if (response['success'] === 1) {
                        if (!('return' in response))
                            throw new ExchangeError(this.id + ': malformed response: ' + this.json(response));
                        else
                            return;
                    }
                    var message = response['error'];
                    var feedback = this.id + ' ' + this.json(response);
                    if (message === 'Insufficient balance.') {
                        throw new InsufficientFunds(feedback);
                    }
                    else if (message === 'invalid order.') {
                        throw new OrderNotFound(feedback);
                    }
                    else if (message.indexOf('Minimum price ') >= 0) {
                        throw new InvalidOrder(feedback);
                    }
                    else if (message.indexOf('Minimum order ') >= 0) {
                        throw new InvalidOrder(feedback);
                    }
                    else if (message === 'Invalid credentials. API not found or session has expired.') {
                        throw new AuthenticationError(feedback);
                    }
                    else if (message === 'Invalid credentials. Bad sign.') {
                        throw new AuthenticationError(feedback);
                    }
                    throw new ExchangeError(this.id + ': unknown error: ' + this.json(response));
                };
                return bitcoincoid;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 27: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), NotSupported = _a.NotSupported, DDoSProtection = _a.DDoSProtection, AuthenticationError = _a.AuthenticationError, ExchangeError = _a.ExchangeError, InsufficientFunds = _a.InsufficientFunds, InvalidOrder = _a.InvalidOrder, OrderNotFound = _a.OrderNotFound, InvalidNonce = _a.InvalidNonce;
            module.exports = (function (_super) {
                __extends(bitfinex, _super);
                function bitfinex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitfinex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitfinex',
                        'name': 'Bitfinex',
                        'countries': 'VG',
                        'version': 'v1',
                        'rateLimit': 1500,
                        'has': {
                            'CORS': false,
                            'createDepositAddress': true,
                            'deposit': true,
                            'fetchClosedOrders': true,
                            'fetchDepositAddress': true,
                            'fetchFees': true,
                            'fetchFundingFees': true,
                            'fetchMyTrades': true,
                            'fetchOHLCV': true,
                            'fetchOpenOrders': true,
                            'fetchOrder': true,
                            'fetchTickers': true,
                            'fetchTradingFees': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1m': '1m',
                            '5m': '5m',
                            '15m': '15m',
                            '30m': '30m',
                            '1h': '1h',
                            '3h': '3h',
                            '6h': '6h',
                            '12h': '12h',
                            '1d': '1D',
                            '1w': '7D',
                            '2w': '14D',
                            '1M': '1M',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                            'api': 'https://api.bitfinex.com',
                            'www': 'https://www.bitfinex.com',
                            'doc': [
                                'https://bitfinex.readme.io/v1/docs',
                                'https://github.com/bitfinexcom/bitfinex-api-node',
                            ],
                        },
                        'api': {
                            'v2': {
                                'get': [
                                    'candles/trade:{timeframe}:{symbol}/{section}',
                                    'candles/trade:{timeframe}:{symbol}/last',
                                    'candles/trade:{timeframe}:{symbol}/hist',
                                ],
                            },
                            'public': {
                                'get': [
                                    'book/{symbol}',
                                    'lendbook/{currency}',
                                    'lends/{currency}',
                                    'pubticker/{symbol}',
                                    'stats/{symbol}',
                                    'symbols',
                                    'symbols_details',
                                    'tickers',
                                    'today',
                                    'trades/{symbol}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'account_fees',
                                    'account_infos',
                                    'balances',
                                    'basket_manage',
                                    'credits',
                                    'deposit/new',
                                    'funding/close',
                                    'history',
                                    'history/movements',
                                    'key_info',
                                    'margin_infos',
                                    'mytrades',
                                    'mytrades_funding',
                                    'offer/cancel',
                                    'offer/new',
                                    'offer/status',
                                    'offers',
                                    'offers/hist',
                                    'order/cancel',
                                    'order/cancel/all',
                                    'order/cancel/multi',
                                    'order/cancel/replace',
                                    'order/new',
                                    'order/new/multi',
                                    'order/status',
                                    'orders',
                                    'orders/hist',
                                    'position/claim',
                                    'positions',
                                    'summary',
                                    'taken_funds',
                                    'total_taken_funds',
                                    'transfer',
                                    'unused_taken_funds',
                                    'withdraw',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': true,
                                'percentage': true,
                                'maker': 0.1 / 100,
                                'taker': 0.2 / 100,
                                'tiers': {
                                    'taker': [
                                        [0, 0.2 / 100],
                                        [500000, 0.2 / 100],
                                        [1000000, 0.2 / 100],
                                        [2500000, 0.2 / 100],
                                        [5000000, 0.2 / 100],
                                        [7500000, 0.2 / 100],
                                        [10000000, 0.18 / 100],
                                        [15000000, 0.16 / 100],
                                        [20000000, 0.14 / 100],
                                        [25000000, 0.12 / 100],
                                        [30000000, 0.1 / 100],
                                    ],
                                    'maker': [
                                        [0, 0.1 / 100],
                                        [500000, 0.08 / 100],
                                        [1000000, 0.06 / 100],
                                        [2500000, 0.04 / 100],
                                        [5000000, 0.02 / 100],
                                        [7500000, 0],
                                        [10000000, 0],
                                        [15000000, 0],
                                        [20000000, 0],
                                        [25000000, 0],
                                        [30000000, 0],
                                    ],
                                },
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'deposit': {
                                    'BTC': 0.0005,
                                    'IOTA': 0.5,
                                    'ETH': 0.01,
                                    'BCH': 0.01,
                                    'LTC': 0.1,
                                    'EOS': 0.1,
                                    'XMR': 0.04,
                                    'SAN': 0.1,
                                    'DASH': 0.01,
                                    'ETC': 0.01,
                                    'XRP': 0.02,
                                    'YYW': 0.1,
                                    'NEO': 0,
                                    'ZEC': 0.1,
                                    'BTG': 0,
                                    'OMG': 0.1,
                                    'DATA': 1,
                                    'QASH': 1,
                                    'ETP': 0.01,
                                    'QTUM': 0.01,
                                    'EDO': 0.5,
                                    'AVT': 0.5,
                                    'USDT': 0,
                                },
                                'withdraw': {
                                    'BTC': 0.0008,
                                    'IOTA': 0.5,
                                    'ETH': 0.01,
                                    'ETC': 0.01,
                                    'BCH': 0.0001,
                                    'LTC': 0.001,
                                    'EOS': 0.8609,
                                    'XMR': 0.04,
                                    'SAN': 3.2779,
                                    'DASH': 0.01,
                                    'XRP': 0.02,
                                    'YYW': 40.543,
                                    'NEO': 0,
                                    'ZEC': 0.001,
                                    'BTG': 0,
                                    'OMG': 0.5897,
                                    'DATA': 52.405,
                                    'FUN': 90.402,
                                    'GNT': 15.435,
                                    'MNA': 76.821,
                                    'BAT': 17.223,
                                    'SPK': 24.708,
                                    'QASH': 6.1629,
                                    'ETP': 0.01,
                                    'QTUM': 0.01,
                                    'EDO': 2.5238,
                                    'AVT': 3.2495,
                                    'USDT': 20.0,
                                    'ZRX': 5.6442,
                                    'TNB': 87.511,
                                    'SNT': 32.736,
                                },
                            },
                        },
                        'exceptions': {
                            'exact': {
                                'Order could not be cancelled.': OrderNotFound,
                                'No such order found.': OrderNotFound,
                                'Order price must be positive.': InvalidOrder,
                                'Could not find a key matching the given X-BFX-APIKEY.': AuthenticationError,
                                'This API key does not have permission for this action': AuthenticationError,
                                'Key price should be a decimal number, e.g. "123.456"': InvalidOrder,
                                'Key amount should be a decimal number, e.g. "123.456"': InvalidOrder,
                                'ERR_RATE_LIMIT': DDoSProtection,
                                'Nonce is too small.': InvalidNonce,
                            },
                            'broad': {
                                'Invalid order: not enough exchange balance for ': InsufficientFunds,
                                'Invalid order: minimum size for ': InvalidOrder,
                                'Invalid order': InvalidOrder,
                            },
                        },
                    });
                };
                bitfinex.prototype.commonCurrencyCode = function (currency) {
                    var currencies = {
                        'DSH': 'DASH',
                        'QTM': 'QTUM',
                        'BCC': 'CST_BCC',
                        'BCU': 'CST_BCU',
                        'IOT': 'IOTA',
                        'DAT': 'DATA',
                    };
                    return (currency in currencies) ? currencies[currency] : currency;
                };
                bitfinex.prototype.fetchFundingFees = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, fees, withdraw, ids, i, id, code, currency;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostAccountFees(params)];
                                case 2:
                                    response = _a.sent();
                                    fees = response['withdraw'];
                                    withdraw = {};
                                    ids = Object.keys(fees);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        code = id;
                                        if (id in this.currencies_by_id) {
                                            currency = this.currencies_by_id[id];
                                            code = currency['code'];
                                        }
                                        withdraw[code] = this.safeFloat(fees, id);
                                    }
                                    return [2, {
                                            'info': response,
                                            'withdraw': withdraw,
                                            'deposit': withdraw,
                                        }];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchTradingFees = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostSummary(params)];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'maker': this.safeFloat(response, 'maker_fee'),
                                            'taker': this.safeFloat(response, 'taker_fee'),
                                        }];
                            }
                        });
                    });
                };
                bitfinex.prototype.loadFees = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new NotSupported(this.id + ' loadFees() not implemented yet');
                        });
                    });
                };
                bitfinex.prototype.fetchFees = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var fundingFees, tradingFees;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchFundingFees()];
                                case 1:
                                    fundingFees = _a.sent();
                                    return [4, this.fetchTradingFees()];
                                case 2:
                                    tradingFees = _a.sent();
                                    return [2, this.deepExtend(fundingFees, tradingFees)];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, baseId, quoteId, base, quote, symbol, precision, limits;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetSymbolsDetails()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['pair'].toUpperCase();
                                        baseId = id.slice(0, 3);
                                        quoteId = id.slice(3, 6);
                                        base = this.commonCurrencyCode(baseId);
                                        quote = this.commonCurrencyCode(quoteId);
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'price': market['price_precision'],
                                            'amount': market['price_precision'],
                                        };
                                        limits = {
                                            'amount': {
                                                'min': parseFloat(market['minimum_order_size']),
                                                'max': parseFloat(market['maximum_order_size']),
                                            },
                                            'price': {
                                                'min': Math.pow(10, -precision['price']),
                                                'max': Math.pow(10, precision['price']),
                                            },
                                        };
                                        limits['cost'] = {
                                            'min': limits['amount']['min'] * limits['price']['min'],
                                            'max': undefined,
                                        };
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'active': true,
                                            'precision': precision,
                                            'limits': limits,
                                            'lot': Math.pow(10, -precision['amount']),
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balanceType, balances, result, i, balance, currency, uppercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    balanceType = this.safeString(params, 'type', 'exchange');
                                    return [4, this.privatePostBalances()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (i = 0; i < balances.length; i++) {
                                        balance = balances[i];
                                        if (balance['type'] === balanceType) {
                                            currency = balance['currency'];
                                            uppercase = currency.toUpperCase();
                                            uppercase = this.commonCurrencyCode(uppercase);
                                            account = this.account();
                                            account['free'] = parseFloat(balance['available']);
                                            account['total'] = parseFloat(balance['amount']);
                                            account['used'] = account['total'] - account['free'];
                                            result[uppercase] = account;
                                        }
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'symbol': this.marketId(symbol),
                                    };
                                    if (typeof limit !== 'undefined') {
                                        request['limit_bids'] = limit;
                                        request['limit_asks'] = limit;
                                    }
                                    return [4, this.publicGetBookSymbol(this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price', 'amount')];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result, i, ticker, id, market, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickers(params)];
                                case 2:
                                    tickers = _a.sent();
                                    result = {};
                                    for (i = 0; i < tickers.length; i++) {
                                        ticker = tickers[i];
                                        if ('pair' in ticker) {
                                            id = ticker['pair'];
                                            if (id in this.markets_by_id) {
                                                market = this.markets_by_id[id];
                                                symbol = market['symbol'];
                                                result[symbol] = this.parseTicker(ticker, market);
                                            }
                                            else {
                                                throw new ExchangeError(this.id + ' fetchTickers() failed to recognize symbol ' + id + ' ' + this.json(ticker));
                                            }
                                        }
                                        else {
                                            throw new ExchangeError(this.id + ' fetchTickers() response not recognized ' + this.json(tickers));
                                        }
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetPubtickerSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                bitfinex.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = parseFloat(ticker['timestamp']) * 1000;
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    else if ('pair' in ticker) {
                        var id = ticker['pair'];
                        if (id in this.markets_by_id) {
                            market = this.markets_by_id[id];
                            symbol = market['symbol'];
                        }
                        else {
                            throw new ExchangeError(this.id + ' unrecognized ticker symbol ' + id + ' ' + this.json(ticker));
                        }
                    }
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['bid']),
                        'ask': parseFloat(ticker['ask']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last_price']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': parseFloat(ticker['mid']),
                        'baseVolume': parseFloat(ticker['volume']),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                bitfinex.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(parseFloat(trade['timestamp'])) * 1000;
                    var side = trade['type'].toLowerCase();
                    var orderId = this.safeString(trade, 'order_id');
                    var price = parseFloat(trade['price']);
                    var amount = parseFloat(trade['amount']);
                    var cost = price * amount;
                    var fee = undefined;
                    if ('fee_amount' in trade) {
                        var feeCost = this.safeFloat(trade, 'fee_amount');
                        var feeCurrency = this.safeString(trade, 'fee_currency');
                        if (feeCurrency in this.currencies_by_id)
                            feeCurrency = this.currencies_by_id[feeCurrency]['code'];
                        fee = {
                            'cost': feeCost,
                            'currency': feeCurrency,
                        };
                    }
                    return {
                        'id': trade['tid'].toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'order': orderId,
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'fee': fee,
                    };
                };
                bitfinex.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 50; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'limit_trades': limit,
                                    };
                                    if (typeof since !== 'undefined')
                                        request['timestamp'] = parseInt(since / 1000);
                                    return [4, this.publicGetTradesSymbol(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = { 'symbol': market['id'] };
                                    if (typeof limit !== 'undefined')
                                        request['limit_trades'] = limit;
                                    if (typeof since !== 'undefined')
                                        request['timestamp'] = parseInt(since / 1000);
                                    return [4, this.privatePostMytrades(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitfinex.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderType, order, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    orderType = type;
                                    if ((type === 'limit') || (type === 'market'))
                                        orderType = 'exchange ' + type;
                                    order = {
                                        'symbol': this.marketId(symbol),
                                        'amount': amount.toString(),
                                        'side': side,
                                        'type': orderType,
                                        'ocoorder': false,
                                        'buy_price_oco': 0,
                                        'sell_price_oco': 0,
                                    };
                                    if (type === 'market') {
                                        order['price'] = this.nonce().toString();
                                    }
                                    else {
                                        order['price'] = price.toString();
                                    }
                                    return [4, this.privatePostOrderNew(this.extend(order, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, this.parseOrder(result)];
                            }
                        });
                    });
                };
                bitfinex.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrderCancel({ 'order_id': parseInt(id) })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitfinex.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = order['side'];
                    var open = order['is_live'];
                    var canceled = order['is_cancelled'];
                    var status = undefined;
                    if (open) {
                        status = 'open';
                    }
                    else if (canceled) {
                        status = 'canceled';
                    }
                    else {
                        status = 'closed';
                    }
                    var symbol = undefined;
                    if (!market) {
                        var exchange_1 = order['symbol'].toUpperCase();
                        if (exchange_1 in this.markets_by_id) {
                            market = this.markets_by_id[exchange_1];
                        }
                    }
                    if (market)
                        symbol = market['symbol'];
                    var orderType = order['type'];
                    var exchange = orderType.indexOf('exchange ') >= 0;
                    if (exchange) {
                        var parts = order['type'].split(' ');
                        orderType = parts[1];
                    }
                    var timestamp = parseInt(parseFloat(order['timestamp']) * 1000);
                    var result = {
                        'info': order,
                        'id': order['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': orderType,
                        'side': side,
                        'price': this.safeFloat(order, 'price'),
                        'average': this.safeFloat(order, 'avg_execution_price'),
                        'amount': this.safeFloat(order, 'original_amount'),
                        'remaining': this.safeFloat(order, 'remaining_amount'),
                        'filled': this.safeFloat(order, 'executed_amount'),
                        'status': status,
                        'fee': undefined,
                    };
                    return result;
                };
                bitfinex.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrders(params)];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response, undefined, since, limit);
                                    if (symbol)
                                        orders = this.filterBy(orders, 'symbol', symbol);
                                    return [2, orders];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.privatePostOrdersHist(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response, undefined, since, limit);
                                    if (typeof symbol !== 'undefined')
                                        orders = this.filterBy(orders, 'symbol', symbol);
                                    orders = this.filterBy(orders, 'status', 'closed');
                                    return [2, orders];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrderStatus(this.extend({
                                            'order_id': parseInt(id),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response)];
                            }
                        });
                    });
                };
                bitfinex.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv[0],
                        ohlcv[1],
                        ohlcv[3],
                        ohlcv[4],
                        ohlcv[2],
                        ohlcv[5],
                    ];
                };
                bitfinex.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 100; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, v2id, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    v2id = 't' + market['id'];
                                    request = {
                                        'symbol': v2id,
                                        'timeframe': this.timeframes[timeframe],
                                        'sort': 1,
                                        'limit': limit,
                                    };
                                    if (typeof since !== 'undefined')
                                        request['start'] = since;
                                    request = this.extend(request, params);
                                    return [4, this.v2GetCandlesTradeTimeframeSymbolHist(request)];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                bitfinex.prototype.getCurrencyName = function (currency) {
                    var names = {
                        'BTC': 'bitcoin',
                        'LTC': 'litecoin',
                        'ETH': 'ethereum',
                        'ETC': 'ethereumc',
                        'OMNI': 'mastercoin',
                        'ZEC': 'zcash',
                        'XMR': 'monero',
                        'USD': 'wire',
                        'DASH': 'dash',
                        'XRP': 'ripple',
                        'EOS': 'eos',
                        'BCH': 'bcash',
                        'USDT': 'tetheruso',
                        'NEO': 'neo',
                        'AVT': 'aventus',
                        'QTUM': 'qtum',
                        'EDO': 'eidoo',
                    };
                    if (currency in names)
                        return names[currency];
                    throw new NotSupported(this.id + ' ' + currency + ' not supported for withdrawal');
                };
                bitfinex.prototype.createDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchDepositAddress(currency, this.extend({
                                        'renew': 1,
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    address = this.safeString(response, 'address');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'status': 'ok',
                                            'info': response['info'],
                                        }];
                            }
                        });
                    });
                };
                bitfinex.prototype.fetchDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var name, request, response, address, tag;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    name = this.getCurrencyName(currency);
                                    request = {
                                        'method': name,
                                        'wallet_name': 'exchange',
                                        'renew': 0,
                                    };
                                    return [4, this.privatePostDepositNew(this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    address = response['address'];
                                    tag = undefined;
                                    if ('address_pool' in response) {
                                        tag = address;
                                        address = response['address_pool'];
                                    }
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'tag': tag,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                bitfinex.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var name, request, responses, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    name = this.getCurrencyName(currency);
                                    request = {
                                        'withdraw_type': name,
                                        'walletselected': 'exchange',
                                        'amount': amount.toString(),
                                        'address': address,
                                    };
                                    if (tag)
                                        request['payment_id'] = tag;
                                    return [4, this.privatePostWithdraw(this.extend(request, params))];
                                case 1:
                                    responses = _a.sent();
                                    response = responses[0];
                                    return [2, {
                                            'info': response,
                                            'id': response['withdrawal_id'],
                                        }];
                            }
                        });
                    });
                };
                bitfinex.prototype.nonce = function () {
                    return this.milliseconds();
                };
                bitfinex.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var request = '/' + this.implodeParams(path, params);
                    if (api === 'v2') {
                        request = '/' + api + request;
                    }
                    else {
                        request = '/' + this.version + request;
                    }
                    var query = this.omit(params, this.extractParams(path));
                    var url = this.urls['api'] + request;
                    if ((api === 'public') || (path.indexOf('/hist') >= 0)) {
                        if (Object.keys(query).length) {
                            var suffix = '?' + this.urlencode(query);
                            url += suffix;
                            request += suffix;
                        }
                    }
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        query = this.extend({
                            'nonce': nonce.toString(),
                            'request': request,
                        }, query);
                        query = this.json(query);
                        query = this.encode(query);
                        var payload = this.stringToBase64(query);
                        var secret = this.encode(this.secret);
                        var signature = this.hmac(payload, secret, 'sha384');
                        headers = {
                            'X-BFX-APIKEY': this.apiKey,
                            'X-BFX-PAYLOAD': this.decode(payload),
                            'X-BFX-SIGNATURE': signature,
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bitfinex.prototype.findBroadlyMatchedKey = function (map, broadString) {
                    var partialKeys = Object.keys(map);
                    for (var i = 0; i < partialKeys.length; i++) {
                        var partialKey = partialKeys[i];
                        if (broadString.indexOf(partialKey) >= 0)
                            return partialKey;
                    }
                    return undefined;
                };
                bitfinex.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (body.length < 2)
                        return;
                    if (code >= 400) {
                        if (body[0] === '{') {
                            var response = JSON.parse(body);
                            var feedback = this.id + ' ' + this.json(response);
                            var message = undefined;
                            if ('message' in response)
                                message = response['message'];
                            else if ('error' in response)
                                message = response['error'];
                            else
                                throw new ExchangeError(feedback);
                            var exact = this.exceptions['exact'];
                            if (message in exact)
                                throw new exact[message](feedback);
                            var broad = this.exceptions['broad'];
                            var broadKey = this.findBroadlyMatchedKey(broad, message);
                            if (typeof broadKey !== 'undefined')
                                throw new broad[broadKey](feedback);
                            throw new ExchangeError(feedback);
                        }
                    }
                };
                return bitfinex;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 28: [function (require, module, exports) {
            'use strict';
            var bitfinex = require('./bitfinex.js');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, NotSupported = _a.NotSupported, InsufficientFunds = _a.InsufficientFunds;
            module.exports = (function (_super) {
                __extends(bitfinex2, _super);
                function bitfinex2() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitfinex2.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitfinex2',
                        'name': 'Bitfinex v2',
                        'countries': 'VG',
                        'version': 'v2',
                        'has': {
                            'CORS': true,
                            'createOrder': false,
                            'createMarketOrder': false,
                            'createLimitOrder': false,
                            'editOrder': false,
                            'fetchMyTrades': false,
                            'fetchOHLCV': true,
                            'fetchTickers': true,
                            'fetchOrder': true,
                            'fetchOpenOrders': false,
                            'fetchClosedOrders': false,
                            'withdraw': true,
                            'deposit': false,
                        },
                        'timeframes': {
                            '1m': '1m',
                            '5m': '5m',
                            '15m': '15m',
                            '30m': '30m',
                            '1h': '1h',
                            '3h': '3h',
                            '6h': '6h',
                            '12h': '12h',
                            '1d': '1D',
                            '1w': '7D',
                            '2w': '14D',
                            '1M': '1M',
                        },
                        'rateLimit': 1500,
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                            'api': 'https://api.bitfinex.com',
                            'www': 'https://www.bitfinex.com',
                            'doc': [
                                'https://bitfinex.readme.io/v2/docs',
                                'https://github.com/bitfinexcom/bitfinex-api-node',
                            ],
                            'fees': 'https://www.bitfinex.com/fees',
                        },
                        'api': {
                            'v1': {
                                'get': [
                                    'symbols',
                                    'symbols_details',
                                ],
                            },
                            'public': {
                                'get': [
                                    'platform/status',
                                    'tickers',
                                    'ticker/{symbol}',
                                    'trades/{symbol}/hist',
                                    'book/{symbol}/{precision}',
                                    'book/{symbol}/P0',
                                    'book/{symbol}/P1',
                                    'book/{symbol}/P2',
                                    'book/{symbol}/P3',
                                    'book/{symbol}/R0',
                                    'stats1/{key}:{size}:{symbol}/{side}/{section}',
                                    'stats1/{key}:{size}:{symbol}/long/last',
                                    'stats1/{key}:{size}:{symbol}/long/hist',
                                    'stats1/{key}:{size}:{symbol}/short/last',
                                    'stats1/{key}:{size}:{symbol}/short/hist',
                                    'candles/trade:{timeframe}:{symbol}/{section}',
                                    'candles/trade:{timeframe}:{symbol}/last',
                                    'candles/trade:{timeframe}:{symbol}/hist',
                                ],
                                'post': [
                                    'calc/trade/avg',
                                ],
                            },
                            'private': {
                                'post': [
                                    'auth/r/wallets',
                                    'auth/r/orders/{symbol}',
                                    'auth/r/orders/{symbol}/new',
                                    'auth/r/orders/{symbol}/hist',
                                    'auth/r/order/{symbol}:{id}/trades',
                                    'auth/r/trades/{symbol}/hist',
                                    'auth/r/positions',
                                    'auth/r/funding/offers/{symbol}',
                                    'auth/r/funding/offers/{symbol}/hist',
                                    'auth/r/funding/loans/{symbol}',
                                    'auth/r/funding/loans/{symbol}/hist',
                                    'auth/r/funding/credits/{symbol}',
                                    'auth/r/funding/credits/{symbol}/hist',
                                    'auth/r/funding/trades/{symbol}/hist',
                                    'auth/r/info/margin/{key}',
                                    'auth/r/info/funding/{key}',
                                    'auth/r/movements/{currency}/hist',
                                    'auth/r/stats/perf:{timeframe}/hist',
                                    'auth/r/alerts',
                                    'auth/w/alert/set',
                                    'auth/w/alert/{type}:{symbol}:{price}/del',
                                    'auth/calc/order/avail',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.1 / 100,
                                'taker': 0.2 / 100,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.0005,
                                    'BCH': 0.0005,
                                    'ETH': 0.01,
                                    'EOS': 0.1,
                                    'LTC': 0.001,
                                    'OMG': 0.1,
                                    'IOT': 0.0,
                                    'NEO': 0.0,
                                    'ETC': 0.01,
                                    'XRP': 0.02,
                                    'ETP': 0.01,
                                    'ZEC': 0.001,
                                    'BTG': 0.0,
                                    'DASH': 0.01,
                                    'XMR': 0.04,
                                    'QTM': 0.01,
                                    'EDO': 0.5,
                                    'DAT': 1.0,
                                    'AVT': 0.5,
                                    'SAN': 0.1,
                                    'USDT': 5.0,
                                    'SPK': 9.2784,
                                    'BAT': 9.0883,
                                    'GNT': 8.2881,
                                    'SNT': 14.303,
                                    'QASH': 3.2428,
                                    'YYW': 18.055,
                                },
                            },
                        },
                    });
                };
                bitfinex2.prototype.commonCurrencyCode = function (currency) {
                    var currencies = {
                        'DSH': 'DASH',
                        'QTM': 'QTUM',
                        'IOT': 'IOTA',
                        'DAT': 'DATA',
                    };
                    return (currency in currencies) ? currencies[currency] : currency;
                };
                bitfinex2.prototype.isFiat = function (code) {
                    var fiat = {
                        'USD': 'USD',
                        'EUR': 'EUR',
                    };
                    return (code in fiat);
                };
                bitfinex2.prototype.getCurrencyId = function (code) {
                    var isFiat = this.isFiat(code);
                    var prefix = isFiat ? 'f' : 't';
                    return prefix + code;
                };
                bitfinex2.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, baseId, quoteId, base, quote, symbol, precision, limits;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.v1GetSymbolsDetails()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['pair'].toUpperCase();
                                        baseId = id.slice(0, 3);
                                        quoteId = id.slice(3, 6);
                                        base = this.commonCurrencyCode(baseId);
                                        quote = this.commonCurrencyCode(quoteId);
                                        symbol = base + '/' + quote;
                                        id = 't' + id;
                                        baseId = this.getCurrencyId(baseId);
                                        quoteId = this.getCurrencyId(quoteId);
                                        precision = {
                                            'price': market['price_precision'],
                                            'amount': market['price_precision'],
                                        };
                                        limits = {
                                            'amount': {
                                                'min': parseFloat(market['minimum_order_size']),
                                                'max': parseFloat(market['maximum_order_size']),
                                            },
                                            'price': {
                                                'min': Math.pow(10, -precision['price']),
                                                'max': Math.pow(10, precision['price']),
                                            },
                                        };
                                        limits['cost'] = {
                                            'min': limits['amount']['min'] * limits['price']['min'],
                                            'max': undefined,
                                        };
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'active': true,
                                            'precision': precision,
                                            'limits': limits,
                                            'lot': Math.pow(10, -precision['amount']),
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitfinex2.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balanceType, result, b, balance, accountType, currency, total, available, uppercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostAuthRWallets()];
                                case 2:
                                    response = _a.sent();
                                    balanceType = this.safeString(params, 'type', 'exchange');
                                    result = { 'info': response };
                                    for (b = 0; b < response.length; b++) {
                                        balance = response[b];
                                        accountType = balance[0];
                                        currency = balance[1];
                                        total = balance[2];
                                        available = balance[4];
                                        if (accountType === balanceType) {
                                            if (currency[0] === 't')
                                                currency = currency.slice(1);
                                            uppercase = currency.toUpperCase();
                                            uppercase = this.commonCurrencyCode(uppercase);
                                            account = this.account();
                                            account['free'] = available;
                                            account['total'] = total;
                                            if (account['free'])
                                                account['used'] = account['total'] - account['free'];
                                            result[uppercase] = account;
                                        }
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitfinex2.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp, result, i, order, price, amount, side;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetBookSymbolPrecision(this.extend({
                                            'symbol': this.marketId(symbol),
                                            'precision': 'R0',
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = this.milliseconds();
                                    result = {
                                        'bids': [],
                                        'asks': [],
                                        'timestamp': timestamp,
                                        'datetime': this.iso8601(timestamp),
                                    };
                                    for (i = 0; i < orderbook.length; i++) {
                                        order = orderbook[i];
                                        price = order[1];
                                        amount = order[2];
                                        side = (amount > 0) ? 'bids' : 'asks';
                                        amount = Math.abs(amount);
                                        result[side].push([price, amount]);
                                    }
                                    result['bids'] = this.sortBy(result['bids'], 0, true);
                                    result['asks'] = this.sortBy(result['asks'], 0);
                                    return [2, result];
                            }
                        });
                    });
                };
                bitfinex2.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var length = ticker.length;
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': ticker[length - 2],
                        'low': ticker[length - 1],
                        'bid': ticker[length - 10],
                        'ask': ticker[length - 8],
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': ticker[length - 4],
                        'change': ticker[length - 6],
                        'percentage': ticker[length - 5],
                        'average': undefined,
                        'baseVolume': ticker[length - 3],
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                bitfinex2.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result, i, ticker, id, market, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickers(this.extend({
                                            'symbols': this.ids.join(','),
                                        }, params))];
                                case 2:
                                    tickers = _a.sent();
                                    result = {};
                                    for (i = 0; i < tickers.length; i++) {
                                        ticker = tickers[i];
                                        id = ticker[0];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitfinex2.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.markets[symbol];
                                    return [4, this.publicGetTickerSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                bitfinex2.prototype.parseTrade = function (trade, market) {
                    var _a = __read(trade, 4), id = _a[0], timestamp = _a[1], amount = _a[2], price = _a[3];
                    var side = (amount < 0) ? 'sell' : 'buy';
                    if (amount < 0) {
                        amount = -amount;
                    }
                    return {
                        'id': id.toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': side,
                        'price': price,
                        'amount': amount,
                    };
                };
                bitfinex2.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 120; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'sort': 1,
                                        'limit': limit,
                                    };
                                    if (typeof since !== 'undefined')
                                        request['start'] = since;
                                    return [4, this.publicGetTradesSymbolHist(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    trades = this.sortBy(response, 1);
                                    return [2, this.parseTrades(trades, market, undefined, limit)];
                            }
                        });
                    });
                };
                bitfinex2.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 100; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'timeframe': this.timeframes[timeframe],
                                        'sort': 1,
                                        'limit': limit,
                                    };
                                    if (typeof since !== 'undefined')
                                        request['start'] = since;
                                    request = this.extend(request, params);
                                    return [4, this.publicGetCandlesTradeTimeframeSymbolHist(request)];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                bitfinex2.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new NotSupported(this.id + ' createOrder not implemented yet');
                        });
                    });
                };
                bitfinex2.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    throw new NotSupported(this.id + ' cancelOrder not implemented yet');
                };
                bitfinex2.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new NotSupported(this.id + ' fetchOrder not implemented yet');
                        });
                    });
                };
                bitfinex2.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new NotSupported(this.id + ' withdraw not implemented yet');
                        });
                    });
                };
                bitfinex2.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 25; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'limit': limit,
                                        'end': this.seconds(),
                                    };
                                    if (typeof since !== 'undefined')
                                        request['start'] = parseInt(since / 1000);
                                    return [4, this.privatePostAuthRTradesSymbolHist(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                bitfinex2.prototype.nonce = function () {
                    return this.milliseconds();
                };
                bitfinex2.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var request = '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'v1')
                        request = api + request;
                    else
                        request = this.version + request;
                    var url = this.urls['api'] + '/' + request;
                    if (api === 'public') {
                        if (Object.keys(query).length) {
                            url += '?' + this.urlencode(query);
                        }
                    }
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        body = this.json(query);
                        var auth = '/api' + '/' + request + nonce + body;
                        var signature = this.hmac(this.encode(auth), this.encode(this.secret), 'sha384');
                        headers = {
                            'bfx-nonce': nonce,
                            'bfx-apikey': this.apiKey,
                            'bfx-signature': signature,
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bitfinex2.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (response) {
                                        if ('message' in response) {
                                            if (response['message'].indexOf('not enough exchange balance') >= 0)
                                                throw new InsufficientFunds(this.id + ' ' + this.json(response));
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                        }
                                        return [2, response];
                                    }
                                    else if (response === '') {
                                        throw new ExchangeError(this.id + ' returned empty response');
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return bitfinex2;
            }(bitfinex));
        }, { "./base/errors": 10, "./bitfinex.js": 27 }], 29: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, OrderNotFound = _a.OrderNotFound;
            module.exports = (function (_super) {
                __extends(bitflyer, _super);
                function bitflyer() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitflyer.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitflyer',
                        'name': 'bitFlyer',
                        'countries': 'JP',
                        'version': 'v1',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': false,
                            'withdraw': true,
                            'fetchOrders': true,
                            'fetchOrder': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg',
                            'api': 'https://api.bitflyer.jp',
                            'www': 'https://bitflyer.jp',
                            'doc': 'https://bitflyer.jp/API',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'getmarkets/usa',
                                    'getmarkets/eu',
                                    'getmarkets',
                                    'getboard',
                                    'getticker',
                                    'getexecutions',
                                    'gethealth',
                                    'getchats',
                                ],
                            },
                            'private': {
                                'get': [
                                    'getpermissions',
                                    'getbalance',
                                    'getcollateral',
                                    'getcollateralaccounts',
                                    'getaddresses',
                                    'getcoinins',
                                    'getcoinouts',
                                    'getbankaccounts',
                                    'getdeposits',
                                    'getwithdrawals',
                                    'getchildorders',
                                    'getparentorders',
                                    'getparentorder',
                                    'getexecutions',
                                    'getpositions',
                                    'gettradingcommission',
                                ],
                                'post': [
                                    'sendcoin',
                                    'withdraw',
                                    'sendchildorder',
                                    'cancelchildorder',
                                    'sendparentorder',
                                    'cancelparentorder',
                                    'cancelallchildorders',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.25 / 100,
                                'taker': 0.25 / 100,
                            },
                        },
                    });
                };
                bitflyer.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var jp_markets, us_markets, eu_markets, markets, result, p, market, id, currencies, base, quote, symbol, numCurrencies;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetGetmarkets()];
                                case 1:
                                    jp_markets = _a.sent();
                                    return [4, this.publicGetGetmarketsUsa()];
                                case 2:
                                    us_markets = _a.sent();
                                    return [4, this.publicGetGetmarketsEu()];
                                case 3:
                                    eu_markets = _a.sent();
                                    markets = this.arrayConcat(jp_markets, us_markets);
                                    markets = this.arrayConcat(markets, eu_markets);
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['product_code'];
                                        currencies = id.split('_');
                                        base = undefined;
                                        quote = undefined;
                                        symbol = id;
                                        numCurrencies = currencies.length;
                                        if (numCurrencies === 1) {
                                            base = symbol.slice(0, 3);
                                            quote = symbol.slice(3, 6);
                                        }
                                        else if (numCurrencies === 2) {
                                            base = currencies[0];
                                            quote = currencies[1];
                                            symbol = base + '/' + quote;
                                        }
                                        else {
                                            base = currencies[1];
                                            quote = currencies[2];
                                        }
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitflyer.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, b, account, currency, result, currencies, i, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetGetbalance()];
                                case 2:
                                    response = _a.sent();
                                    balances = {};
                                    for (b = 0; b < response.length; b++) {
                                        account = response[b];
                                        currency = account['currency_code'];
                                        balances[currency] = account;
                                    }
                                    result = { 'info': response };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        account = this.account();
                                        if (currency in balances) {
                                            account['total'] = balances[currency]['amount'];
                                            account['free'] = balances[currency]['available'];
                                            account['used'] = account['total'] - account['free'];
                                        }
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitflyer.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetGetboard(this.extend({
                                            'product_code': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price', 'size')];
                            }
                        });
                    });
                };
                bitflyer.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetGetticker(this.extend({
                                            'product_code': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    timestamp = this.parse8601(ticker['timestamp']);
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': undefined,
                                            'low': undefined,
                                            'bid': parseFloat(ticker['best_bid']),
                                            'ask': parseFloat(ticker['best_ask']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['ltp']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['volume_by_product']),
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bitflyer.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var side = undefined;
                    var order = undefined;
                    if ('side' in trade)
                        if (trade['side']) {
                            side = trade['side'].toLowerCase();
                            var id = side + '_child_order_acceptance_id';
                            if (id in trade)
                                order = trade[id];
                        }
                    var timestamp = this.parse8601(trade['exec_date']);
                    return {
                        'id': trade['id'].toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'order': order,
                        'type': undefined,
                        'side': side,
                        'price': trade['price'],
                        'amount': trade['size'],
                    };
                };
                bitflyer.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetGetexecutions(this.extend({
                                            'product_code': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitflyer.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'product_code': this.marketId(symbol),
                                        'child_order_type': type.toUpperCase(),
                                        'side': side.toUpperCase(),
                                        'price': price,
                                        'size': amount,
                                    };
                                    return [4, this.privatePostSendchildorder(this.extend(order, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result['child_order_acceptance_id'],
                                        }];
                            }
                        });
                    });
                };
                bitflyer.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof symbol === 'undefined')
                                        throw new ExchangeError(this.id + ' cancelOrder() requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCancelchildorder(this.extend({
                                            'product_code': this.marketId(symbol),
                                            'child_order_acceptance_id': id,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitflyer.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        'ACTIVE': 'open',
                        'COMPLETED': 'closed',
                        'CANCELED': 'canceled',
                        'EXPIRED': 'canceled',
                        'REJECTED': 'canceled',
                    };
                    if (status in statuses)
                        return statuses[status];
                    return status.toLowerCase();
                };
                bitflyer.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(order['child_order_date']);
                    var amount = this.safeFloat(order, 'size');
                    var remaining = this.safeFloat(order, 'outstanding_size');
                    var filled = this.safeFloat(order, 'executed_size');
                    var price = this.safeFloat(order, 'price');
                    var cost = price * filled;
                    var status = this.parseOrderStatus(order['child_order_state']);
                    var type = order['child_order_type'].toLowerCase();
                    var side = order['side'].toLowerCase();
                    var symbol = undefined;
                    if (typeof market === 'undefined') {
                        var marketId = this.safeString(order, 'product_code');
                        if (typeof marketId !== 'undefined') {
                            if (marketId in this.markets_by_id)
                                market = this.markets_by_id[marketId];
                        }
                    }
                    if (typeof market !== 'undefined')
                        symbol = market['symbol'];
                    var fee = undefined;
                    var feeCost = this.safeFloat(order, 'total_commission');
                    if (typeof feeCost !== 'undefined') {
                        fee = {
                            'cost': feeCost,
                            'currency': undefined,
                            'rate': undefined,
                        };
                    }
                    return {
                        'id': order['child_order_acceptance_id'],
                        'info': order,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': status,
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'fee': fee,
                    };
                };
                bitflyer.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 100; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof symbol === 'undefined')
                                        throw new ExchangeError(this.id + ' fetchOrders() requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'product_code': this.marketId(symbol),
                                        'count': limit,
                                    };
                                    return [4, this.privateGetGetchildorders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response, symbol, since, limit);
                                    if (symbol)
                                        orders = this.filterBy(orders, 'symbol', symbol);
                                    return [2, orders];
                            }
                        });
                    });
                };
                bitflyer.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders, ordersById;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof symbol === 'undefined')
                                        throw new ExchangeError(this.id + ' fetchOrder() requires a symbol argument');
                                    return [4, this.fetchOrders(symbol)];
                                case 1:
                                    orders = _a.sent();
                                    ordersById = this.indexBy(orders, 'id');
                                    if (id in ordersById)
                                        return [2, ordersById[id]];
                                    throw new OrderNotFound(this.id + ' No order found with id ' + id);
                            }
                        });
                    });
                };
                bitflyer.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostWithdraw(this.extend({
                                            'currency_code': currency,
                                            'amount': amount,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['message_id'],
                                        }];
                            }
                        });
                    });
                };
                bitflyer.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var request = '/' + this.version + '/';
                    if (api === 'private')
                        request += 'me/';
                    request += path;
                    if (method === 'GET') {
                        if (Object.keys(params).length)
                            request += '?' + this.urlencode(params);
                    }
                    var url = this.urls['api'] + request;
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var auth = [nonce, method, request].join('');
                        if (Object.keys(params).length) {
                            body = this.json(params);
                            if (method !== 'GET')
                                auth += body;
                        }
                        headers = {
                            'ACCESS-KEY': this.apiKey,
                            'ACCESS-TIMESTAMP': nonce,
                            'ACCESS-SIGN': this.hmac(this.encode(auth), this.encode(this.secret)),
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return bitflyer;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 30: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(bithumb, _super);
                function bithumb() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bithumb.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bithumb',
                        'name': 'Bithumb',
                        'countries': 'KR',
                        'rateLimit': 500,
                        'has': {
                            'CORS': true,
                            'fetchTickers': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg',
                            'api': {
                                'public': 'https://api.bithumb.com/public',
                                'private': 'https://api.bithumb.com',
                            },
                            'www': 'https://www.bithumb.com',
                            'doc': 'https://www.bithumb.com/u1/US127',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'ticker/{currency}',
                                    'ticker/all',
                                    'orderbook/{currency}',
                                    'orderbook/all',
                                    'recent_transactions/{currency}',
                                    'recent_transactions/all',
                                ],
                            },
                            'private': {
                                'post': [
                                    'info/account',
                                    'info/balance',
                                    'info/wallet_address',
                                    'info/ticker',
                                    'info/orders',
                                    'info/user_transactions',
                                    'trade/place',
                                    'info/order_detail',
                                    'trade/cancel',
                                    'trade/btc_withdrawal',
                                    'trade/krw_deposit',
                                    'trade/krw_withdrawal',
                                    'trade/market_buy',
                                    'trade/market_sell',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.15 / 100,
                                'taker': 0.15 / 100,
                            },
                        },
                    });
                };
                bithumb.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, currencies, result, i, id, market, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTickerAll()];
                                case 1:
                                    markets = _a.sent();
                                    currencies = Object.keys(markets['data']);
                                    result = [];
                                    for (i = 0; i < currencies.length; i++) {
                                        id = currencies[i];
                                        if (id !== 'date') {
                                            market = markets['data'][id];
                                            base = id;
                                            quote = 'KRW';
                                            symbol = id + '/' + quote;
                                            result.push({
                                                'id': id,
                                                'symbol': symbol,
                                                'base': base,
                                                'quote': quote,
                                                'info': market,
                                                'lot': undefined,
                                                'active': true,
                                                'precision': {
                                                    'amount': undefined,
                                                    'price': undefined,
                                                },
                                                'limits': {
                                                    'amount': {
                                                        'min': undefined,
                                                        'max': undefined,
                                                    },
                                                    'price': {
                                                        'min': undefined,
                                                        'max': undefined,
                                                    },
                                                    'cost': {
                                                        'min': undefined,
                                                        'max': undefined,
                                                    },
                                                },
                                            });
                                        }
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bithumb.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, balances, currencies, i, currency, account, lowercase;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostInfoBalance(this.extend({
                                            'currency': 'ALL',
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    balances = response['data'];
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        account = this.account();
                                        lowercase = currency.toLowerCase();
                                        account['total'] = this.safeFloat(balances, 'total_' + lowercase);
                                        account['used'] = this.safeFloat(balances, 'in_use_' + lowercase);
                                        account['free'] = this.safeFloat(balances, 'available_' + lowercase);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bithumb.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'currency': market['base'],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['count'] = limit;
                                    return [4, this.publicGetOrderbookCurrency(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['data'];
                                    timestamp = parseInt(orderbook['timestamp']);
                                    return [2, this.parseOrderBook(orderbook, timestamp, 'bids', 'asks', 'price', 'quantity')];
                            }
                        });
                    });
                };
                bithumb.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = parseInt(ticker['date']);
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var open = this.safeFloat(ticker, 'opening_price');
                    var close = this.safeFloat(ticker, 'closing_price');
                    var change = close - open;
                    var vwap = this.safeFloat(ticker, 'average_price');
                    var baseVolume = this.safeFloat(ticker, 'volume_1day');
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'max_price'),
                        'low': this.safeFloat(ticker, 'min_price'),
                        'bid': this.safeFloat(ticker, 'buy_price'),
                        'ask': this.safeFloat(ticker, 'sell_price'),
                        'vwap': vwap,
                        'open': open,
                        'close': close,
                        'last': close,
                        'previousClose': undefined,
                        'change': change,
                        'percentage': change / open * 100,
                        'average': this.sum(open, close) / 2,
                        'baseVolume': baseVolume,
                        'quoteVolume': baseVolume * vwap,
                        'info': ticker,
                    };
                };
                bithumb.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, timestamp, tickers, ids, i, id, symbol, market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickerAll(params)];
                                case 2:
                                    response = _a.sent();
                                    result = {};
                                    timestamp = response['data']['date'];
                                    tickers = this.omit(response['data'], 'date');
                                    ids = Object.keys(tickers);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        symbol = id;
                                        market = undefined;
                                        if (id in this.markets_by_id) {
                                            market = this.markets_by_id[id];
                                            symbol = market['symbol'];
                                        }
                                        ticker = tickers[id];
                                        ticker['date'] = timestamp;
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bithumb.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTickerCurrency(this.extend({
                                            'currency': market['base'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTicker(response['data'], market)];
                            }
                        });
                    });
                };
                bithumb.prototype.parseTrade = function (trade, market) {
                    var _a = __read(trade['transaction_date'].split(' '), 2), transaction_date = _a[0], transaction_time = _a[1];
                    if (transaction_time.length < 8)
                        transaction_time = '0' + transaction_time;
                    var timestamp = this.parse8601(transaction_date + ' ' + transaction_time);
                    timestamp -= 9 * 3600000;
                    var side = (trade['type'] === 'ask') ? 'sell' : 'buy';
                    return {
                        'id': undefined,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'order': undefined,
                        'type': undefined,
                        'side': side,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['units_traded']),
                    };
                };
                bithumb.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetRecentTransactionsCurrency(this.extend({
                                            'currency': market['base'],
                                            'count': 100,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['data'], market, since, limit)];
                            }
                        });
                    });
                };
                bithumb.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, method, response, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = undefined;
                                    method = 'privatePostTrade';
                                    if (type === 'limit') {
                                        request = {
                                            'order_currency': market['id'],
                                            'Payment_currency': market['quote'],
                                            'units': amount,
                                            'price': price,
                                            'type': (side === 'buy') ? 'bid' : 'ask',
                                        };
                                        method += 'Place';
                                    }
                                    else if (type === 'market') {
                                        request = {
                                            'currency': market['id'],
                                            'units': amount,
                                        };
                                        method += 'Market' + this.capitalize(side);
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    id = undefined;
                                    if ('order_id' in response) {
                                        if (response['order_id'])
                                            id = response['order_id'].toString();
                                    }
                                    return [2, {
                                            'info': response,
                                            'id': id,
                                        }];
                            }
                        });
                    });
                };
                bithumb.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var side, currency;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    side = ('side' in params);
                                    if (!side)
                                        throw new ExchangeError(this.id + ' cancelOrder requires a side parameter (sell or buy) and a currency parameter');
                                    side = (side === 'buy') ? 'purchase' : 'sales';
                                    currency = ('currency' in params);
                                    if (!currency)
                                        throw new ExchangeError(this.id + ' cancelOrder requires a currency parameter');
                                    return [4, this.privatePostTradeCancel({
                                            'order_id': id,
                                            'type': params['side'],
                                            'currency': params['currency'],
                                        })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bithumb.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, destination, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    request = {
                                        'units': amount,
                                        'address': address,
                                        'currency': currency,
                                    };
                                    if (currency === 'XRP' || currency === 'XMR') {
                                        destination = ('destination' in params);
                                        if (!destination)
                                            throw new ExchangeError(this.id + ' ' + currency + ' withdraw requires an extra destination param');
                                    }
                                    return [4, this.privatePostTradeBtcWithdrawal(this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                bithumb.prototype.nonce = function () {
                    return this.milliseconds();
                };
                bithumb.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var endpoint = '/' + this.implodeParams(path, params);
                    var url = this.urls['api'][api] + endpoint;
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        body = this.urlencode(this.extend({
                            'endpoint': endpoint,
                        }, query));
                        var nonce = this.nonce().toString();
                        var auth = endpoint + '\0' + body + '\0' + nonce;
                        var signature = this.hmac(this.encode(auth), this.encode(this.secret), 'sha512');
                        var signature64 = this.decode(this.stringToBase64(this.encode(signature)));
                        headers = {
                            'Accept': 'application/json',
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Api-Key': this.apiKey,
                            'Api-Sign': signature64.toString(),
                            'Api-Nonce': nonce,
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bithumb.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('status' in response) {
                                        if (response['status'] === '0000')
                                            return [2, response];
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return bithumb;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 31: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var NotSupported = require('./base/errors').NotSupported;
            module.exports = (function (_super) {
                __extends(bitlish, _super);
                function bitlish() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitlish.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitlish',
                        'name': 'Bitlish',
                        'countries': ['GB', 'EU', 'RU'],
                        'rateLimit': 1500,
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1h': 3600,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766275-dcfc6c30-5ed3-11e7-839d-00a846385d0b.jpg',
                            'api': 'https://bitlish.com/api',
                            'www': 'https://bitlish.com',
                            'doc': 'https://bitlish.com/api',
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': false,
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'taker': 0.3 / 100,
                                'maker': 0,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0.001,
                                    'LTC': 0.001,
                                    'DOGE': 0.001,
                                    'ETH': 0.001,
                                    'XMR': 0,
                                    'ZEC': 0.001,
                                    'DASH': 0.0001,
                                    'EUR': 50,
                                },
                                'deposit': {
                                    'BTC': 0,
                                    'LTC': 0,
                                    'DOGE': 0,
                                    'ETH': 0,
                                    'XMR': 0,
                                    'ZEC': 0,
                                    'DASH': 0,
                                    'EUR': 0,
                                },
                            },
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'instruments',
                                    'ohlcv',
                                    'pairs',
                                    'tickers',
                                    'trades_depth',
                                    'trades_history',
                                ],
                                'post': [
                                    'instruments',
                                    'ohlcv',
                                    'pairs',
                                    'tickers',
                                    'trades_depth',
                                    'trades_history',
                                ],
                            },
                            'private': {
                                'post': [
                                    'accounts_operations',
                                    'balance',
                                    'cancel_trade',
                                    'cancel_trades_by_ids',
                                    'cancel_all_trades',
                                    'create_bcode',
                                    'create_template_wallet',
                                    'create_trade',
                                    'deposit',
                                    'list_accounts_operations_from_ts',
                                    'list_active_trades',
                                    'list_bcodes',
                                    'list_my_matches_from_ts',
                                    'list_my_trades',
                                    'list_my_trads_from_ts',
                                    'list_payment_methods',
                                    'list_payments',
                                    'redeem_code',
                                    'resign',
                                    'signin',
                                    'signout',
                                    'trade_details',
                                    'trade_options',
                                    'withdraw',
                                    'withdraw_by_id',
                                ],
                            },
                        },
                    });
                };
                bitlish.prototype.commonCurrencyCode = function (currency) {
                    if (!this.substituteCommonCurrencyCodes)
                        return currency;
                    if (currency === 'XBT')
                        return 'BTC';
                    if (currency === 'BCC')
                        return 'BCH';
                    if (currency === 'DRK')
                        return 'DASH';
                    if (currency === 'DSH')
                        currency = 'DASH';
                    if (currency === 'XDG')
                        currency = 'DOGE';
                    return currency;
                };
                bitlish.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, keys, p, market, id, symbol, _a, base, quote;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetPairs()];
                                case 1:
                                    markets = _c.sent();
                                    result = [];
                                    keys = Object.keys(markets);
                                    for (p = 0; p < keys.length; p++) {
                                        market = markets[keys[p]];
                                        id = market['id'];
                                        symbol = market['name'];
                                        _a = __read(symbol.split('/'), 2), base = _a[0], quote = _a[1];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitlish.prototype.parseTicker = function (ticker, market) {
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var last = this.safeFloat(ticker, 'last');
                    return {
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'high': this.safeFloat(ticker, 'max'),
                        'low': this.safeFloat(ticker, 'min'),
                        'bid': undefined,
                        'ask': undefined,
                        'vwap': undefined,
                        'open': this.safeFloat(ticker, 'first'),
                        'close': last,
                        'last': last,
                        'previousClose': undefined,
                        'change': undefined,
                        'percentage': this.safeFloat(ticker, 'prc') * 100,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'sum'),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                bitlish.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, ids, result, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickers(params)];
                                case 2:
                                    tickers = _a.sent();
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitlish.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, tickers, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTickers(params)];
                                case 2:
                                    tickers = _a.sent();
                                    ticker = tickers[market['id']];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                bitlish.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1h'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var now, start, interval;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    now = this.seconds();
                                    start = now - 86400 * 30;
                                    if (typeof since !== 'undefined')
                                        start = parseInt(since / 1000);
                                    interval = [start.toString(), undefined];
                                    return [4, this.publicPostOhlcv(this.extend({
                                            'time_range': interval,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitlish.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp, last;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTradesDepth(this.extend({
                                            'pair_id': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = undefined;
                                    last = this.safeInteger(orderbook, 'last');
                                    if (last)
                                        timestamp = parseInt(last / 1000);
                                    return [2, this.parseOrderBook(orderbook, timestamp, 'bid', 'ask', 'price', 'volume')];
                            }
                        });
                    });
                };
                bitlish.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var side = (trade['dir'] === 'bid') ? 'buy' : 'sell';
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = parseInt(trade['created'] / 1000);
                    return {
                        'id': undefined,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'order': undefined,
                        'type': undefined,
                        'side': side,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                bitlish.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradesHistory(this.extend({
                                            'pair_id': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['list'], market, since, limit)];
                            }
                        });
                    });
                };
                bitlish.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, currencies, balance, c, currency, account, i, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostBalance()];
                                case 2:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    currencies = Object.keys(response);
                                    balance = {};
                                    for (c = 0; c < currencies.length; c++) {
                                        currency = currencies[c];
                                        account = response[currency];
                                        currency = currency.toUpperCase();
                                        if (currency === 'DSH')
                                            currency = 'DASH';
                                        if (currency === 'XDG')
                                            currency = 'DOGE';
                                        balance[currency] = account;
                                    }
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        account = this.account();
                                        if (currency in balance) {
                                            account['free'] = parseFloat(balance[currency]['funds']);
                                            account['used'] = parseFloat(balance[currency]['holded']);
                                            account['total'] = this.sum(account['free'], account['used']);
                                        }
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitlish.prototype.signIn = function () {
                    return this.privatePostSignin({
                        'login': this.login,
                        'passwd': this.password,
                    });
                };
                bitlish.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'pair_id': this.marketId(symbol),
                                        'dir': (side === 'buy') ? 'bid' : 'ask',
                                        'amount': amount,
                                    };
                                    if (type === 'limit')
                                        order['price'] = price;
                                    return [4, this.privatePostCreateTrade(this.extend(order, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result['id'],
                                        }];
                            }
                        });
                    });
                };
                bitlish.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCancelTrade({ 'id': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitlish.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (currency !== 'BTC') {
                                        throw new NotSupported(this.id + ' currently supports BTC withdrawals only, until they document other currencies...');
                                    }
                                    return [4, this.privatePostWithdraw(this.extend({
                                            'currency': currency.toLowerCase(),
                                            'amount': parseFloat(amount),
                                            'account': address,
                                            'payment_method': 'bitcoin',
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['message_id'],
                                        }];
                            }
                        });
                    });
                };
                bitlish.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + path;
                    if (api === 'public') {
                        if (method === 'GET') {
                            if (Object.keys(params).length)
                                url += '?' + this.urlencode(params);
                        }
                        else {
                            body = this.json(params);
                            headers = { 'Content-Type': 'application/json' };
                        }
                    }
                    else {
                        this.checkRequiredCredentials();
                        body = this.json(this.extend({ 'token': this.apiKey }, params));
                        headers = { 'Content-Type': 'application/json' };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return bitlish;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 32: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(bitmarket, _super);
                function bitmarket() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitmarket.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitmarket',
                        'name': 'BitMarket',
                        'countries': ['PL', 'EU'],
                        'rateLimit': 1500,
                        'has': {
                            'CORS': false,
                            'fetchOHLCV': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '90m': '90m',
                            '6h': '6h',
                            '1d': '1d',
                            '1w': '7d',
                            '1M': '1m',
                            '3M': '3m',
                            '6M': '6m',
                            '1y': '1y',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27767256-a8555200-5ef9-11e7-96fd-469a65e2b0bd.jpg',
                            'api': {
                                'public': 'https://www.bitmarket.net',
                                'private': 'https://www.bitmarket.pl/api2/',
                            },
                            'www': [
                                'https://www.bitmarket.pl',
                                'https://www.bitmarket.net',
                            ],
                            'doc': [
                                'https://www.bitmarket.net/docs.php?file=api_public.html',
                                'https://www.bitmarket.net/docs.php?file=api_private.html',
                                'https://github.com/bitmarket-net/api',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'json/{market}/ticker',
                                    'json/{market}/orderbook',
                                    'json/{market}/trades',
                                    'json/ctransfer',
                                    'graphs/{market}/90m',
                                    'graphs/{market}/6h',
                                    'graphs/{market}/1d',
                                    'graphs/{market}/7d',
                                    'graphs/{market}/1m',
                                    'graphs/{market}/3m',
                                    'graphs/{market}/6m',
                                    'graphs/{market}/1y',
                                ],
                            },
                            'private': {
                                'post': [
                                    'info',
                                    'trade',
                                    'cancel',
                                    'orders',
                                    'trades',
                                    'history',
                                    'withdrawals',
                                    'tradingdesk',
                                    'tradingdeskStatus',
                                    'tradingdeskConfirm',
                                    'cryptotradingdesk',
                                    'cryptotradingdeskStatus',
                                    'cryptotradingdeskConfirm',
                                    'withdraw',
                                    'withdrawFiat',
                                    'withdrawPLNPP',
                                    'withdrawFiatFast',
                                    'deposit',
                                    'transfer',
                                    'transfers',
                                    'marginList',
                                    'marginOpen',
                                    'marginClose',
                                    'marginCancel',
                                    'marginModify',
                                    'marginBalanceAdd',
                                    'marginBalanceRemove',
                                    'swapList',
                                    'swapOpen',
                                    'swapClose',
                                ],
                            },
                        },
                        'markets': {
                            'BCH/PLN': { 'id': 'BCCPLN', 'symbol': 'BCH/PLN', 'base': 'BCH', 'quote': 'PLN' },
                            'BTG/PLN': { 'id': 'BTGPLN', 'symbol': 'BTG/PLN', 'base': 'BTG', 'quote': 'PLN' },
                            'BTC/PLN': { 'id': 'BTCPLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                            'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                            'LTC/PLN': { 'id': 'LTCPLN', 'symbol': 'LTC/PLN', 'base': 'LTC', 'quote': 'PLN' },
                            'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                            'LiteMineX/BTC': { 'id': 'LiteMineXBTC', 'symbol': 'LiteMineX/BTC', 'base': 'LiteMineX', 'quote': 'BTC' },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': true,
                                'percentage': true,
                                'taker': 0.45 / 100,
                                'maker': 0.15 / 100,
                                'tiers': {
                                    'taker': [
                                        [0, 0.45 / 100],
                                        [99.99, 0.44 / 100],
                                        [299.99, 0.43 / 100],
                                        [499.99, 0.42 / 100],
                                        [999.99, 0.41 / 100],
                                        [1999.99, 0.40 / 100],
                                        [2999.99, 0.39 / 100],
                                        [4999.99, 0.38 / 100],
                                        [9999.99, 0.37 / 100],
                                        [19999.99, 0.36 / 100],
                                        [29999.99, 0.35 / 100],
                                        [49999.99, 0.34 / 100],
                                        [99999.99, 0.33 / 100],
                                        [199999.99, 0.32 / 100],
                                        [299999.99, 0.31 / 100],
                                        [499999.99, 0.0 / 100],
                                    ],
                                    'maker': [
                                        [0, 0.15 / 100],
                                        [99.99, 0.14 / 100],
                                        [299.99, 0.13 / 100],
                                        [499.99, 0.12 / 100],
                                        [999.99, 0.11 / 100],
                                        [1999.99, 0.10 / 100],
                                        [2999.99, 0.9 / 100],
                                        [4999.99, 0.8 / 100],
                                        [9999.99, 0.7 / 100],
                                        [19999.99, 0.6 / 100],
                                        [29999.99, 0.5 / 100],
                                        [49999.99, 0.4 / 100],
                                        [99999.99, 0.3 / 100],
                                        [199999.99, 0.2 / 100],
                                        [299999.99, 0.1 / 100],
                                        [499999.99, 0.0 / 100],
                                    ],
                                },
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0.0008,
                                    'LTC': 0.005,
                                    'BCH': 0.0008,
                                    'BTG': 0.0008,
                                    'DOGE': 1,
                                    'EUR': 2,
                                    'PLN': 2,
                                },
                                'deposit': {
                                    'BTC': 0,
                                    'LTC': 0,
                                    'BCH': 0,
                                    'BTG': 0,
                                    'DOGE': 25,
                                    'EUR': 2,
                                    'PLN': 0,
                                },
                            },
                        },
                    });
                };
                bitmarket.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, data, balance, result, currencies, i, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostInfo()];
                                case 2:
                                    response = _a.sent();
                                    data = response['data'];
                                    balance = data['balances'];
                                    result = { 'info': data };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        account = this.account();
                                        if (currency in balance['available'])
                                            account['free'] = balance['available'][currency];
                                        if (currency in balance['blocked'])
                                            account['used'] = balance['blocked'][currency];
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitmarket.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetJsonMarketOrderbook(this.extend({
                                        'market': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    timestamp = this.milliseconds();
                                    return [2, {
                                            'bids': orderbook['bids'],
                                            'asks': orderbook['asks'],
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                        }];
                            }
                        });
                    });
                };
                bitmarket.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp, vwap, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetJsonMarketTicker(this.extend({
                                        'market': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = this.milliseconds();
                                    vwap = parseFloat(ticker['vwap']);
                                    baseVolume = parseFloat(ticker['volume']);
                                    quoteVolume = baseVolume * vwap;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': vwap,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bitmarket.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var side = (trade['type'] === 'bid') ? 'buy' : 'sell';
                    var timestamp = trade['date'] * 1000;
                    return {
                        'id': trade['tid'].toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'order': undefined,
                        'type': undefined,
                        'side': side,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                bitmarket.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetJsonMarketTrades(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitmarket.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '90m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv['time'] * 1000,
                        parseFloat(ohlcv['open']),
                        parseFloat(ohlcv['high']),
                        parseFloat(ohlcv['low']),
                        parseFloat(ohlcv['close']),
                        parseFloat(ohlcv['vol']),
                    ];
                };
                bitmarket.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '90m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = 'publicGetGraphsMarket' + this.timeframes[timeframe];
                                    market = this.market(symbol);
                                    return [4, this[method](this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                bitmarket.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostTrade(this.extend({
                                        'market': this.marketId(symbol),
                                        'type': side,
                                        'amount': amount,
                                        'rate': price,
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    result = {
                                        'info': response,
                                    };
                                    if ('id' in response['order'])
                                        result['id'] = response['id'];
                                    return [2, result];
                            }
                        });
                    });
                };
                bitmarket.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancel({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitmarket.prototype.isFiat = function (currency) {
                    if (currency === 'EUR')
                        return true;
                    if (currency === 'PLN')
                        return true;
                    return false;
                };
                bitmarket.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = undefined;
                                    request = {
                                        'currency': currency,
                                        'quantity': amount,
                                    };
                                    if (this.isFiat(currency)) {
                                        method = 'privatePostWithdrawFiat';
                                        if ('account' in params) {
                                            request['account'] = params['account'];
                                        }
                                        else {
                                            throw new ExchangeError(this.id + ' requires account parameter to withdraw fiat currency');
                                        }
                                        if ('account2' in params) {
                                            request['account2'] = params['account2'];
                                        }
                                        else {
                                            if (currency === 'EUR')
                                                throw new ExchangeError(this.id + ' requires account2 parameter to withdraw EUR');
                                        }
                                        if ('withdrawal_note' in params) {
                                            request['withdrawal_note'] = params['withdrawal_note'];
                                        }
                                        else {
                                            if (currency === 'PLN')
                                                throw new ExchangeError(this.id + ' requires withdrawal_note parameter to withdraw PLN');
                                        }
                                    }
                                    else {
                                        method = 'privatePostWithdraw';
                                        request['address'] = address;
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response,
                                        }];
                            }
                        });
                    });
                };
                bitmarket.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    if (api === 'public') {
                        url += '/' + this.implodeParams(path + '.json', params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var query = this.extend({
                            'tonce': nonce,
                            'method': path,
                        }, params);
                        body = this.urlencode(query);
                        headers = {
                            'API-Key': this.apiKey,
                            'API-Hash': this.hmac(this.encode(body), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return bitmarket;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 33: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, DDoSProtection = _a.DDoSProtection, OrderNotFound = _a.OrderNotFound, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(bitmex, _super);
                function bitmex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitmex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitmex',
                        'name': 'BitMEX',
                        'countries': 'SC',
                        'version': 'v1',
                        'userAgent': undefined,
                        'rateLimit': 2000,
                        'has': {
                            'CORS': false,
                            'fetchOHLCV': true,
                            'withdraw': true,
                            'fetchOrder': true,
                            'fetchOrders': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                        },
                        'timeframes': {
                            '1m': '1m',
                            '5m': '5m',
                            '1h': '1h',
                            '1d': '1d',
                        },
                        'urls': {
                            'test': 'https://testnet.bitmex.com',
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg',
                            'api': 'https://www.bitmex.com',
                            'www': 'https://www.bitmex.com',
                            'doc': [
                                'https://www.bitmex.com/app/apiOverview',
                                'https://github.com/BitMEX/api-connectors/tree/master/official-http',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'announcement',
                                    'announcement/urgent',
                                    'funding',
                                    'instrument',
                                    'instrument/active',
                                    'instrument/activeAndIndices',
                                    'instrument/activeIntervals',
                                    'instrument/compositeIndex',
                                    'instrument/indices',
                                    'insurance',
                                    'leaderboard',
                                    'liquidation',
                                    'orderBook',
                                    'orderBook/L2',
                                    'quote',
                                    'quote/bucketed',
                                    'schema',
                                    'schema/websocketHelp',
                                    'settlement',
                                    'stats',
                                    'stats/history',
                                    'trade',
                                    'trade/bucketed',
                                ],
                            },
                            'private': {
                                'get': [
                                    'apiKey',
                                    'chat',
                                    'chat/channels',
                                    'chat/connected',
                                    'execution',
                                    'execution/tradeHistory',
                                    'notification',
                                    'order',
                                    'position',
                                    'user',
                                    'user/affiliateStatus',
                                    'user/checkReferralCode',
                                    'user/commission',
                                    'user/depositAddress',
                                    'user/margin',
                                    'user/minWithdrawalFee',
                                    'user/wallet',
                                    'user/walletHistory',
                                    'user/walletSummary',
                                ],
                                'post': [
                                    'apiKey',
                                    'apiKey/disable',
                                    'apiKey/enable',
                                    'chat',
                                    'order',
                                    'order/bulk',
                                    'order/cancelAllAfter',
                                    'order/closePosition',
                                    'position/isolate',
                                    'position/leverage',
                                    'position/riskLimit',
                                    'position/transferMargin',
                                    'user/cancelWithdrawal',
                                    'user/confirmEmail',
                                    'user/confirmEnableTFA',
                                    'user/confirmWithdrawal',
                                    'user/disableTFA',
                                    'user/logout',
                                    'user/logoutAll',
                                    'user/preferences',
                                    'user/requestEnableTFA',
                                    'user/requestWithdrawal',
                                ],
                                'put': [
                                    'order',
                                    'order/bulk',
                                    'user',
                                ],
                                'delete': [
                                    'apiKey',
                                    'order',
                                    'order/all',
                                ],
                            },
                        },
                    });
                };
                bitmex.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, active, id, base, quote, type, future, prediction, basequote, swap, symbol, maker, taker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetInstrumentActiveAndIndices()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        active = (market['state'] !== 'Unlisted');
                                        id = market['symbol'];
                                        base = market['underlying'];
                                        quote = market['quoteCurrency'];
                                        type = undefined;
                                        future = false;
                                        prediction = false;
                                        basequote = base + quote;
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        swap = (id === basequote);
                                        symbol = id;
                                        if (swap) {
                                            type = 'swap';
                                            symbol = base + '/' + quote;
                                        }
                                        else if (id.indexOf('B_') >= 0) {
                                            prediction = true;
                                            type = 'prediction';
                                        }
                                        else {
                                            future = true;
                                            type = 'future';
                                        }
                                        maker = market['makerFee'];
                                        taker = market['takerFee'];
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'active': active,
                                            'taker': taker,
                                            'maker': maker,
                                            'type': type,
                                            'spot': false,
                                            'swap': swap,
                                            'future': future,
                                            'prediction': prediction,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitmex.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, b, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetUserMargin({ 'currency': 'all' })];
                                case 2:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    for (b = 0; b < response.length; b++) {
                                        balance = response[b];
                                        currency = balance['currency'].toUpperCase();
                                        currency = this.commonCurrencyCode(currency);
                                        account = {
                                            'free': balance['availableMargin'],
                                            'used': 0.0,
                                            'total': balance['marginBalance'],
                                        };
                                        if (currency === 'BTC') {
                                            account['free'] = account['free'] * 0.00000001;
                                            account['total'] = account['total'] * 0.00000001;
                                        }
                                        account['used'] = account['total'] - account['free'];
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitmex.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp, result, o, order, side, amount, price;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderBookL2(this.extend({
                                            'symbol': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = this.milliseconds();
                                    result = {
                                        'bids': [],
                                        'asks': [],
                                        'timestamp': timestamp,
                                        'datetime': this.iso8601(timestamp),
                                    };
                                    for (o = 0; o < orderbook.length; o++) {
                                        order = orderbook[o];
                                        side = (order['side'] === 'Sell') ? 'asks' : 'bids';
                                        amount = order['size'];
                                        price = order['price'];
                                        result[side].push([price, amount]);
                                    }
                                    result['bids'] = this.sortBy(result['bids'], 0, true);
                                    result['asks'] = this.sortBy(result['asks'], 0);
                                    return [2, result];
                            }
                        });
                    });
                };
                bitmex.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var filter, result, numResults;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    filter = { 'filter': { 'orderID': id } };
                                    return [4, this.fetchOrders(symbol, undefined, undefined, this.deepExtend(filter, params))];
                                case 1:
                                    result = _a.sent();
                                    numResults = result.length;
                                    if (numResults === 1)
                                        return [2, result[0]];
                                    throw new OrderNotFound(this.id + ': The order ' + id + ' not found.');
                            }
                        });
                    });
                };
                bitmex.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (typeof symbol !== 'undefined') {
                                        market = this.market(symbol);
                                        request['symbol'] = market['id'];
                                    }
                                    if (typeof since !== 'undefined')
                                        request['startTime'] = this.iso8601(since);
                                    if (typeof limit !== 'undefined')
                                        request['count'] = limit;
                                    request = this.deepExtend(request, params);
                                    request['filter'] = this.json(request['filter']);
                                    return [4, this.privateGetOrder(request)];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitmex.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var filter_params;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    filter_params = { 'filter': { 'open': true } };
                                    return [4, this.fetchOrders(symbol, since, limit, this.deepExtend(filter_params, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitmex.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.filterBy(orders, 'status', 'closed')];
                            }
                        });
                    });
                };
                bitmex.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, quotes, quotesLength, quote, tickers, ticker, timestamp, open, close, change;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    if (!market['active'])
                                        throw new ExchangeError(this.id + ': symbol ' + symbol + ' is delisted');
                                    request = this.extend({
                                        'symbol': market['id'],
                                        'binSize': '1d',
                                        'partial': true,
                                        'count': 1,
                                        'reverse': true,
                                    }, params);
                                    return [4, this.publicGetQuoteBucketed(request)];
                                case 2:
                                    quotes = _a.sent();
                                    quotesLength = quotes.length;
                                    quote = quotes[quotesLength - 1];
                                    return [4, this.publicGetTradeBucketed(request)];
                                case 3:
                                    tickers = _a.sent();
                                    ticker = tickers[0];
                                    timestamp = this.milliseconds();
                                    open = this.safeFloat(ticker, 'open');
                                    close = this.safeFloat(ticker, 'close');
                                    change = close - open;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(quote['bidPrice']),
                                            'ask': parseFloat(quote['askPrice']),
                                            'vwap': parseFloat(ticker['vwap']),
                                            'open': open,
                                            'close': close,
                                            'last': close,
                                            'previousClose': undefined,
                                            'change': change,
                                            'percentage': change / open * 100,
                                            'average': this.sum(open, close) / 2,
                                            'baseVolume': parseFloat(ticker['homeNotional']),
                                            'quoteVolume': parseFloat(ticker['foreignNotional']),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bitmex.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var timestamp = this.parse8601(ohlcv['timestamp']);
                    return [
                        timestamp,
                        ohlcv['open'],
                        ohlcv['high'],
                        ohlcv['low'],
                        ohlcv['close'],
                        ohlcv['volume'],
                    ];
                };
                bitmex.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 100; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, ymdhms, ymdhm, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'binSize': this.timeframes[timeframe],
                                        'partial': true,
                                        'count': limit,
                                    };
                                    if (typeof since !== 'undefined') {
                                        ymdhms = this.ymdhms(since);
                                        ymdhm = ymdhms.slice(0, 16);
                                        request['startTime'] = ymdhm;
                                    }
                                    return [4, this.publicGetTradeBucketed(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                bitmex.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(trade['timestamp']);
                    var symbol = undefined;
                    if (!market) {
                        if ('symbol' in trade)
                            market = this.markets_by_id[trade['symbol']];
                    }
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'id': trade['trdMatchID'],
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'order': undefined,
                        'type': undefined,
                        'side': trade['side'].toLowerCase(),
                        'price': trade['price'],
                        'amount': trade['size'],
                    };
                };
                bitmex.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        'new': 'open',
                        'partiallyfilled': 'open',
                        'filled': 'closed',
                        'canceled': 'canceled',
                        'rejected': 'rejected',
                        'expired': 'expired',
                    };
                    return this.safeString(statuses, status.toLowerCase());
                };
                bitmex.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var status = this.safeValue(order, 'ordStatus');
                    if (typeof status !== 'undefined')
                        status = this.parseOrderStatus(status);
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    else {
                        var id = order['symbol'];
                        if (id in this.markets_by_id) {
                            market = this.markets_by_id[id];
                            symbol = market['symbol'];
                        }
                    }
                    var datetime_value = undefined;
                    var timestamp = undefined;
                    var iso8601 = undefined;
                    if ('timestamp' in order)
                        datetime_value = order['timestamp'];
                    else if ('transactTime' in order)
                        datetime_value = order['transactTime'];
                    if (typeof datetime_value !== 'undefined') {
                        timestamp = this.parse8601(datetime_value);
                        iso8601 = this.iso8601(timestamp);
                    }
                    var price = parseFloat(order['price']);
                    var amount = parseFloat(order['orderQty']);
                    var filled = this.safeFloat(order, 'cumQty', 0.0);
                    var remaining = Math.max(amount - filled, 0.0);
                    var cost = undefined;
                    if (typeof price !== 'undefined')
                        if (typeof filled !== 'undefined')
                            cost = price * filled;
                    var result = {
                        'info': order,
                        'id': order['orderID'].toString(),
                        'timestamp': timestamp,
                        'datetime': iso8601,
                        'symbol': symbol,
                        'type': order['ordType'].toLowerCase(),
                        'side': order['side'].toLowerCase(),
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': undefined,
                    };
                    return result;
                };
                bitmex.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrade(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitmex.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'symbol': this.marketId(symbol),
                                        'side': this.capitalize(side),
                                        'orderQty': amount,
                                        'ordType': this.capitalize(type),
                                    };
                                    if (type === 'limit')
                                        order['price'] = price;
                                    return [4, this.privatePostOrder(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['orderID'],
                                        }];
                            }
                        });
                    });
                };
                bitmex.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, order, error;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateDeleteOrder({ 'orderID': id })];
                                case 2:
                                    response = _a.sent();
                                    order = response[0];
                                    error = this.safeString(order, 'error');
                                    if (typeof error !== 'undefined')
                                        if (error.indexOf('Unable to cancel order due to existing state') >= 0)
                                            throw new OrderNotFound(this.id + ' cancelOrder() failed: ' + error);
                                    return [2, this.parseOrder(order)];
                            }
                        });
                    });
                };
                bitmex.prototype.isFiat = function (currency) {
                    if (currency === 'EUR')
                        return true;
                    if (currency === 'PLN')
                        return true;
                    return false;
                };
                bitmex.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (currency !== 'BTC')
                                        throw new ExchangeError(this.id + ' supoprts BTC withdrawals only, other currencies coming soon...');
                                    request = {
                                        'currency': 'XBt',
                                        'amount': amount,
                                        'address': address,
                                    };
                                    return [4, this.privatePostUserRequestWithdrawal(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['transactID'],
                                        }];
                            }
                        });
                    });
                };
                bitmex.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code === 429)
                        throw new DDoSProtection(this.id + ' ' + body);
                    if (code >= 400) {
                        if (body) {
                            if (body[0] === '{') {
                                var response = JSON.parse(body);
                                if ('error' in response) {
                                    if ('message' in response['error']) {
                                        var message = this.safeValue(response['error'], 'message');
                                        if (typeof message !== 'undefined') {
                                            if (message === 'Invalid API Key.')
                                                throw new AuthenticationError(this.id + ' ' + this.json(response));
                                        }
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                }
                            }
                        }
                    }
                };
                bitmex.prototype.nonce = function () {
                    return this.milliseconds();
                };
                bitmex.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var query = '/api' + '/' + this.version + '/' + path;
                    if (method !== 'PUT')
                        if (Object.keys(params).length)
                            query += '?' + this.urlencode(params);
                    var url = this.urls['api'] + query;
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var auth = method + query + nonce;
                        if (method === 'POST' || method === 'PUT') {
                            if (Object.keys(params).length) {
                                body = this.json(params);
                                auth += body;
                            }
                        }
                        headers = {
                            'Content-Type': 'application/json',
                            'api-nonce': nonce,
                            'api-key': this.apiKey,
                            'api-signature': this.hmac(this.encode(auth), this.encode(this.secret)),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return bitmex;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 34: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(bitso, _super);
                function bitso() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitso.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitso',
                        'name': 'Bitso',
                        'countries': 'MX',
                        'rateLimit': 2000,
                        'version': 'v3',
                        'has': {
                            'CORS': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766335-715ce7aa-5ed5-11e7-88a8-173a27bb30fe.jpg',
                            'api': 'https://api.bitso.com',
                            'www': 'https://bitso.com',
                            'doc': 'https://bitso.com/api_info',
                            'fees': 'https://bitso.com/fees?l=es',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'available_books',
                                    'ticker',
                                    'order_book',
                                    'trades',
                                ],
                            },
                            'private': {
                                'get': [
                                    'account_status',
                                    'balance',
                                    'fees',
                                    'fundings',
                                    'fundings/{fid}',
                                    'funding_destination',
                                    'kyc_documents',
                                    'ledger',
                                    'ledger/trades',
                                    'ledger/fees',
                                    'ledger/fundings',
                                    'ledger/withdrawals',
                                    'mx_bank_codes',
                                    'open_orders',
                                    'order_trades/{oid}',
                                    'orders/{oid}',
                                    'user_trades',
                                    'user_trades/{tid}',
                                    'withdrawals/',
                                    'withdrawals/{wid}',
                                ],
                                'post': [
                                    'bitcoin_withdrawal',
                                    'debit_card_withdrawal',
                                    'ether_withdrawal',
                                    'orders',
                                    'phone_number',
                                    'phone_verification',
                                    'phone_withdrawal',
                                    'spei_withdrawal',
                                ],
                                'delete': [
                                    'orders/{oid}',
                                    'orders/all',
                                ],
                            },
                        },
                    });
                };
                bitso.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, i, market, id, symbol, _a, base, quote, limits, precision, lot;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetAvailableBooks()];
                                case 1:
                                    markets = _c.sent();
                                    result = [];
                                    for (i = 0; i < markets['payload'].length; i++) {
                                        market = markets['payload'][i];
                                        id = market['book'];
                                        symbol = id.toUpperCase().replace('_', '/');
                                        _a = __read(symbol.split('/'), 2), base = _a[0], quote = _a[1];
                                        limits = {
                                            'amount': {
                                                'min': parseFloat(market['minimum_amount']),
                                                'max': parseFloat(market['maximum_amount']),
                                            },
                                            'price': {
                                                'min': parseFloat(market['minimum_price']),
                                                'max': parseFloat(market['maximum_price']),
                                            },
                                            'cost': {
                                                'min': parseFloat(market['minimum_value']),
                                                'max': parseFloat(market['maximum_value']),
                                            },
                                        };
                                        precision = {
                                            'amount': this.precisionFromString(market['minimum_amount']),
                                            'price': this.precisionFromString(market['minimum_price']),
                                        };
                                        lot = limits['amount']['min'];
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                            'lot': lot,
                                            'limits': limits,
                                            'precision': precision,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitso.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetBalance()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['payload']['balances'];
                                    result = { 'info': response };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'].toUpperCase();
                                        account = {
                                            'free': parseFloat(balance['available']),
                                            'used': parseFloat(balance['locked']),
                                            'total': parseFloat(balance['total']),
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitso.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderBook(this.extend({
                                            'book': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['payload'];
                                    timestamp = this.parse8601(orderbook['updated_at']);
                                    return [2, this.parseOrderBook(orderbook, timestamp, 'bids', 'asks', 'price', 'amount')];
                            }
                        });
                    });
                };
                bitso.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, ticker, timestamp, vwap, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker(this.extend({
                                            'book': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['payload'];
                                    timestamp = this.parse8601(ticker['created_at']);
                                    vwap = parseFloat(ticker['vwap']);
                                    baseVolume = parseFloat(ticker['volume']);
                                    quoteVolume = baseVolume * vwap;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': vwap,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bitso.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(trade['created_at']);
                    var symbol = undefined;
                    if (typeof market === 'undefined') {
                        var marketId = this.safeString(trade, 'book');
                        if (marketId in this.markets_by_id)
                            market = this.markets_by_id[marketId];
                    }
                    if (typeof market !== 'undefined')
                        symbol = market['symbol'];
                    var side = this.safeString(trade, 'side');
                    if (typeof side === 'undefined')
                        side = this.safeString(trade, 'maker_side');
                    var amount = this.safeFloat(trade, 'amount');
                    if (typeof amount === 'undefined')
                        amount = this.safeFloat(trade, 'major');
                    if (typeof amount !== 'undefined')
                        amount = Math.abs(amount);
                    var fee = undefined;
                    var feeCost = this.safeFloat(trade, 'fees_amount');
                    if (typeof feeCost !== 'undefined') {
                        var feeCurrency = this.safeString(trade, 'fees_currency');
                        if (typeof feeCurrency !== 'undefined') {
                            if (feeCurrency in this.currencies_by_id)
                                feeCurrency = this.currencies_by_id[feeCurrency]['code'];
                        }
                        fee = {
                            'cost': feeCost,
                            'currency': feeCurrency,
                        };
                    }
                    var cost = this.safeFloat(trade, 'minor');
                    if (typeof cost !== 'undefined')
                        cost = Math.abs(cost);
                    var price = this.safeFloat(trade, 'price');
                    var orderId = this.safeString(trade, 'oid');
                    return {
                        'id': trade['tid'].toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'order': orderId,
                        'type': undefined,
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'fee': fee,
                    };
                };
                bitso.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrades(this.extend({
                                            'book': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['payload'], market, since, limit)];
                            }
                        });
                    });
                };
                bitso.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 25; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, markerInParams, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    markerInParams = ('marker' in params);
                                    if ((typeof since !== 'undefined') && !markerInParams)
                                        throw ExchangeError(this.id + ' fetchMyTrades does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id');
                                    if (markerInParams)
                                        params = this.extend(params, {
                                            'marker': parseInt(params['marker']),
                                        });
                                    request = {
                                        'book': market['id'],
                                        'limit': limit,
                                    };
                                    return [4, this.privateGetUserTrades(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['payload'], market, since, limit)];
                            }
                        });
                    });
                };
                bitso.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'book': this.marketId(symbol),
                                        'side': side,
                                        'type': type,
                                        'major': this.amountToPrecision(symbol, amount),
                                    };
                                    if (type === 'limit')
                                        order['price'] = this.priceToPrecision(symbol, price);
                                    return [4, this.privatePostOrders(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['payload']['oid'],
                                        }];
                            }
                        });
                    });
                };
                bitso.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateDeleteOrdersOid({ 'oid': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitso.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        'partial-fill': 'open',
                    };
                    if (status in statuses)
                        return statuses['status'];
                    return status;
                };
                bitso.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = order['side'];
                    var status = this.parseOrderStatus(order['status']);
                    var symbol = undefined;
                    if (typeof market === 'undefined') {
                        var marketId = order['book'];
                        if (marketId in this.markets_by_id)
                            market = this.markets_by_id[marketId];
                    }
                    if (market)
                        symbol = market['symbol'];
                    var orderType = order['type'];
                    var timestamp = this.parse8601(order['created_at']);
                    var amount = parseFloat(order['original_amount']);
                    var remaining = parseFloat(order['unfilled_amount']);
                    var filled = amount - remaining;
                    var result = {
                        'info': order,
                        'id': order['oid'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': orderType,
                        'side': side,
                        'price': this.safeFloat(order, 'price'),
                        'amount': amount,
                        'cost': undefined,
                        'remaining': remaining,
                        'filled': filled,
                        'status': status,
                        'fee': undefined,
                    };
                    return result;
                };
                bitso.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 25; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, markerInParams, request, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    markerInParams = ('marker' in params);
                                    if ((typeof since !== 'undefined') && !markerInParams)
                                        throw ExchangeError(this.id + ' fetchOpenOrders does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id');
                                    if (markerInParams)
                                        params = this.extend(params, {
                                            'marker': parseInt(params['marker']),
                                        });
                                    request = {
                                        'book': market['id'],
                                        'limit': limit,
                                    };
                                    return [4, this.privateGetOpenOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response['payload'], market, since, limit);
                                    return [2, orders];
                            }
                        });
                    });
                };
                bitso.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var endpoint = '/' + this.version + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (method === 'GET') {
                        if (Object.keys(query).length)
                            endpoint += '?' + this.urlencode(query);
                    }
                    var url = this.urls['api'] + endpoint;
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var request = [nonce, method, endpoint].join('');
                        if (method !== 'GET') {
                            if (Object.keys(query).length) {
                                body = this.json(query);
                                request += body;
                            }
                        }
                        var signature = this.hmac(this.encode(request), this.encode(this.secret));
                        var auth = this.apiKey + ':' + nonce + ':' + signature;
                        headers = {
                            'Authorization': 'Bitso ' + auth,
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bitso.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('success' in response)
                                        if (response['success'])
                                            return [2, response];
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                return bitso;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 35: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), AuthenticationError = _a.AuthenticationError, ExchangeError = _a.ExchangeError, NotSupported = _a.NotSupported;
            module.exports = (function (_super) {
                __extends(bitstamp, _super);
                function bitstamp() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitstamp.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitstamp',
                        'name': 'Bitstamp',
                        'countries': 'GB',
                        'rateLimit': 1000,
                        'version': 'v2',
                        'has': {
                            'CORS': true,
                            'fetchDepositAddress': true,
                            'fetchOrder': true,
                            'fetchOpenOrders': true,
                            'fetchMyTrades': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
                            'api': 'https://www.bitstamp.net/api',
                            'www': 'https://www.bitstamp.net',
                            'doc': 'https://www.bitstamp.net/api',
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': true,
                            'uid': true,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'order_book/{pair}/',
                                    'ticker_hour/{pair}/',
                                    'ticker/{pair}/',
                                    'transactions/{pair}/',
                                    'trading-pairs-info/',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balance/',
                                    'balance/{pair}/',
                                    'bch_withdrawal/',
                                    'bch_address/',
                                    'user_transactions/',
                                    'user_transactions/{pair}/',
                                    'open_orders/all/',
                                    'open_orders/{pair}/',
                                    'order_status/',
                                    'cancel_order/',
                                    'buy/{pair}/',
                                    'buy/market/{pair}/',
                                    'sell/{pair}/',
                                    'sell/market/{pair}/',
                                    'ltc_withdrawal/',
                                    'ltc_address/',
                                    'eth_withdrawal/',
                                    'eth_address/',
                                    'xrp_withdrawal/',
                                    'xrp_address/',
                                    'transfer-to-main/',
                                    'transfer-from-main/',
                                    'withdrawal/open/',
                                    'withdrawal/status/',
                                    'withdrawal/cancel/',
                                    'liquidation_address/new/',
                                    'liquidation_address/info/',
                                ],
                            },
                            'v1': {
                                'post': [
                                    'bitcoin_deposit_address/',
                                    'unconfirmed_btc/',
                                    'bitcoin_withdrawal/',
                                    'ripple_withdrawal/',
                                    'ripple_address/',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': true,
                                'percentage': true,
                                'taker': 0.25 / 100,
                                'maker': 0.25 / 100,
                                'tiers': {
                                    'taker': [
                                        [0, 0.25 / 100],
                                        [20000, 0.24 / 100],
                                        [100000, 0.22 / 100],
                                        [400000, 0.20 / 100],
                                        [600000, 0.15 / 100],
                                        [1000000, 0.14 / 100],
                                        [2000000, 0.13 / 100],
                                        [4000000, 0.12 / 100],
                                        [20000000, 0.11 / 100],
                                        [20000001, 0.10 / 100],
                                    ],
                                    'maker': [
                                        [0, 0.25 / 100],
                                        [20000, 0.24 / 100],
                                        [100000, 0.22 / 100],
                                        [400000, 0.20 / 100],
                                        [600000, 0.15 / 100],
                                        [1000000, 0.14 / 100],
                                        [2000000, 0.13 / 100],
                                        [4000000, 0.12 / 100],
                                        [20000000, 0.11 / 100],
                                        [20000001, 0.10 / 100],
                                    ],
                                },
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0,
                                    'BCH': 0,
                                    'LTC': 0,
                                    'ETH': 0,
                                    'XRP': 0,
                                    'USD': 25,
                                    'EUR': 0.90,
                                },
                                'deposit': {
                                    'BTC': 0,
                                    'BCH': 0,
                                    'LTC': 0,
                                    'ETH': 0,
                                    'XRP': 0,
                                    'USD': 25,
                                    'EUR': 0,
                                },
                            },
                        },
                    });
                };
                bitstamp.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, i, market, symbol, _a, base, quote, baseId, quoteId, symbolId, id, precision, parts, cost, active, lot;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetTradingPairsInfo()];
                                case 1:
                                    markets = _c.sent();
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        symbol = market['name'];
                                        _a = __read(symbol.split('/'), 2), base = _a[0], quote = _a[1];
                                        baseId = base.toLowerCase();
                                        quoteId = quote.toLowerCase();
                                        symbolId = baseId + '_' + quoteId;
                                        id = market['url_symbol'];
                                        precision = {
                                            'amount': market['base_decimals'],
                                            'price': market['counter_decimals'],
                                        };
                                        parts = market['minimum_order'].split(' ');
                                        cost = parts[0];
                                        active = (market['trading'] === 'Enabled');
                                        lot = Math.pow(10, -precision['amount']);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'symbolId': symbolId,
                                            'info': market,
                                            'lot': lot,
                                            'active': active,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': lot,
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision['price']),
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': parseFloat(cost),
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitstamp.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderBookPair(this.extend({
                                            'pair': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = parseInt(orderbook['timestamp']) * 1000;
                                    return [2, this.parseOrderBook(orderbook, timestamp)];
                            }
                        });
                    });
                };
                bitstamp.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp, vwap, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickerPair(this.extend({
                                            'pair': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    timestamp = parseInt(ticker['timestamp']) * 1000;
                                    vwap = parseFloat(ticker['vwap']);
                                    baseVolume = parseFloat(ticker['volume']);
                                    quoteVolume = baseVolume * vwap;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': vwap,
                                            'open': parseFloat(ticker['open']),
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bitstamp.prototype.getMarketFromTrade = function (trade) {
                    trade = this.omit(trade, [
                        'fee',
                        'price',
                        'datetime',
                        'tid',
                        'type',
                        'order_id',
                    ]);
                    var currencyIds = Object.keys(trade);
                    var numCurrencyIds = currencyIds.length;
                    if (numCurrencyIds === 2) {
                        var marketId = currencyIds[0] + currencyIds[1];
                        if (marketId in this.markets_by_id)
                            return this.markets_by_id[marketId];
                        marketId = currencyIds[1] + currencyIds[0];
                        if (marketId in this.markets_by_id)
                            return this.markets_by_id[marketId];
                    }
                    return undefined;
                };
                bitstamp.prototype.getMarketFromTrades = function (trades) {
                    var tradesBySymbol = this.indexBy(trades, 'symbol');
                    var symbols = Object.keys(tradesBySymbol);
                    var numSymbols = symbols.length;
                    if (numSymbols === 1)
                        return this.markets[symbols[0]];
                    return undefined;
                };
                bitstamp.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = undefined;
                    var symbol = undefined;
                    if ('date' in trade) {
                        timestamp = parseInt(trade['date']) * 1000;
                    }
                    else if ('datetime' in trade) {
                        timestamp = this.parse8601(trade['datetime']);
                    }
                    var side = this.safeString(trade, 'side');
                    var orderId = this.safeString(trade, 'order_id');
                    if (typeof orderId === 'undefined')
                        if (typeof side === 'undefined') {
                            side = this.safeInteger(trade, 'type');
                            if (side === 0)
                                side = 'buy';
                            else
                                side = 'sell';
                        }
                    var price = this.safeFloat(trade, 'price');
                    var amount = this.safeFloat(trade, 'amount');
                    var id = this.safeString(trade, 'tid');
                    id = this.safeString(trade, 'id', id);
                    if (typeof market === 'undefined') {
                        var keys = Object.keys(trade);
                        for (var i = 0; i < keys.length; i++) {
                            if (keys[i].indexOf('_') >= 0) {
                                var marketId = keys[i].replace('_', '');
                                if (marketId in this.markets_by_id)
                                    market = this.markets_by_id[marketId];
                            }
                        }
                        if (typeof market === 'undefined')
                            market = this.getMarketFromTrade(trade);
                    }
                    var feeCost = this.safeFloat(trade, 'fee');
                    var feeCurrency = undefined;
                    if (typeof market !== 'undefined') {
                        price = this.safeFloat(trade, market['symbolId'], price);
                        amount = this.safeFloat(trade, market['baseId'], amount);
                        feeCurrency = market['quote'];
                        symbol = market['symbol'];
                    }
                    var cost = undefined;
                    if (typeof price !== 'undefined')
                        if (typeof amount !== 'undefined')
                            cost = price * amount;
                    return {
                        'id': id,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'order': orderId,
                        'type': undefined,
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'fee': {
                            'cost': feeCost,
                            'currency': feeCurrency,
                        },
                    };
                };
                bitstamp.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTransactionsPair(this.extend({
                                            'pair': market['id'],
                                            'time': 'minute',
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitstamp.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balance, result, currencies, i, currency, lowercase, total, free, used, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostBalance()];
                                case 2:
                                    balance = _a.sent();
                                    result = { 'info': balance };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        total = lowercase + '_balance';
                                        free = lowercase + '_available';
                                        used = lowercase + '_reserved';
                                        account = this.account();
                                        if (free in balance)
                                            account['free'] = parseFloat(balance[free]);
                                        if (used in balance)
                                            account['used'] = parseFloat(balance[used]);
                                        if (total in balance)
                                            account['total'] = parseFloat(balance[total]);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitstamp.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = 'privatePost' + this.capitalize(side);
                                    order = {
                                        'pair': this.marketId(symbol),
                                        'amount': amount,
                                    };
                                    if (type === 'market')
                                        method += 'Market';
                                    else
                                        order['price'] = price;
                                    method += 'Pair';
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                bitstamp.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCancelOrder({ 'id': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitstamp.prototype.parseOrderStatus = function (order) {
                    if ((order['status'] === 'Queue') || (order['status'] === 'Open'))
                        return 'open';
                    if (order['status'] === 'Finished')
                        return 'closed';
                    return order['status'];
                };
                bitstamp.prototype.fetchOrderStatus = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrderStatus(this.extend({ 'id': id }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrderStatus(response)];
                            }
                        });
                    });
                };
                bitstamp.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (typeof symbol !== 'undefined')
                                        market = this.market(symbol);
                                    return [4, this.privatePostOrderStatus(this.extend({ 'id': id }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response, market)];
                            }
                        });
                    });
                };
                bitstamp.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, method, market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    method = 'privatePostUserTransactions';
                                    market = undefined;
                                    if (typeof symbol !== 'undefined') {
                                        market = this.market(symbol);
                                        request['pair'] = market['id'];
                                        method += 'Pair';
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitstamp.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var id = this.safeString(order, 'id');
                    var timestamp = undefined;
                    var iso8601 = undefined;
                    var side = this.safeString(order, 'type');
                    if (typeof side !== 'undefined')
                        side = (side === '1') ? 'sell' : 'buy';
                    var datetimeString = this.safeString(order, 'datetime');
                    if (typeof datetimeString !== 'undefined') {
                        timestamp = this.parse8601(datetimeString);
                        iso8601 = this.iso8601(timestamp);
                    }
                    var symbol = undefined;
                    if (typeof market === 'undefined') {
                        if ('currency_pair' in order) {
                            var marketId = order['currency_pair'];
                            if (marketId in this.markets_by_id)
                                market = this.markets_by_id[marketId];
                        }
                    }
                    var amount = this.safeFloat(order, 'amount');
                    var filled = 0.0;
                    var trades = [];
                    var transactions = this.safeValue(order, 'transactions');
                    var feeCost = undefined;
                    var cost = undefined;
                    if (typeof transactions !== 'undefined') {
                        if (Array.isArray(transactions)) {
                            for (var i = 0; i < transactions.length; i++) {
                                var trade = this.parseTrade(this.extend({
                                    'order_id': id,
                                    'side': side,
                                }, transactions[i]), market);
                                filled += trade['amount'];
                                if (typeof feeCost === 'undefined')
                                    feeCost = 0.0;
                                feeCost += trade['fee']['cost'];
                                if (typeof cost === 'undefined')
                                    cost = 0.0;
                                cost += trade['cost'];
                                trades.push(trade);
                            }
                        }
                    }
                    var status = this.safeString(order, 'status');
                    if ((status === 'In Queue') || (status === 'Open'))
                        status = 'open';
                    else if (status === 'Finished') {
                        status = 'closed';
                        if (typeof amount === 'undefined')
                            amount = filled;
                    }
                    var remaining = undefined;
                    if (typeof amount !== 'undefined')
                        remaining = amount - filled;
                    var price = this.safeFloat(order, 'price');
                    if (typeof market === 'undefined')
                        market = this.getMarketFromTrades(trades);
                    var feeCurrency = undefined;
                    if (typeof market !== 'undefined') {
                        symbol = market['symbol'];
                        feeCurrency = market['quote'];
                    }
                    if (typeof cost === 'undefined') {
                        if (typeof price !== 'undefined')
                            cost = price * filled;
                    }
                    else if (typeof price === 'undefined') {
                        if (filled > 0)
                            price = cost / filled;
                    }
                    var fee = {
                        'cost': feeCost,
                        'currency': feeCurrency,
                    };
                    return {
                        'id': id,
                        'datetime': iso8601,
                        'timestamp': timestamp,
                        'status': status,
                        'symbol': symbol,
                        'type': undefined,
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'trades': trades,
                        'fee': fee,
                        'info': order,
                    };
                };
                bitstamp.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = undefined;
                                    if (!(typeof symbol !== 'undefined')) return [3, 2];
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    _a.label = 2;
                                case 2: return [4, this.privatePostOpenOrdersAll()];
                                case 3:
                                    orders = _a.sent();
                                    return [2, this.parseOrders(orders, market, since, limit)];
                            }
                        });
                    });
                };
                bitstamp.prototype.getCurrencyName = function (code) {
                    if (code === 'BTC')
                        return 'bitcoin';
                    return code.toLowerCase();
                };
                bitstamp.prototype.isFiat = function (code) {
                    if (code === 'USD')
                        return true;
                    if (code === 'EUR')
                        return true;
                    return false;
                };
                bitstamp.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var name, v1, method, response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isFiat(code))
                                        throw new NotSupported(this.id + ' fiat fetchDepositAddress() for ' + code + ' is not implemented yet');
                                    name = this.getCurrencyName(code);
                                    v1 = (code === 'BTC');
                                    method = v1 ? 'v1' : 'private';
                                    method += 'Post' + this.capitalize(name);
                                    method += v1 ? 'Deposit' : '';
                                    method += 'Address';
                                    return [4, this[method](params)];
                                case 1:
                                    response = _a.sent();
                                    address = this.safeString(response, 'address');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': code,
                                            'status': 'ok',
                                            'address': address,
                                            'tag': this.safeString(response, 'destination_tag'),
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                bitstamp.prototype.withdraw = function (code, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var name, request, v1, method, query, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    if (this.isFiat(code))
                                        throw new NotSupported(this.id + ' fiat withdraw() for ' + code + ' is not implemented yet');
                                    name = this.getCurrencyName(code);
                                    request = {
                                        'amount': amount,
                                        'address': address,
                                    };
                                    v1 = (code === 'BTC');
                                    method = v1 ? 'v1' : 'private';
                                    method += 'Post' + this.capitalize(name) + 'Withdrawal';
                                    query = params;
                                    if (code === 'XRP') {
                                        if (typeof tag !== 'undefined') {
                                            request['destination_tag'] = tag;
                                            query = this.omit(params, 'destination_tag');
                                        }
                                        else {
                                            throw new ExchangeError(this.id + ' withdraw() requires a destination_tag param for ' + code);
                                        }
                                    }
                                    return [4, this[method](this.extend(request, query))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                bitstamp.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/';
                    if (api !== 'v1')
                        url += this.version + '/';
                    url += this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var auth = nonce + this.uid + this.apiKey;
                        var signature = this.encode(this.hmac(this.encode(auth), this.encode(this.secret)));
                        query = this.extend({
                            'key': this.apiKey,
                            'signature': signature.toUpperCase(),
                            'nonce': nonce,
                        }, query);
                        body = this.urlencode(query);
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bitstamp.prototype.handleErrors = function (httpCode, reason, url, method, headers, body) {
                    if (typeof body !== 'string')
                        return;
                    if (body.length < 2)
                        return;
                    if ((body[0] === '{') || (body[0] === '[')) {
                        var response = JSON.parse(body);
                        var status_1 = this.safeString(response, 'status');
                        if (status_1 === 'error') {
                            var code = this.safeString(response, 'code');
                            if (typeof code !== 'undefined') {
                                if (code === 'API0005')
                                    throw new AuthenticationError(this.id + ' invalid signature, use the uid for the main account if you have subaccounts');
                            }
                            throw new ExchangeError(this.id + ' ' + this.json(response));
                        }
                    }
                };
                return bitstamp;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 36: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, NotSupported = _a.NotSupported;
            module.exports = (function (_super) {
                __extends(bitstamp1, _super);
                function bitstamp1() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitstamp1.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitstamp1',
                        'name': 'Bitstamp v1',
                        'countries': 'GB',
                        'rateLimit': 1000,
                        'version': 'v1',
                        'has': {
                            'CORS': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
                            'api': 'https://www.bitstamp.net/api',
                            'www': 'https://www.bitstamp.net',
                            'doc': 'https://www.bitstamp.net/api',
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': true,
                            'uid': true,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'ticker',
                                    'ticker_hour',
                                    'order_book',
                                    'transactions',
                                    'eur_usd',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balance',
                                    'user_transactions',
                                    'open_orders',
                                    'order_status',
                                    'cancel_order',
                                    'cancel_all_orders',
                                    'buy',
                                    'sell',
                                    'bitcoin_deposit_address',
                                    'unconfirmed_btc',
                                    'ripple_withdrawal',
                                    'ripple_address',
                                    'withdrawal_requests',
                                    'bitcoin_withdrawal',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/USD': { 'id': 'btcusd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                            'BTC/EUR': { 'id': 'btceur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                            'EUR/USD': { 'id': 'eurusd', 'symbol': 'EUR/USD', 'base': 'EUR', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                            'XRP/USD': { 'id': 'xrpusd', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                            'XRP/EUR': { 'id': 'xrpeur', 'symbol': 'XRP/EUR', 'base': 'XRP', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                            'XRP/BTC': { 'id': 'xrpbtc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'maker': 0.0025, 'taker': 0.0025 },
                            'LTC/USD': { 'id': 'ltcusd', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                            'LTC/EUR': { 'id': 'ltceur', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                            'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'maker': 0.0025, 'taker': 0.0025 },
                            'ETH/USD': { 'id': 'ethusd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                            'ETH/EUR': { 'id': 'etheur', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                            'ETH/BTC': { 'id': 'ethbtc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.0025, 'taker': 0.0025 },
                        },
                    });
                };
                bitstamp1.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (symbol !== 'BTC/USD')
                                        throw new ExchangeError(this.id + ' ' + this.version + " fetchOrderBook doesn't support " + symbol + ', use it for BTC/USD only');
                                    return [4, this.publicGetOrderBook(params)];
                                case 1:
                                    orderbook = _a.sent();
                                    timestamp = parseInt(orderbook['timestamp']) * 1000;
                                    return [2, this.parseOrderBook(orderbook, timestamp)];
                            }
                        });
                    });
                };
                bitstamp1.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp, vwap, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (symbol !== 'BTC/USD')
                                        throw new ExchangeError(this.id + ' ' + this.version + " fetchTicker doesn't support " + symbol + ', use it for BTC/USD only');
                                    return [4, this.publicGetTicker(params)];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = parseInt(ticker['timestamp']) * 1000;
                                    vwap = parseFloat(ticker['vwap']);
                                    baseVolume = parseFloat(ticker['volume']);
                                    quoteVolume = baseVolume * vwap;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': vwap,
                                            'open': parseFloat(ticker['open']),
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bitstamp1.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = undefined;
                    if ('date' in trade) {
                        timestamp = parseInt(trade['date']) * 1000;
                    }
                    else if ('datetime' in trade) {
                        timestamp = parseInt(trade['datetime']) * 1000;
                    }
                    var side = (trade['type'] === 0) ? 'buy' : 'sell';
                    var order = undefined;
                    if ('order_id' in trade)
                        order = trade['order_id'].toString();
                    if ('currency_pair' in trade) {
                        if (trade['currency_pair'] in this.markets_by_id)
                            market = this.markets_by_id[trade['currency_pair']];
                    }
                    return {
                        'id': trade['tid'].toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'order': order,
                        'type': undefined,
                        'side': side,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                bitstamp1.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (symbol !== 'BTC/USD')
                                        throw new ExchangeError(this.id + ' ' + this.version + " fetchTrades doesn't support " + symbol + ', use it for BTC/USD only');
                                    market = this.market(symbol);
                                    return [4, this.publicGetTransactions(this.extend({
                                            'time': 'minute',
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitstamp1.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balance, result, currencies, i, currency, lowercase, total, free, used, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostBalance()];
                                case 1:
                                    balance = _a.sent();
                                    result = { 'info': balance };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        total = lowercase + '_balance';
                                        free = lowercase + '_available';
                                        used = lowercase + '_reserved';
                                        account = this.account();
                                        account['free'] = this.safeFloat(balance, free, 0.0);
                                        account['used'] = this.safeFloat(balance, used, 0.0);
                                        account['total'] = this.safeFloat(balance, total, 0.0);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitstamp1.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type !== 'limit')
                                        throw new ExchangeError(this.id + ' ' + this.version + ' accepts limit orders only');
                                    if (symbol !== 'BTC/USD')
                                        throw new ExchangeError(this.id + ' v1 supports BTC/USD orders only');
                                    method = 'privatePost' + this.capitalize(side);
                                    order = {
                                        'amount': amount,
                                        'price': price,
                                    };
                                    return [4, this[method](this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                bitstamp1.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancelOrder({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bitstamp1.prototype.parseOrderStatus = function (order) {
                    if ((order['status'] === 'Queue') || (order['status'] === 'Open'))
                        return 'open';
                    if (order['status'] === 'Finished')
                        return 'closed';
                    return order['status'];
                };
                bitstamp1.prototype.fetchOrderStatus = function (id, symbol) {
                    if (symbol === void 0) { symbol = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrderStatus({ 'id': id })];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrderStatus(response)];
                            }
                        });
                    });
                };
                bitstamp1.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, pair, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (symbol)
                                        market = this.market(symbol);
                                    pair = market ? market['id'] : 'all';
                                    request = this.extend({ 'id': pair }, params);
                                    return [4, this.privatePostOpenOrdersId(request)];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                bitstamp1.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new NotSupported(this.id + ' fetchOrder is not implemented yet');
                        });
                    });
                };
                bitstamp1.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var auth = nonce + this.uid + this.apiKey;
                        var signature = this.encode(this.hmac(this.encode(auth), this.encode(this.secret)));
                        query = this.extend({
                            'key': this.apiKey,
                            'signature': signature.toUpperCase(),
                            'nonce': nonce,
                        }, query);
                        body = this.urlencode(query);
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bitstamp1.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('status' in response)
                                        if (response['status'] === 'error')
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return bitstamp1;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 37: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError, InvalidOrder = _a.InvalidOrder, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound, DDoSProtection = _a.DDoSProtection;
            module.exports = (function (_super) {
                __extends(bittrex, _super);
                function bittrex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bittrex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bittrex',
                        'name': 'Bittrex',
                        'countries': 'US',
                        'version': 'v1.1',
                        'rateLimit': 1500,
                        'hasAlreadyAuthenticatedSuccessfully': false,
                        'has': {
                            'CORS': true,
                            'createMarketOrder': false,
                            'fetchDepositAddress': true,
                            'fetchClosedOrders': 'emulated',
                            'fetchCurrencies': true,
                            'fetchMyTrades': false,
                            'fetchOHLCV': true,
                            'fetchOrder': true,
                            'fetchOrders': true,
                            'fetchOpenOrders': true,
                            'fetchTickers': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1m': 'oneMin',
                            '5m': 'fiveMin',
                            '30m': 'thirtyMin',
                            '1h': 'hour',
                            '1d': 'day',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766352-cf0b3c26-5ed5-11e7-82b7-f3826b7a97d8.jpg',
                            'api': {
                                'public': 'https://bittrex.com/api',
                                'account': 'https://bittrex.com/api',
                                'market': 'https://bittrex.com/api',
                                'v2': 'https://bittrex.com/api/v2.0/pub',
                            },
                            'www': 'https://bittrex.com',
                            'doc': [
                                'https://bittrex.com/Home/Api',
                                'https://www.npmjs.org/package/node.bittrex.api',
                            ],
                            'fees': [
                                'https://bittrex.com/Fees',
                                'https://support.bittrex.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-',
                            ],
                        },
                        'api': {
                            'v2': {
                                'get': [
                                    'currencies/GetBTCPrice',
                                    'market/GetTicks',
                                    'market/GetLatestTick',
                                    'Markets/GetMarketSummaries',
                                    'market/GetLatestTick',
                                ],
                            },
                            'public': {
                                'get': [
                                    'currencies',
                                    'markethistory',
                                    'markets',
                                    'marketsummaries',
                                    'marketsummary',
                                    'orderbook',
                                    'ticker',
                                ],
                            },
                            'account': {
                                'get': [
                                    'balance',
                                    'balances',
                                    'depositaddress',
                                    'deposithistory',
                                    'order',
                                    'orderhistory',
                                    'withdrawalhistory',
                                    'withdraw',
                                ],
                            },
                            'market': {
                                'get': [
                                    'buylimit',
                                    'buymarket',
                                    'cancel',
                                    'openorders',
                                    'selllimit',
                                    'sellmarket',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'maker': 0.0025,
                                'taker': 0.0025,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0.001,
                                    'LTC': 0.01,
                                    'DOGE': 2,
                                    'VTC': 0.02,
                                    'PPC': 0.02,
                                    'FTC': 0.2,
                                    'RDD': 2,
                                    'NXT': 2,
                                    'DASH': 0.002,
                                    'POT': 0.002,
                                },
                                'deposit': {
                                    'BTC': 0,
                                    'LTC': 0,
                                    'DOGE': 0,
                                    'VTC': 0,
                                    'PPC': 0,
                                    'FTC': 0,
                                    'RDD': 0,
                                    'NXT': 0,
                                    'DASH': 0,
                                    'POT': 0,
                                },
                            },
                        },
                    });
                };
                bittrex.prototype.costToPrecision = function (symbol, cost) {
                    return this.truncate(parseFloat(cost), this.markets[symbol]['precision']['price']);
                };
                bittrex.prototype.feeToPrecision = function (symbol, fee) {
                    return this.truncate(parseFloat(fee), this.markets[symbol]['precision']['price']);
                };
                bittrex.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, i, market, id, baseId, quoteId, base, quote, symbol, precision, active;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.v2GetMarketsGetMarketSummaries()];
                                case 1:
                                    response = _a.sent();
                                    result = [];
                                    for (i = 0; i < response['result'].length; i++) {
                                        market = response['result'][i]['Market'];
                                        id = market['MarketName'];
                                        baseId = market['MarketCurrency'];
                                        quoteId = market['BaseCurrency'];
                                        base = this.commonCurrencyCode(baseId);
                                        quote = this.commonCurrencyCode(quoteId);
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': 8,
                                            'price': 8,
                                        };
                                        active = market['IsActive'];
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'active': active,
                                            'info': market,
                                            'lot': Math.pow(10, -precision['amount']),
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': market['MinTradeSize'],
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bittrex.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, indexed, keys, i, id, currency, account, balance, free, total, used;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.accountGetBalances(params)];
                                case 2:
                                    response = _a.sent();
                                    balances = response['result'];
                                    result = { 'info': balances };
                                    indexed = this.indexBy(balances, 'Currency');
                                    keys = Object.keys(indexed);
                                    for (i = 0; i < keys.length; i++) {
                                        id = keys[i];
                                        currency = this.commonCurrencyCode(id);
                                        account = this.account();
                                        balance = indexed[id];
                                        free = parseFloat(balance['Available']);
                                        total = parseFloat(balance['Balance']);
                                        used = total - free;
                                        account['free'] = free;
                                        account['used'] = used;
                                        account['total'] = total;
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bittrex.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderbook(this.extend({
                                            'market': this.marketId(symbol),
                                            'type': 'both',
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['result'];
                                    if ('type' in params) {
                                        if (params['type'] === 'buy') {
                                            orderbook = {
                                                'buy': response['result'],
                                                'sell': [],
                                            };
                                        }
                                        else if (params['type'] === 'sell') {
                                            orderbook = {
                                                'buy': [],
                                                'sell': response['result'],
                                            };
                                        }
                                    }
                                    return [2, this.parseOrderBook(orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity')];
                            }
                        });
                    });
                };
                bittrex.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(ticker['TimeStamp'] + '+00:00');
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var previous = this.safeFloat(ticker, 'PrevDay');
                    var last = this.safeFloat(ticker, 'Last');
                    var change = undefined;
                    var percentage = undefined;
                    if (typeof last !== 'undefined')
                        if (typeof previous !== 'undefined') {
                            change = last - previous;
                            if (previous > 0)
                                percentage = (change / previous) * 100;
                        }
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'High'),
                        'low': this.safeFloat(ticker, 'Low'),
                        'bid': this.safeFloat(ticker, 'Bid'),
                        'ask': this.safeFloat(ticker, 'Ask'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': last,
                        'change': change,
                        'percentage': percentage,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'Volume'),
                        'quoteVolume': this.safeFloat(ticker, 'BaseVolume'),
                        'info': ticker,
                    };
                };
                bittrex.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, currencies, result, i, currency, id, code, precision, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetCurrencies(params)];
                                case 1:
                                    response = _a.sent();
                                    currencies = response['result'];
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['Currency'];
                                        code = this.commonCurrencyCode(id);
                                        precision = 8;
                                        address = this.safeValue(currency, 'BaseAddress');
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'address': address,
                                            'info': currency,
                                            'type': currency['CoinType'],
                                            'name': currency['CurrencyLong'],
                                            'active': currency['IsActive'],
                                            'status': 'ok',
                                            'fee': currency['TxFee'],
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': currency['TxFee'],
                                                    'max': Math.pow(10, precision),
                                                },
                                            },
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bittrex.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, result, t, ticker, id, market, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetMarketsummaries(params)];
                                case 2:
                                    response = _a.sent();
                                    tickers = response['result'];
                                    result = {};
                                    for (t = 0; t < tickers.length; t++) {
                                        ticker = tickers[t];
                                        id = ticker['MarketName'];
                                        market = undefined;
                                        symbol = id;
                                        if (id in this.markets_by_id) {
                                            market = this.markets_by_id[id];
                                            symbol = market['symbol'];
                                        }
                                        else {
                                            symbol = this.parseSymbol(id);
                                        }
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bittrex.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketsummary(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['result'][0];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                bittrex.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(trade['TimeStamp'] + '+00:00');
                    var side = undefined;
                    if (trade['OrderType'] === 'BUY') {
                        side = 'buy';
                    }
                    else if (trade['OrderType'] === 'SELL') {
                        side = 'sell';
                    }
                    var id = undefined;
                    if ('Id' in trade)
                        id = trade['Id'].toString();
                    return {
                        'id': id,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': 'limit',
                        'side': side,
                        'price': parseFloat(trade['Price']),
                        'amount': parseFloat(trade['Quantity']),
                    };
                };
                bittrex.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarkethistory(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    if ('result' in response) {
                                        if (typeof response['result'] !== 'undefined')
                                            return [2, this.parseTrades(response['result'], market, since, limit)];
                                    }
                                    throw new ExchangeError(this.id + ' fetchTrades() returned undefined response');
                            }
                        });
                    });
                };
                bittrex.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1d'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var timestamp = this.parse8601(ohlcv['T'] + '+00:00');
                    return [
                        timestamp,
                        ohlcv['O'],
                        ohlcv['H'],
                        ohlcv['L'],
                        ohlcv['C'],
                        ohlcv['V'],
                    ];
                };
                bittrex.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'tickInterval': this.timeframes[timeframe],
                                        'marketName': market['id'],
                                    };
                                    return [4, this.v2GetMarketGetTicks(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    if ('result' in response) {
                                        if (response['result'])
                                            return [2, this.parseOHLCVs(response['result'], market, timeframe, since, limit)];
                                    }
                                    throw new ExchangeError(this.id + ' returned an empty or unrecognized response: ' + this.json(response));
                            }
                        });
                    });
                };
                bittrex.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    market = undefined;
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['market'] = market['id'];
                                    }
                                    return [4, this.marketGetOpenorders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response['result'], market, since, limit);
                                    return [2, this.filterBySymbol(orders, symbol)];
                            }
                        });
                    });
                };
                bittrex.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, order, response, orderIdField, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type !== 'limit')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'marketGet' + this.capitalize(side) + type;
                                    order = {
                                        'market': market['id'],
                                        'quantity': this.amountToPrecision(symbol, amount),
                                        'rate': this.priceToPrecision(symbol, price),
                                    };
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    orderIdField = this.getOrderIdField();
                                    result = {
                                        'info': response,
                                        'id': response['result'][orderIdField],
                                        'symbol': symbol,
                                        'type': type,
                                        'side': side,
                                        'status': 'open',
                                    };
                                    return [2, result];
                            }
                        });
                    });
                };
                bittrex.prototype.getOrderIdField = function () {
                    return 'uuid';
                };
                bittrex.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderIdField, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    orderIdField = this.getOrderIdField();
                                    request = {};
                                    request[orderIdField] = id;
                                    return [4, this.marketGetCancel(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                bittrex.prototype.parseSymbol = function (id) {
                    var _a = __read(id.split('-'), 2), quote = _a[0], base = _a[1];
                    base = this.commonCurrencyCode(base);
                    quote = this.commonCurrencyCode(quote);
                    return base + '/' + quote;
                };
                bittrex.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = this.safeString(order, 'OrderType');
                    if (typeof side === 'undefined')
                        side = this.safeString(order, 'Type');
                    var isBuyOrder = (side === 'LIMIT_BUY') || (side === 'BUY');
                    side = isBuyOrder ? 'buy' : 'sell';
                    var status = 'open';
                    if (('Closed' in order) && order['Closed'])
                        status = 'closed';
                    if (('CancelInitiated' in order) && order['CancelInitiated'])
                        status = 'canceled';
                    var symbol = undefined;
                    if (!market) {
                        if ('Exchange' in order) {
                            var marketId = order['Exchange'];
                            if (marketId in this.markets_by_id)
                                market = this.markets_by_id[marketId];
                            else
                                symbol = this.parseSymbol(marketId);
                        }
                    }
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = undefined;
                    if ('Opened' in order)
                        timestamp = this.parse8601(order['Opened'] + '+00:00');
                    if ('TimeStamp' in order)
                        timestamp = this.parse8601(order['TimeStamp'] + '+00:00');
                    if ('Created' in order)
                        timestamp = this.parse8601(order['Created'] + '+00:00');
                    var fee = undefined;
                    var commission = undefined;
                    if ('Commission' in order) {
                        commission = 'Commission';
                    }
                    else if ('CommissionPaid' in order) {
                        commission = 'CommissionPaid';
                    }
                    if (commission) {
                        fee = {
                            'cost': parseFloat(order[commission]),
                        };
                        if (market)
                            fee['currency'] = market['quote'];
                    }
                    var price = this.safeFloat(order, 'Limit');
                    var cost = this.safeFloat(order, 'Price');
                    var amount = this.safeFloat(order, 'Quantity');
                    var remaining = this.safeFloat(order, 'QuantityRemaining', 0.0);
                    var filled = amount - remaining;
                    if (!cost) {
                        if (price && amount)
                            cost = price * amount;
                    }
                    if (!price) {
                        if (cost && filled)
                            price = cost / filled;
                    }
                    var average = this.safeFloat(order, 'PricePerUnit');
                    var id = this.safeString(order, 'OrderUuid');
                    if (typeof id === 'undefined')
                        id = this.safeString(order, 'OrderId');
                    var result = {
                        'info': order,
                        'id': id,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': 'limit',
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'average': average,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': fee,
                    };
                    return result;
                };
                bittrex.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderIdField, request, e_16, message;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    response = undefined;
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 4, , 5]);
                                    orderIdField = this.getOrderIdField();
                                    request = {};
                                    request[orderIdField] = id;
                                    return [4, this.accountGetOrder(this.extend(request, params))];
                                case 3:
                                    response = _a.sent();
                                    return [3, 5];
                                case 4:
                                    e_16 = _a.sent();
                                    if (this.last_json_response) {
                                        message = this.safeString(this.last_json_response, 'message');
                                        if (message === 'UUID_INVALID')
                                            throw new OrderNotFound(this.id + ' fetchOrder() error: ' + this.last_http_response);
                                    }
                                    throw e_16;
                                case 5: return [2, this.parseOrder(response['result'])];
                            }
                        });
                    });
                };
                bittrex.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    market = undefined;
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['market'] = market['id'];
                                    }
                                    return [4, this.accountGetOrderhistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response['result'], market, since, limit);
                                    if (symbol)
                                        return [2, this.filterBySymbol(orders, symbol)];
                                    return [2, orders];
                            }
                        });
                    });
                };
                bittrex.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.filterBy(orders, 'status', 'closed')];
                            }
                        });
                    });
                };
                bittrex.prototype.currencyId = function (currency) {
                    if (currency === 'BCH')
                        return 'BCC';
                    return currency;
                };
                bittrex.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, address, message, status, tag;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.accountGetDepositaddress(this.extend({
                                            'currency': currency['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    address = this.safeString(response['result'], 'Address');
                                    message = this.safeString(response, 'message');
                                    status = 'ok';
                                    if (!address || message === 'ADDRESS_GENERATING')
                                        status = 'pending';
                                    tag = undefined;
                                    if ((code === 'XRP') || (code === 'XLM')) {
                                        tag = address;
                                        address = currency['address'];
                                    }
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': code,
                                            'address': address,
                                            'tag': tag,
                                            'status': status,
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                bittrex.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencyId, request, response, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    currencyId = this.currencyId(currency);
                                    request = {
                                        'currency': currencyId,
                                        'quantity': amount,
                                        'address': address,
                                    };
                                    if (tag)
                                        request['paymentid'] = tag;
                                    return [4, this.accountGetWithdraw(this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    id = undefined;
                                    if ('result' in response) {
                                        if ('uuid' in response['result'])
                                            id = response['result']['uuid'];
                                    }
                                    return [2, {
                                            'info': response,
                                            'id': id,
                                        }];
                            }
                        });
                    });
                };
                bittrex.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api] + '/';
                    if (api !== 'v2')
                        url += this.version + '/';
                    if (api === 'public') {
                        url += api + '/' + method.toLowerCase() + path;
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else if (api === 'v2') {
                        url += path;
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        url += api + '/';
                        if (((api === 'account') && (path !== 'withdraw')) || (path === 'openorders'))
                            url += method.toLowerCase();
                        url += path + '?' + this.urlencode(this.extend({
                            'nonce': nonce,
                            'apikey': this.apiKey,
                        }, params));
                        var signature = this.hmac(this.encode(url), this.encode(this.secret), 'sha512');
                        headers = { 'apisign': signature };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bittrex.prototype.throwExceptionOnError = function (response) {
                    if ('message' in response) {
                        var message = this.safeString(response, 'message');
                        var error = this.id + ' ' + this.json(response);
                        if (message === 'APISIGN_NOT_PROVIDED')
                            throw new AuthenticationError(error);
                        if (message === 'INVALID_SIGNATURE')
                            throw new AuthenticationError(error);
                        if (message === 'INVALID_CURRENCY')
                            throw new ExchangeError(error);
                        if (message === 'INVALID_PERMISSION')
                            throw new AuthenticationError(error);
                        if (message === 'INSUFFICIENT_FUNDS')
                            throw new InsufficientFunds(error);
                        if (message === 'QUANTITY_NOT_PROVIDED')
                            throw new InvalidOrder(error);
                        if (message === 'MIN_TRADE_REQUIREMENT_NOT_MET')
                            throw new InvalidOrder(error);
                        if (message === 'APIKEY_INVALID') {
                            if (this.hasAlreadyAuthenticatedSuccessfully) {
                                throw new DDoSProtection(error);
                            }
                            else {
                                throw new AuthenticationError(error);
                            }
                        }
                        if (message === 'DUST_TRADE_DISALLOWED_MIN_VALUE_50K_SAT')
                            throw new InvalidOrder(this.id + ' order cost should be over 50k satoshi ' + this.json(response));
                        if (message === 'ORDER_NOT_OPEN')
                            throw new InvalidOrder(error);
                        if (message === 'UUID_INVALID')
                            throw new OrderNotFound(error);
                    }
                };
                bittrex.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code >= 400) {
                        if (body[0] === '{') {
                            var response = JSON.parse(body);
                            this.throwExceptionOnError(response);
                            if ('success' in response) {
                                var success = response['success'];
                                if (typeof success === 'string')
                                    success = (success === 'true') ? true : false;
                                if (!success) {
                                    this.throwExceptionOnError(response);
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                                }
                            }
                        }
                    }
                };
                bittrex.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, success;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('success' in response) {
                                        success = response['success'];
                                        if (typeof success === 'string')
                                            success = (success === 'true') ? true : false;
                                        if (success) {
                                            if ((api === 'account') || (api === 'market'))
                                                this.hasAlreadyAuthenticatedSuccessfully = true;
                                            return [2, response];
                                        }
                                    }
                                    this.throwExceptionOnError(response);
                                    return [2];
                            }
                        });
                    });
                };
                return bittrex;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 38: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError, InvalidNonce = _a.InvalidNonce, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound, DDoSProtection = _a.DDoSProtection;
            module.exports = (function (_super) {
                __extends(bitz, _super);
                function bitz() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bitz.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bitz',
                        'name': 'Bit-Z',
                        'countries': 'HK',
                        'rateLimit': 1000,
                        'version': 'v1',
                        'has': {
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                            'fetchOpenOrders': true,
                        },
                        'timeframes': {
                            '1m': '1m',
                            '5m': '5m',
                            '15m': '15m',
                            '30m': '30m',
                            '1h': '1h',
                            '1d': '1d',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/35862606-4f554f14-0b5d-11e8-957d-35058c504b6f.jpg',
                            'api': 'https://www.bit-z.com/api_v1',
                            'www': 'https://www.bit-z.com',
                            'doc': 'https://www.bit-z.com/api.html',
                            'fees': 'https://www.bit-z.com/about/fee',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'ticker',
                                    'tickerall',
                                    'depth',
                                    'orders',
                                    'kline',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balances',
                                    'tradeAdd',
                                    'tradeCancel',
                                    'openOrders',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.001,
                                'taker': 0.001,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': '0.5%',
                                    'DKKT': '0.5%',
                                    'ETH': 0.01,
                                    'USDT': '0.5%',
                                    'LTC': '0.5%',
                                    'FCT': '0.5%',
                                    'LSK': '0.5%',
                                    'HXI': '0.8%',
                                    'ZEC': '0.5%',
                                    'DOGE': '0.5%',
                                    'MZC': '0.5%',
                                    'ETC': '0.5%',
                                    'GXS': '0.5%',
                                    'XPM': '0.5%',
                                    'PPC': '0.5%',
                                    'BLK': '0.5%',
                                    'XAS': '0.5%',
                                    'HSR': '0.5%',
                                    'NULS': 5.0,
                                    'VOISE': 350.0,
                                    'PAY': 1.5,
                                    'EOS': 0.6,
                                    'YBCT': 35.0,
                                    'OMG': 0.3,
                                    'OTN': 0.4,
                                    'BTX': '0.5%',
                                    'QTUM': '0.5%',
                                    'DASH': '0.5%',
                                    'GAME': '0.5%',
                                    'BCH': '0.5%',
                                    'GNT': 9.0,
                                    'SSS': 1500.0,
                                    'ARK': '0.5%',
                                    'PART': '0.5%',
                                    'LEO': '0.5%',
                                    'DGB': '0.5%',
                                    'ZSC': 130.0,
                                    'VIU': 350.0,
                                    'BTG': '0.5%',
                                    'ARN': 10.0,
                                    'VTC': '0.5%',
                                    'BCD': '0.5%',
                                    'TRX': 200.0,
                                    'HWC': '0.5%',
                                    'UNIT': '0.5%',
                                    'OXY': '0.5%',
                                    'MCO': 0.3500,
                                    'SBTC': '0.5%',
                                    'BCX': '0.5%',
                                    'ETF': '0.5%',
                                    'PYLNT': 0.4000,
                                    'XRB': '0.5%',
                                    'ETP': '0.5%',
                                },
                            },
                        },
                        'precision': {
                            'amount': 8,
                            'price': 8,
                        },
                    });
                };
                bitz.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, ids, result, i, id, market, _a, baseId, quoteId, base, quote, symbol;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetTickerall()];
                                case 1:
                                    response = _c.sent();
                                    markets = response['data'];
                                    ids = Object.keys(markets);
                                    result = [];
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = markets[id];
                                        _a = __read(id.split('_'), 2), baseId = _a[0], quoteId = _a[1];
                                        base = baseId.toUpperCase();
                                        quote = quoteId.toUpperCase();
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'active': true,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitz.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, data, balances, result, keys, i, currency, balance, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostBalances(params)];
                                case 2:
                                    response = _a.sent();
                                    data = response['data'];
                                    balances = this.omit(data, 'uid');
                                    result = { 'info': response };
                                    keys = Object.keys(balances);
                                    for (i = 0; i < keys.length; i++) {
                                        currency = keys[i];
                                        balance = parseFloat(balances[currency]);
                                        if (currency in this.currencies_by_id)
                                            currency = this.currencies_by_id[currency]['code'];
                                        else
                                            currency = currency.toUpperCase();
                                        account = this.account();
                                        account['free'] = balance;
                                        account['used'] = undefined;
                                        account['total'] = balance;
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bitz.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['date'] * 1000;
                    var symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['buy']),
                        'ask': parseFloat(ticker['sell']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['vol']),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                bitz.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTicker(this.extend({
                                            'coin': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTicker(response['data'], market)];
                            }
                        });
                    });
                };
                bitz.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, result, ids, i, id, market, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickerall(params)];
                                case 2:
                                    response = _a.sent();
                                    tickers = response['data'];
                                    result = {};
                                    ids = Object.keys(tickers);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        result[symbol] = this.parseTicker(tickers[id], market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bitz.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetDepth(this.extend({
                                            'coin': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['data'];
                                    timestamp = orderbook['date'] * 1000;
                                    return [2, this.parseOrderBook(orderbook, timestamp)];
                            }
                        });
                    });
                };
                bitz.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var hkt = this.sum(this.milliseconds(), 28800000);
                    var utcDate = this.iso8601(hkt);
                    utcDate = utcDate.split('T');
                    utcDate = utcDate[0] + ' ' + trade['t'] + '+08';
                    var timestamp = this.parse8601(utcDate);
                    var price = parseFloat(trade['p']);
                    var amount = parseFloat(trade['n']);
                    var symbol = market['symbol'];
                    var cost = this.priceToPrecision(symbol, amount * price);
                    return {
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'id': undefined,
                        'order': undefined,
                        'type': 'limit',
                        'side': trade['s'],
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'fee': undefined,
                        'info': trade,
                    };
                };
                bitz.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetOrders(this.extend({
                                            'coin': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    trades = response['data']['d'];
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                bitz.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ohlcv;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetKline(this.extend({
                                            'coin': market['id'],
                                            'type': this.timeframes[timeframe],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ohlcv = this.unjson(response['data']['datas']['data']);
                                    return [2, this.parseOHLCVs(ohlcv, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                bitz.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (typeof market !== 'undefined')
                        symbol = market['symbol'];
                    var side = this.safeString(order, 'side');
                    if (typeof side === 'undefined') {
                        side = this.safeString(order, 'type');
                        if (typeof side !== 'undefined')
                            side = (side === 'in') ? 'buy' : 'sell';
                    }
                    return {
                        'id': order['id'],
                        'datetime': undefined,
                        'timestamp': undefined,
                        'status': 'open',
                        'symbol': symbol,
                        'type': 'limit',
                        'side': side,
                        'price': order['price'],
                        'cost': undefined,
                        'amount': order['number'],
                        'filled': undefined,
                        'remaining': undefined,
                        'trades': undefined,
                        'fee': undefined,
                        'info': order,
                    };
                };
                bitz.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderType, request, response, id, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    orderType = (side === 'buy') ? 'in' : 'out';
                                    request = {
                                        'coin': market['id'],
                                        'type': orderType,
                                        'price': this.priceToPrecision(symbol, price),
                                        'number': this.amountToString(symbol, amount),
                                        'tradepwd': this.password,
                                    };
                                    return [4, this.privatePostTradeAdd(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    id = response['data']['id'];
                                    order = this.parseOrder({
                                        'id': id,
                                        'price': price,
                                        'number': amount,
                                        'side': side,
                                    }, market);
                                    this.orders[id] = order;
                                    return [2, order];
                            }
                        });
                    });
                };
                bitz.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostTradeCancel(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                bitz.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostOpenOrders(this.extend({
                                            'coin': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response['data'], market)];
                            }
                        });
                    });
                };
                bitz.prototype.nonce = function () {
                    var milliseconds = this.milliseconds();
                    return (milliseconds % 1000000);
                };
                bitz.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + path;
                    var query = undefined;
                    if (api === 'public') {
                        query = this.urlencode(params);
                        if (query.length)
                            url += '?' + query;
                    }
                    else {
                        this.checkRequiredCredentials();
                        body = this.urlencode(this.keysort(this.extend({
                            'api_key': this.apiKey,
                            'timestamp': this.seconds(),
                            'nonce': this.nonce(),
                        }, params)));
                        body += '&sign=' + this.hash(this.encode(body + this.secret));
                        headers = { 'Content-type': 'application/x-www-form-urlencoded' };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bitz.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, code, ErrorClass, message;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    code = this.safeString(response, 'code');
                                    if (code !== '0') {
                                        ErrorClass = this.safeValue({
                                            '103': AuthenticationError,
                                            '104': AuthenticationError,
                                            '200': AuthenticationError,
                                            '202': AuthenticationError,
                                            '401': AuthenticationError,
                                            '406': AuthenticationError,
                                            '203': InvalidNonce,
                                            '201': OrderNotFound,
                                            '408': InsufficientFunds,
                                            '106': DDoSProtection,
                                        }, code, ExchangeError);
                                        message = this.safeString(response, 'msg', 'Error');
                                        throw new ErrorClass(message);
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return bitz;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 39: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            module.exports = (function (_super) {
                __extends(bl3p, _super);
                function bl3p() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bl3p.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bl3p',
                        'name': 'BL3P',
                        'countries': ['NL', 'EU'],
                        'rateLimit': 1000,
                        'version': '1',
                        'comment': 'An exchange market by BitonicNL',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg',
                            'api': 'https://api.bl3p.eu',
                            'www': [
                                'https://bl3p.eu',
                                'https://bitonic.nl',
                            ],
                            'doc': [
                                'https://github.com/BitonicNL/bl3p-api/tree/master/docs',
                                'https://bl3p.eu/api',
                                'https://bitonic.nl/en/api',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    '{market}/ticker',
                                    '{market}/orderbook',
                                    '{market}/trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    '{market}/money/depth/full',
                                    '{market}/money/order/add',
                                    '{market}/money/order/cancel',
                                    '{market}/money/order/result',
                                    '{market}/money/orders',
                                    '{market}/money/orders/history',
                                    '{market}/money/trades/fetch',
                                    'GENMKT/money/info',
                                    'GENMKT/money/deposit_address',
                                    'GENMKT/money/new_deposit_address',
                                    'GENMKT/money/wallet/history',
                                    'GENMKT/money/withdraw',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                            'LTC/EUR': { 'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                        },
                    });
                };
                bl3p.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, data, balance, result, currencies, i, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostGENMKTMoneyInfo()];
                                case 1:
                                    response = _a.sent();
                                    data = response['data'];
                                    balance = data['wallets'];
                                    result = { 'info': data };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        account = this.account();
                                        if (currency in balance) {
                                            if ('available' in balance[currency]) {
                                                account['free'] = parseFloat(balance[currency]['available']['value']);
                                            }
                                        }
                                        if (currency in balance) {
                                            if ('balance' in balance[currency]) {
                                                account['total'] = parseFloat(balance[currency]['balance']['value']);
                                            }
                                        }
                                        if (account['total']) {
                                            if (account['free']) {
                                                account['used'] = account['total'] - account['free'];
                                            }
                                        }
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bl3p.prototype.parseBidAsk = function (bidask, priceKey, amountKey) {
                    if (priceKey === void 0) { priceKey = 0; }
                    if (amountKey === void 0) { amountKey = 0; }
                    return [
                        bidask[priceKey] / 100000.0,
                        bidask[amountKey] / 100000000.0,
                    ];
                };
                bl3p.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketOrderbook(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    orderbook = response['data'];
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price_int', 'amount_int')];
                            }
                        });
                    });
                };
                bl3p.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarketTicker(this.extend({
                                        'market': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = ticker['timestamp'] * 1000;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['volume']['24h']),
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                bl3p.prototype.parseTrade = function (trade, market) {
                    return {
                        'id': trade['trade_id'].toString(),
                        'timestamp': trade['date'],
                        'datetime': this.iso8601(trade['date']),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': trade['price_int'] / 100000.0,
                        'amount': trade['amount_int'] / 100000000.0,
                        'info': trade,
                    };
                };
                bl3p.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketTrades(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    result = this.parseTrades(response['data']['trades'], market, since, limit);
                                    return [2, result];
                            }
                        });
                    });
                };
                bl3p.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    order = {
                                        'market': market['id'],
                                        'amount_int': parseInt(amount * 100000000),
                                        'fee_currency': market['quote'],
                                        'type': (side === 'buy') ? 'bid' : 'ask',
                                    };
                                    if (type === 'limit')
                                        order['price_int'] = parseInt(price * 100000.0);
                                    return [4, this.privatePostMarketMoneyOrderAdd(this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['data']['order_id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                bl3p.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostMarketMoneyOrderCancel({ 'order_id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bl3p.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var request = this.implodeParams(path, params);
                    var url = this.urls['api'] + '/' + this.version + '/' + request;
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({ 'nonce': nonce }, query));
                        var secret = this.base64ToBinary(this.secret);
                        var auth = request + "\0" + body;
                        var signature = this.hmac(this.encode(auth), secret, 'sha512', 'base64');
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Rest-Key': this.apiKey,
                            'Rest-Sign': this.decode(signature),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return bl3p;
            }(Exchange));
        }, { "./base/Exchange": 8 }], 40: [function (require, module, exports) {
            'use strict';
            var bittrex = require('./bittrex.js');
            var _a = require('./base/errors'), AuthenticationError = _a.AuthenticationError, InvalidOrder = _a.InvalidOrder, InsufficientFunds = _a.InsufficientFunds, DDoSProtection = _a.DDoSProtection;
            module.exports = (function (_super) {
                __extends(bleutrade, _super);
                function bleutrade() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bleutrade.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bleutrade',
                        'name': 'Bleutrade',
                        'countries': 'BR',
                        'rateLimit': 1000,
                        'version': 'v2',
                        'has': {
                            'CORS': true,
                            'fetchTickers': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/30303000-b602dbe6-976d-11e7-956d-36c5049c01e7.jpg',
                            'api': {
                                'public': 'https://bleutrade.com/api',
                                'account': 'https://bleutrade.com/api',
                                'market': 'https://bleutrade.com/api',
                            },
                            'www': 'https://bleutrade.com',
                            'doc': 'https://bleutrade.com/help/API',
                            'fees': 'https://bleutrade.com/help/fees_and_deadlines',
                        },
                        'fees': {
                            'funding': {
                                'withdraw': {
                                    'ADC': 0.1,
                                    'BTA': 0.1,
                                    'BITB': 0.1,
                                    'BTC': 0.001,
                                    'BCC': 0.001,
                                    'BTCD': 0.001,
                                    'BTG': 0.001,
                                    'BLK': 0.1,
                                    'CDN': 0.1,
                                    'CLAM': 0.01,
                                    'DASH': 0.001,
                                    'DCR': 0.05,
                                    'DGC': 0.1,
                                    'DP': 0.1,
                                    'DPC': 0.1,
                                    'DOGE': 10.0,
                                    'EFL': 0.1,
                                    'ETH': 0.01,
                                    'EXP': 0.1,
                                    'FJC': 0.1,
                                    'BSTY': 0.001,
                                    'GB': 0.1,
                                    'NLG': 0.1,
                                    'HTML': 1.0,
                                    'LTC': 0.001,
                                    'MONA': 0.01,
                                    'MOON': 1.0,
                                    'NMC': 0.015,
                                    'NEOS': 0.1,
                                    'NVC': 0.05,
                                    'OK': 0.1,
                                    'PPC': 0.1,
                                    'POT': 0.1,
                                    'XPM': 0.001,
                                    'QTUM': 0.1,
                                    'RDD': 0.1,
                                    'SLR': 0.1,
                                    'START': 0.1,
                                    'SLG': 0.1,
                                    'TROLL': 0.1,
                                    'UNO': 0.01,
                                    'VRC': 0.1,
                                    'VTC': 0.1,
                                    'XVP': 0.1,
                                    'WDC': 0.001,
                                    'ZET': 0.1,
                                },
                            },
                        },
                    });
                };
                bleutrade.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, base, quote, symbol, precision, active;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarkets()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets['result'].length; p++) {
                                        market = markets['result'][p];
                                        id = market['MarketName'];
                                        base = market['MarketCurrency'];
                                        quote = market['BaseCurrency'];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': 8,
                                            'price': 8,
                                        };
                                        active = market['IsActive'];
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'active': active,
                                            'info': market,
                                            'lot': Math.pow(10, -precision['amount']),
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': market['MinTradeSize'],
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': 0,
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bleutrade.prototype.getOrderIdField = function () {
                    return 'orderid';
                };
                bleutrade.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'market': this.marketId(symbol),
                                        'type': 'ALL',
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['depth'] = limit;
                                    return [4, this.publicGetOrderbook(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['result'];
                                    return [2, this.parseOrderBook(orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity')];
                            }
                        });
                    });
                };
                bleutrade.prototype.throwExceptionOnError = function (response) {
                    if ('message' in response) {
                        if (response['message'] === 'Insufficient funds!')
                            throw new InsufficientFunds(this.id + ' ' + this.json(response));
                        if (response['message'] === 'MIN_TRADE_REQUIREMENT_NOT_MET')
                            throw new InvalidOrder(this.id + ' ' + this.json(response));
                        if (response['message'] === 'APIKEY_INVALID') {
                            if (this.hasAlreadyAuthenticatedSuccessfully) {
                                throw new DDoSProtection(this.id + ' ' + this.json(response));
                            }
                            else {
                                throw new AuthenticationError(this.id + ' ' + this.json(response));
                            }
                        }
                        if (response['message'] === 'DUST_TRADE_DISALLOWED_MIN_VALUE_50K_SAT')
                            throw new InvalidOrder(this.id + ' order cost should be over 50k satoshi ' + this.json(response));
                    }
                };
                return bleutrade;
            }(bittrex));
        }, { "./base/errors": 10, "./bittrex.js": 37 }], 41: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InvalidOrder = _a.InvalidOrder, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(braziliex, _super);
                function braziliex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                braziliex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'braziliex',
                        'name': 'Braziliex',
                        'countries': 'BR',
                        'rateLimit': 1000,
                        'has': {
                            'fetchCurrencies': true,
                            'fetchTickers': true,
                            'fetchOpenOrders': true,
                            'fetchMyTrades': true,
                            'fetchDepositAddress': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/34703593-c4498674-f504-11e7-8d14-ff8e44fb78c1.jpg',
                            'api': 'https://braziliex.com/api/v1',
                            'www': 'https://braziliex.com/',
                            'doc': 'https://braziliex.com/exchange/api.php',
                            'fees': 'https://braziliex.com/exchange/fees.php',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'currencies',
                                    'ticker',
                                    'ticker/{market}',
                                    'orderbook/{market}',
                                    'tradehistory/{market}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balance',
                                    'complete_balance',
                                    'open_orders',
                                    'trade_history',
                                    'deposit_address',
                                    'sell',
                                    'buy',
                                    'cancel_order',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.005,
                                'taker': 0.005,
                            },
                        },
                        'precision': {
                            'amount': 8,
                            'price': 8,
                        },
                    });
                };
                braziliex.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencies, ids, result, i, id, currency, precision, uppercase, code, active, status_2, maintenance, canWithdraw, canDeposit;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetCurrencies(params)];
                                case 1:
                                    currencies = _a.sent();
                                    ids = Object.keys(currencies);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        currency = currencies[id];
                                        precision = this.safeInteger(currency, 'decimal');
                                        uppercase = id.toUpperCase();
                                        code = this.commonCurrencyCode(uppercase);
                                        active = this.safeInteger(currency, 'active') === 1;
                                        status_2 = 'ok';
                                        maintenance = this.safeInteger(currency, 'under_maintenance');
                                        if (maintenance !== 0) {
                                            active = false;
                                            status_2 = 'maintenance';
                                        }
                                        canWithdraw = this.safeInteger(currency, 'is_withdrawal_active') === 1;
                                        canDeposit = this.safeInteger(currency, 'is_deposit_active') === 1;
                                        if (!canWithdraw || !canDeposit)
                                            active = false;
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'name': currency['name'],
                                            'active': active,
                                            'status': status_2,
                                            'precision': precision,
                                            'funding': {
                                                'withdraw': {
                                                    'active': canWithdraw,
                                                    'fee': currency['txWithdrawalFee'],
                                                },
                                                'deposit': {
                                                    'active': canDeposit,
                                                    'fee': currency['txDepositFee'],
                                                },
                                            },
                                            'limits': {
                                                'amount': {
                                                    'min': currency['minAmountTrade'],
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': currency['MinWithdrawal'],
                                                    'max': Math.pow(10, precision),
                                                },
                                                'deposit': {
                                                    'min': currency['minDeposit'],
                                                    'max': undefined,
                                                },
                                            },
                                            'info': currency,
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                braziliex.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, ids, result, i, id, market, _a, baseId, quoteId, base, quote, symbol, active, precision, lot;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetTicker()];
                                case 1:
                                    markets = _c.sent();
                                    ids = Object.keys(markets);
                                    result = [];
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = markets[id];
                                        _a = __read(id.split('_'), 2), baseId = _a[0], quoteId = _a[1];
                                        base = baseId.toUpperCase();
                                        quote = quoteId.toUpperCase();
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        active = this.safeInteger(market, 'active') === 1;
                                        precision = {
                                            'amount': 8,
                                            'price': 8,
                                        };
                                        lot = Math.pow(10, -precision['amount']);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol.toUpperCase(),
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'active': active,
                                            'lot': lot,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': lot,
                                                    'max': Math.pow(10, precision['amount']),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision['price']),
                                                    'max': Math.pow(10, precision['price']),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                            },
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                braziliex.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = market['symbol'];
                    var timestamp = ticker['date'];
                    ticker = ticker['ticker'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'highestBid24'),
                        'low': this.safeFloat(ticker, 'lowestAsk24'),
                        'bid': this.safeFloat(ticker, 'highestBid'),
                        'ask': this.safeFloat(ticker, 'lowestAsk'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last'),
                        'change': this.safeFloat(ticker, 'percentChange'),
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'baseVolume24'),
                        'quoteVolume': this.safeFloat(ticker, 'quoteVolume24'),
                        'info': ticker,
                    };
                };
                braziliex.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTickerMarket(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    ticker = {
                                        'date': this.milliseconds(),
                                        'ticker': ticker,
                                    };
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                braziliex.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result, timestamp, ids, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    result = {};
                                    timestamp = this.milliseconds();
                                    ids = Object.keys(tickers);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = {
                                            'date': timestamp,
                                            'ticker': tickers[id],
                                        };
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                braziliex.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderbookMarket(this.extend({
                                            'market': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price', 'amount')];
                            }
                        });
                    });
                };
                braziliex.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = undefined;
                    if ('date_exec' in trade) {
                        timestamp = this.parse8601(trade['date_exec']);
                    }
                    else {
                        timestamp = this.parse8601(trade['date']);
                    }
                    var price = parseFloat(trade['price']);
                    var amount = parseFloat(trade['amount']);
                    var symbol = market['symbol'];
                    var cost = parseFloat(trade['total']);
                    var orderId = this.safeString(trade, 'order_number');
                    return {
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'id': this.safeString(trade, '_id'),
                        'order': orderId,
                        'type': 'limit',
                        'side': trade['type'],
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'fee': undefined,
                        'info': trade,
                    };
                };
                braziliex.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradehistoryMarket(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    trades = _a.sent();
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                braziliex.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, currencies, i, id, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCompleteBalance(params)];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    currencies = Object.keys(balances);
                                    for (i = 0; i < currencies.length; i++) {
                                        id = currencies[i];
                                        balance = balances[id];
                                        currency = this.commonCurrencyCode(id);
                                        account = {
                                            'free': parseFloat(balance['available']),
                                            'used': 0.0,
                                            'total': parseFloat(balance['total']),
                                        };
                                        account['used'] = account['total'] - account['free'];
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                braziliex.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (!market) {
                        var marketId = this.safeString(order, 'market');
                        if (marketId)
                            if (marketId in this.markets_by_id)
                                market = this.markets_by_id[marketId];
                    }
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = this.safeValue(order, 'timestamp');
                    if (!timestamp)
                        timestamp = this.parse8601(order['date']);
                    var price = parseFloat(order['price']);
                    var cost = this.safeFloat(order, 'total', 0.0);
                    var amount = this.safeFloat(order, 'amount');
                    var filledPercentage = this.safeFloat(order, 'progress');
                    var filled = amount * filledPercentage;
                    var remaining = this.amountToPrecision(symbol, amount - filled);
                    var info = order;
                    if ('info' in info)
                        info = order['info'];
                    return {
                        'id': order['order_number'],
                        'datetime': this.iso8601(timestamp),
                        'timestamp': timestamp,
                        'status': 'open',
                        'symbol': symbol,
                        'type': 'limit',
                        'side': order['type'],
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'trades': undefined,
                        'fee': this.safeValue(order, 'fee'),
                        'info': info,
                    };
                };
                braziliex.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, response, success, parts, feeParts, order, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'privatePost' + this.capitalize(side);
                                    return [4, this[method](this.extend({
                                            'market': market['id'],
                                            'price': price,
                                            'amount': amount,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    success = this.safeInteger(response, 'success');
                                    if (success !== 1)
                                        throw new InvalidOrder(this.id + ' ' + this.json(response));
                                    parts = response['message'].split(' / ');
                                    parts = parts.slice(1);
                                    feeParts = parts[5].split(' ');
                                    order = this.parseOrder({
                                        'timestamp': this.milliseconds(),
                                        'order_number': response['order_number'],
                                        'type': parts[0].toLowerCase(),
                                        'market': parts[0].toLowerCase(),
                                        'amount': parts[2].split(' ')[1],
                                        'price': parts[3].split(' ')[1],
                                        'total': parts[4].split(' ')[1],
                                        'fee': {
                                            'cost': parseFloat(feeParts[1]),
                                            'currency': feeParts[2],
                                        },
                                        'progress': '0.0',
                                        'info': response,
                                    }, market);
                                    id = order['id'];
                                    this.orders[id] = order;
                                    return [2, order];
                            }
                        });
                    });
                };
                braziliex.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostCancelOrder(this.extend({
                                            'order_number': id,
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, result];
                            }
                        });
                    });
                };
                braziliex.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostOpenOrders(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    orders = _a.sent();
                                    return [2, this.parseOrders(orders['order_open'], market, since, limit)];
                            }
                        });
                    });
                };
                braziliex.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostTradeHistory(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    trades = _a.sent();
                                    return [2, this.parseTrades(trades['trade_history'], market, since, limit)];
                            }
                        });
                    });
                };
                braziliex.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, address, tag;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privatePostDepositAddress(this.extend({
                                            'currency': currency['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    address = this.safeString(response, 'deposit_address');
                                    this.checkAddress(address);
                                    tag = this.safeString(response, 'payment_id');
                                    return [2, {
                                            'currency': code,
                                            'address': address,
                                            'tag': tag,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                braziliex.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + api;
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        url += '/' + this.implodeParams(path, params);
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        query = this.extend({
                            'command': path,
                            'nonce': this.nonce(),
                        }, query);
                        body = this.urlencode(query);
                        var signature = this.hmac(this.encode(body), this.encode(this.secret), 'sha512');
                        headers = {
                            'Content-type': 'application/x-www-form-urlencoded',
                            'Key': this.apiKey,
                            'Sign': this.decode(signature),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                braziliex.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, success, message;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('success' in response) {
                                        success = this.safeInteger(response, 'success');
                                        if (success === 0) {
                                            message = this.safeString(response, 'message');
                                            if (message === 'Invalid APIKey')
                                                throw new AuthenticationError(message);
                                            throw new ExchangeError(message);
                                        }
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return braziliex;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 42: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(btcbox, _super);
                function btcbox() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                btcbox.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'btcbox',
                        'name': 'BtcBox',
                        'countries': 'JP',
                        'rateLimit': 1000,
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/31275803-4df755a8-aaa1-11e7-9abb-11ec2fad9f2d.jpg',
                            'api': 'https://www.btcbox.co.jp/api',
                            'www': 'https://www.btcbox.co.jp/',
                            'doc': 'https://www.btcbox.co.jp/help/asm',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'depth',
                                    'orders',
                                    'ticker',
                                    'allticker',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balance',
                                    'trade_add',
                                    'trade_cancel',
                                    'trade_list',
                                    'trade_view',
                                    'wallet',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/JPY': { 'id': 'BTC/JPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
                        },
                    });
                };
                btcbox.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, currencies, i, currency, lowercase, account, free, used;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostBalance()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        if (lowercase === 'dash')
                                            lowercase = 'drk';
                                        account = this.account();
                                        free = lowercase + '_balance';
                                        used = lowercase + '_lock';
                                        if (free in balances)
                                            account['free'] = parseFloat(balances[free]);
                                        if (used in balances)
                                            account['used'] = parseFloat(balances[used]);
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                btcbox.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, numSymbols, orderbook, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {};
                                    numSymbols = this.symbols.length;
                                    if (numSymbols > 1)
                                        request['coin'] = market['id'];
                                    return [4, this.publicGetDepth(this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    result = this.parseOrderBook(orderbook);
                                    result['asks'] = this.sortBy(result['asks'], 0);
                                    return [2, result];
                            }
                        });
                    });
                };
                btcbox.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high'),
                        'low': this.safeFloat(ticker, 'low'),
                        'bid': this.safeFloat(ticker, 'buy'),
                        'ask': this.safeFloat(ticker, 'sell'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last'),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'vol'),
                        'quoteVolume': this.safeFloat(ticker, 'volume'),
                        'info': ticker,
                    };
                };
                btcbox.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, ids, result, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetAllticker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                btcbox.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, numSymbols, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {};
                                    numSymbols = this.symbols.length;
                                    if (numSymbols > 1)
                                        request['coin'] = market['id'];
                                    return [4, this.publicGetTicker(this.extend(request, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                btcbox.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(trade['date']) * 1000;
                    return {
                        'info': trade,
                        'id': trade['tid'],
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['type'],
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                btcbox.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, numSymbols, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {};
                                    numSymbols = this.symbols.length;
                                    if (numSymbols > 1)
                                        request['coin'] = market['id'];
                                    return [4, this.publicGetOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                btcbox.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, numSymbols, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'amount': amount,
                                        'price': price,
                                        'type': side,
                                    };
                                    numSymbols = this.symbols.length;
                                    if (numSymbols > 1)
                                        request['coin'] = market['id'];
                                    return [4, this.privatePostTradeAdd(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                btcbox.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostTradeCancel(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                btcbox.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + path;
                    if (api === 'public') {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var query = this.extend({
                            'key': this.apiKey,
                            'nonce': nonce,
                        }, params);
                        var request = this.urlencode(query);
                        var secret = this.hash(this.encode(this.secret));
                        query['signature'] = this.hmac(this.encode(request), this.encode(secret));
                        body = this.urlencode(query);
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                btcbox.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('result' in response)
                                        if (!response['result'])
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return btcbox;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 43: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            module.exports = (function (_super) {
                __extends(btcchina, _super);
                function btcchina() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                btcchina.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'btcchina',
                        'name': 'BTCChina',
                        'countries': 'CN',
                        'rateLimit': 1500,
                        'version': 'v1',
                        'has': {
                            'CORS': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766368-465b3286-5ed6-11e7-9a11-0f6467e1d82b.jpg',
                            'api': {
                                'plus': 'https://plus-api.btcchina.com/market',
                                'public': 'https://data.btcchina.com/data',
                                'private': 'https://api.btcchina.com/api_trade_v1.php',
                            },
                            'www': 'https://www.btcchina.com',
                            'doc': 'https://www.btcchina.com/apidocs',
                        },
                        'api': {
                            'plus': {
                                'get': [
                                    'orderbook',
                                    'ticker',
                                    'trade',
                                ],
                            },
                            'public': {
                                'get': [
                                    'historydata',
                                    'orderbook',
                                    'ticker',
                                    'trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    'BuyIcebergOrder',
                                    'BuyOrder',
                                    'BuyOrder2',
                                    'BuyStopOrder',
                                    'CancelIcebergOrder',
                                    'CancelOrder',
                                    'CancelStopOrder',
                                    'GetAccountInfo',
                                    'getArchivedOrder',
                                    'getArchivedOrders',
                                    'GetDeposits',
                                    'GetIcebergOrder',
                                    'GetIcebergOrders',
                                    'GetMarketDepth',
                                    'GetMarketDepth2',
                                    'GetOrder',
                                    'GetOrders',
                                    'GetStopOrder',
                                    'GetStopOrders',
                                    'GetTransactions',
                                    'GetWithdrawal',
                                    'GetWithdrawals',
                                    'RequestWithdrawal',
                                    'SellIcebergOrder',
                                    'SellOrder',
                                    'SellOrder2',
                                    'SellStopOrder',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/CNY': { 'id': 'btccny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'api': 'public', 'plus': false },
                            'LTC/CNY': { 'id': 'ltccny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'api': 'public', 'plus': false },
                            'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'api': 'public', 'plus': false },
                            'BCH/CNY': { 'id': 'bcccny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY', 'api': 'plus', 'plus': true },
                            'ETH/CNY': { 'id': 'ethcny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY', 'api': 'plus', 'plus': true },
                        },
                    });
                };
                btcchina.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, keys, p, key, market, parts, id, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTicker({
                                        'market': 'all',
                                    })];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    keys = Object.keys(markets);
                                    for (p = 0; p < keys.length; p++) {
                                        key = keys[p];
                                        market = markets[key];
                                        parts = key.split('_');
                                        id = parts[1];
                                        base = id.slice(0, 3);
                                        quote = id.slice(3, 6);
                                        base = base.toUpperCase();
                                        quote = quote.toUpperCase();
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                btcchina.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, currencies, i, currency, lowercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetAccountInfo()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['result'];
                                    result = { 'info': balances };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        account = this.account();
                                        if (lowercase in balances['balance'])
                                            account['total'] = parseFloat(balances['balance'][lowercase]['amount']);
                                        if (lowercase in balances['frozen'])
                                            account['used'] = parseFloat(balances['frozen'][lowercase]['amount']);
                                        account['free'] = account['total'] - account['used'];
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                btcchina.prototype.createMarketRequest = function (market) {
                    var request = {};
                    var field = (market['plus']) ? 'symbol' : 'market';
                    request[field] = market['id'];
                    return request;
                };
                btcchina.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, orderbook, timestamp, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = market['api'] + 'GetOrderbook';
                                    request = this.createMarketRequest(market);
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = orderbook['date'] * 1000;
                                    result = this.parseOrderBook(orderbook, timestamp);
                                    result['asks'] = this.sortBy(result['asks'], 0);
                                    return [2, result];
                            }
                        });
                    });
                };
                btcchina.prototype.parseTicker = function (ticker, market) {
                    var timestamp = ticker['date'] * 1000;
                    var last = parseFloat(ticker['last']);
                    return {
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['buy']),
                        'ask': parseFloat(ticker['sell']),
                        'vwap': parseFloat(ticker['vwap']),
                        'open': parseFloat(ticker['open']),
                        'close': last,
                        'last': last,
                        'previousClose': undefined,
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['vol']),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                btcchina.prototype.parseTickerPlus = function (ticker, market) {
                    var timestamp = ticker['Timestamp'];
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['High']),
                        'low': parseFloat(ticker['Low']),
                        'bid': parseFloat(ticker['BidPrice']),
                        'ask': parseFloat(ticker['AskPrice']),
                        'vwap': undefined,
                        'open': parseFloat(ticker['Open']),
                        'last': parseFloat(ticker['Last']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['Volume24H']),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                btcchina.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, tickers, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = market['api'] + 'GetTicker';
                                    request = this.createMarketRequest(market);
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    tickers = _a.sent();
                                    ticker = tickers['ticker'];
                                    if (market['plus'])
                                        return [2, this.parseTickerPlus(ticker, market)];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                btcchina.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(trade['date']) * 1000;
                    return {
                        'id': trade['tid'],
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                btcchina.prototype.parseTradePlus = function (trade, market) {
                    var timestamp = this.parse8601(trade['timestamp']);
                    return {
                        'id': undefined,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['side'].toLowerCase(),
                        'price': trade['price'],
                        'amount': trade['size'],
                    };
                };
                btcchina.prototype.parseTradesPlus = function (trades, market) {
                    if (market === void 0) { market = undefined; }
                    var result = [];
                    for (var i = 0; i < trades.length; i++) {
                        result.push(this.parseTradePlus(trades[i], market));
                    }
                    return result;
                };
                btcchina.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, now, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = market['api'] + 'GetTrade';
                                    request = this.createMarketRequest(market);
                                    if (market['plus']) {
                                        now = this.milliseconds();
                                        request['start_time'] = now - 86400 * 1000;
                                        request['end_time'] = now;
                                    }
                                    else {
                                        method += 's';
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    if (market['plus']) {
                                        return [2, this.parseTradesPlus(response['trades'], market)];
                                    }
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                btcchina.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, order, id, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'privatePost' + this.capitalize(side) + 'Order2';
                                    order = {};
                                    id = market['id'].toUpperCase();
                                    if (type === 'market') {
                                        order['params'] = [undefined, amount, id];
                                    }
                                    else {
                                        order['params'] = [price, amount, id];
                                    }
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                btcchina.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = params['market'];
                                    return [4, this.privatePostCancelOrder(this.extend({
                                            'params': [id, market],
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                btcchina.prototype.nonce = function () {
                    return this.microseconds();
                };
                btcchina.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api] + '/' + path;
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var p = [];
                        if ('params' in params)
                            p = params['params'];
                        var nonce = this.nonce();
                        var request = {
                            'method': path,
                            'id': nonce,
                            'params': p,
                        };
                        p = p.join(',');
                        body = this.json(request);
                        var query = ('tonce=' + nonce +
                            '&accesskey=' + this.apiKey +
                            '&requestmethod=' + method.toLowerCase() +
                            '&id=' + nonce +
                            '&method=' + path +
                            '&params=' + p);
                        var signature = this.hmac(this.encode(query), this.encode(this.secret), 'sha1');
                        var auth = this.encode(this.apiKey + ':' + signature);
                        headers = {
                            'Authorization': 'Basic ' + this.stringToBase64(auth),
                            'Json-Rpc-Tonce': nonce,
                        };
                    }
                    else {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return btcchina;
            }(Exchange));
        }, { "./base/Exchange": 8 }], 44: [function (require, module, exports) {
            'use strict';
            var btcturk = require('./btcturk.js');
            module.exports = (function (_super) {
                __extends(btcexchange, _super);
                function btcexchange() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                btcexchange.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'btcexchange',
                        'name': 'BTCExchange',
                        'countries': 'PH',
                        'rateLimit': 1500,
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27993052-4c92911a-64aa-11e7-96d8-ec6ac3435757.jpg',
                            'api': 'https://www.btcexchange.ph/api',
                            'www': 'https://www.btcexchange.ph',
                            'doc': 'https://github.com/BTCTrader/broker-api-docs',
                        },
                        'markets': {
                            'BTC/PHP': { 'id': 'BTC/PHP', 'symbol': 'BTC/PHP', 'base': 'BTC', 'quote': 'PHP' },
                        },
                    });
                };
                return btcexchange;
            }(btcturk));
        }, { "./btcturk.js": 48 }], 45: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, OrderNotFound = _a.OrderNotFound, NotSupported = _a.NotSupported, InvalidOrder = _a.InvalidOrder, DDoSProtection = _a.DDoSProtection;
            module.exports = (function (_super) {
                __extends(btcmarkets, _super);
                function btcmarkets() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                btcmarkets.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'btcmarkets',
                        'name': 'BTC Markets',
                        'countries': 'AU',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': false,
                            'fetchOHLCV': true,
                            'fetchOrder': true,
                            'fetchOrders': true,
                            'fetchClosedOrders': 'emulated',
                            'fetchOpenOrders': true,
                            'fetchMyTrades': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/29142911-0e1acfc2-7d5c-11e7-98c4-07d9532b29d7.jpg',
                            'api': {
                                'public': 'https://api.btcmarkets.net',
                                'private': 'https://api.btcmarkets.net',
                                'web': 'https://btcmarkets.net/data',
                            },
                            'www': 'https://btcmarkets.net/',
                            'doc': 'https://github.com/BTCMarkets/API',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'market/{id}/tick',
                                    'market/{id}/orderbook',
                                    'market/{id}/trades',
                                ],
                            },
                            'private': {
                                'get': [
                                    'account/balance',
                                    'account/{id}/tradingfee',
                                ],
                                'post': [
                                    'fundtransfer/withdrawCrypto',
                                    'fundtransfer/withdrawEFT',
                                    'order/create',
                                    'order/cancel',
                                    'order/history',
                                    'order/open',
                                    'order/trade/history',
                                    'order/createBatch',
                                    'order/detail',
                                ],
                            },
                            'web': {
                                'get': [
                                    'market/BTCMarkets/{id}/tickByTime',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/AUD': { 'id': 'BTC/AUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } }, 'precision': { 'price': 2 } },
                            'LTC/AUD': { 'id': 'LTC/AUD', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } }, 'precision': { 'price': 2 } },
                            'ETH/AUD': { 'id': 'ETH/AUD', 'symbol': 'ETH/AUD', 'base': 'ETH', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } }, 'precision': { 'price': 2 } },
                            'ETC/AUD': { 'id': 'ETC/AUD', 'symbol': 'ETC/AUD', 'base': 'ETC', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } }, 'precision': { 'price': 2 } },
                            'XRP/AUD': { 'id': 'XRP/AUD', 'symbol': 'XRP/AUD', 'base': 'XRP', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } }, 'precision': { 'price': 2 } },
                            'BCH/AUD': { 'id': 'BCH/AUD', 'symbol': 'BCH/AUD', 'base': 'BCH', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } }, 'precision': { 'price': 2 } },
                            'LTC/BTC': { 'id': 'LTC/BTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } } },
                            'ETH/BTC': { 'id': 'ETH/BTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } } },
                            'ETC/BTC': { 'id': 'ETC/BTC', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } } },
                            'XRP/BTC': { 'id': 'XRP/BTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } } },
                            'BCH/BTC': { 'id': 'BCH/BTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022, 'limits': { 'amount': { 'min': 0.001, 'max': undefined } } },
                        },
                        'timeframes': {
                            '1m': 'minute',
                            '1h': 'hour',
                            '1d': 'day',
                        },
                        'exceptions': {
                            '3': InvalidOrder,
                            '6': DDoSProtection,
                        },
                    });
                };
                btcmarkets.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, b, balance, currency, multiplier, total, used, free, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetAccountBalance()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        multiplier = 100000000;
                                        total = parseFloat(balance['balance'] / multiplier);
                                        used = parseFloat(balance['pendingFunds'] / multiplier);
                                        free = total - used;
                                        account = {
                                            'free': free,
                                            'used': used,
                                            'total': total,
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                btcmarkets.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var multiplier = 100000000;
                    return [
                        ohlcv[0],
                        parseFloat(ohlcv[1]) / multiplier,
                        parseFloat(ohlcv[2]) / multiplier,
                        parseFloat(ohlcv[3]) / multiplier,
                        parseFloat(ohlcv[4]) / multiplier,
                        parseFloat(ohlcv[5]) / multiplier,
                    ];
                };
                btcmarkets.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.load_markets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'id': market['id'],
                                        'timeWindow': this.timeframes[timeframe],
                                    };
                                    if (typeof since !== 'undefined')
                                        request['since'] = since;
                                    return [4, this.webGetMarketBTCMarketsIdTickByTime(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response['ticks'], market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                btcmarkets.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketIdOrderbook(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = orderbook['timestamp'] * 1000;
                                    return [2, this.parseOrderBook(orderbook, timestamp)];
                            }
                        });
                    });
                };
                btcmarkets.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['timestamp'] * 1000;
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': undefined,
                        'low': undefined,
                        'bid': parseFloat(ticker['bestBid']),
                        'ask': parseFloat(ticker['bestAsk']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['lastPrice']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['volume24h']),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                btcmarkets.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketIdTick(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                btcmarkets.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['date'] * 1000;
                    return {
                        'info': trade,
                        'id': trade['tid'].toString(),
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                btcmarkets.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketIdTrades(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                btcmarkets.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, multiplier, orderSide, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    multiplier = 100000000;
                                    orderSide = (side === 'buy') ? 'Bid' : 'Ask';
                                    order = this.ordered({
                                        'currency': market['quote'],
                                    });
                                    order['currency'] = market['quote'];
                                    order['instrument'] = market['base'];
                                    order['price'] = parseInt(price * multiplier);
                                    order['volume'] = parseInt(amount * multiplier);
                                    order['orderSide'] = orderSide;
                                    order['ordertype'] = this.capitalize(type);
                                    order['clientRequestId'] = this.nonce().toString();
                                    return [4, this.privatePostOrderCreate(order)];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                btcmarkets.prototype.cancelOrders = function (ids) {
                    return __awaiter(this, void 0, void 0, function () {
                        var i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    for (i = 0; i < ids.length; i++) {
                                        ids[i] = parseInt(ids[i]);
                                    }
                                    return [4, this.privatePostOrderCancel({ 'orderIds': ids })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                btcmarkets.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.cancelOrders([id])];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                btcmarkets.prototype.parseMyTrade = function (trade, market) {
                    var multiplier = 100000000;
                    var timestamp = trade['creationTime'];
                    var side = (trade['side'] === 'Bid') ? 'buy' : 'sell';
                    var currency = (market['quote'] === 'AUD') ? market['quote'] : market['base'];
                    return {
                        'info': trade,
                        'id': trade['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': side,
                        'price': trade['price'] / multiplier,
                        'fee': {
                            'currency': currency,
                            'cost': trade['fee'] / multiplier,
                        },
                        'amount': trade['volume'] / multiplier,
                        'order': this.safeString(trade, 'orderId'),
                    };
                };
                btcmarkets.prototype.parseMyTrades = function (trades, market, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var result = [];
                    for (var i = 0; i < trades.length; i++) {
                        var trade = this.parseMyTrade(trades[i], market);
                        result.push(trade);
                    }
                    return result;
                };
                btcmarkets.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var multiplier = 100000000;
                    var side = (order['orderSide'] === 'Bid') ? 'buy' : 'sell';
                    var type = (order['ordertype'] === 'Limit') ? 'limit' : 'market';
                    var timestamp = order['creationTime'];
                    if (!market) {
                        market = this.market(order['instrument'] + '/' + order['currency']);
                    }
                    var status = 'open';
                    if (order['status'] === 'Failed' || order['status'] === 'Cancelled' || order['status'] === 'Partially Cancelled' || order['status'] === 'Error') {
                        status = 'canceled';
                    }
                    else if (order['status'] === 'Fully Matched' || order['status'] === 'Partially Matched') {
                        status = 'closed';
                    }
                    var price = this.safeFloat(order, 'price') / multiplier;
                    var amount = this.safeFloat(order, 'volume') / multiplier;
                    var remaining = this.safeFloat(order, 'openVolume', 0.0) / multiplier;
                    var filled = amount - remaining;
                    var cost = price * amount;
                    var trades = this.parseMyTrades(order['trades'], market);
                    var result = {
                        'info': order,
                        'id': order['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': type,
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'trades': trades,
                        'fee': undefined,
                    };
                    return result;
                };
                btcmarkets.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ids, response, numOrders, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    ids = [parseInt(id)];
                                    return [4, this.privatePostOrderDetail(this.extend({
                                            'orderIds': ids,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    numOrders = response['orders'].length;
                                    if (numOrders < 1)
                                        throw new OrderNotFound(this.id + ' No matching order found: ' + id);
                                    order = response['orders'][0];
                                    return [2, this.parseOrder(order)];
                            }
                        });
                    });
                };
                btcmarkets.prototype.prepareHistoryRequest = function (market, since, limit) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request;
                        return __generator(this, function (_a) {
                            request = this.ordered({
                                'currency': market['quote'],
                                'instrument': market['base'],
                            });
                            if (typeof limit !== 'undefined')
                                request['limit'] = limit;
                            else
                                request['limit'] = 100;
                            if (typeof since !== 'undefined')
                                request['since'] = since;
                            else
                                request['since'] = 0;
                            return [2, request];
                        });
                    });
                };
                btcmarkets.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new NotSupported(this.id + ': fetchOrders requires a `symbol` parameter.');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = this.prepareHistoryRequest(market, since, limit);
                                    return [4, this.privatePostOrderHistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response['orders'], market)];
                            }
                        });
                    });
                };
                btcmarkets.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new NotSupported(this.id + ': fetchOpenOrders requires a `symbol` parameter.');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = this.prepareHistoryRequest(market, since, limit);
                                    return [4, this.privatePostOrderOpen(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response['orders'], market)];
                            }
                        });
                    });
                };
                btcmarkets.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.filterBy(orders, 'status', 'closed')];
                            }
                        });
                    });
                };
                btcmarkets.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new NotSupported(this.id + ': fetchMyTrades requires a `symbol` parameter.');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = this.prepareHistoryRequest(market, since, limit);
                                    return [4, this.privatePostOrderTradeHistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseMyTrades(response['trades'], market)];
                            }
                        });
                    });
                };
                btcmarkets.prototype.nonce = function () {
                    return this.milliseconds();
                };
                btcmarkets.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var uri = '/' + this.implodeParams(path, params);
                    var url = this.urls['api'][api] + uri;
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var auth = uri + "\n" + nonce + "\n";
                        headers = {
                            'Content-Type': 'application/json',
                            'apikey': this.apiKey,
                            'timestamp': nonce,
                        };
                        if (method === 'POST') {
                            body = this.json(params);
                            auth += body;
                        }
                        var secret = this.base64ToBinary(this.secret);
                        var signature = this.hmac(this.encode(auth), secret, 'sha512', 'base64');
                        headers['signature'] = this.decode(signature);
                    }
                    else {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                btcmarkets.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (body.length < 2)
                        return;
                    if (body[0] === '{') {
                        var response = JSON.parse(body);
                        if ('success' in response) {
                            if (!response['success']) {
                                var error = this.safeString(response, 'errorCode');
                                var message = this.id + ' ' + this.json(response);
                                if (error in this.exceptions) {
                                    var ExceptionClass = this.exceptions[error];
                                    throw new ExceptionClass(message);
                                }
                                else {
                                    throw new ExchangeError(message);
                                }
                            }
                        }
                    }
                };
                btcmarkets.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                return btcmarkets;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 46: [function (require, module, exports) {
            'use strict';
            var coinegg = require('./coinegg.js');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(btctradeim, _super);
                function btctradeim() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                btctradeim.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'btctradeim',
                        'name': 'BtcTrade.im',
                        'countries': 'HK',
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/36770531-c2142444-1c5b-11e8-91e2-a4d90dc85fe8.jpg',
                            'api': {
                                'web': 'https://www.btctrade.im/coin',
                                'rest': 'https://api.btctrade.im/api/v1',
                            },
                            'www': 'https://www.btctrade.im',
                            'doc': 'https://www.btctrade.im/help.api.html',
                            'fees': 'https://www.btctrade.im/spend.price.html',
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.2 / 100,
                                'taker': 0.2 / 100,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.001,
                                },
                            },
                        },
                    });
                };
                btctradeim.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, data, code, message;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (api === 'web') {
                                        return [2, response];
                                    }
                                    data = this.safeValue(response, 'data');
                                    if (data) {
                                        code = this.safeString(response, 'code');
                                        if (code !== '0') {
                                            message = this.safeString(response, 'msg', 'Error');
                                            throw new ExchangeError(message);
                                        }
                                        return [2, data];
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return btctradeim;
            }(coinegg));
        }, { "./base/errors": 10, "./coinegg.js": 57 }], 47: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(btctradeua, _super);
                function btctradeua() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                btctradeua.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'btctradeua',
                        'name': 'BTC Trade UA',
                        'countries': 'UA',
                        'rateLimit': 3000,
                        'has': {
                            'CORS': true,
                            'createMarketOrder': false,
                            'fetchOpenOrders': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg',
                            'api': 'https://btc-trade.com.ua/api',
                            'www': 'https://btc-trade.com.ua',
                            'doc': 'https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'deals/{symbol}',
                                    'trades/sell/{symbol}',
                                    'trades/buy/{symbol}',
                                    'japan_stat/high/{symbol}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'auth',
                                    'ask/{symbol}',
                                    'balance',
                                    'bid/{symbol}',
                                    'buy/{symbol}',
                                    'my_orders/{symbol}',
                                    'order/status/{id}',
                                    'remove/order/{id}',
                                    'sell/{symbol}',
                                ],
                            },
                        },
                        'markets': {
                            'BCH/UAH': { 'id': 'bch_uah', 'symbol': 'BCH/UAH', 'base': 'BCH', 'quote': 'UAH' },
                            'BTC/UAH': { 'id': 'btc_uah', 'symbol': 'BTC/UAH', 'base': 'BTC', 'quote': 'UAH', 'precision': { 'price': 1 }, 'limits': { 'amount': { 'min': 0.0000000001 } } },
                            'DASH/BTC': { 'id': 'dash_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
                            'DASH/UAH': { 'id': 'dash_uah', 'symbol': 'DASH/UAH', 'base': 'DASH', 'quote': 'UAH' },
                            'DOGE/BTC': { 'id': 'doge_btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC' },
                            'DOGE/UAH': { 'id': 'doge_uah', 'symbol': 'DOGE/UAH', 'base': 'DOGE', 'quote': 'UAH' },
                            'ETH/UAH': { 'id': 'eth_uah', 'symbol': 'ETH/UAH', 'base': 'ETH', 'quote': 'UAH' },
                            'ITI/UAH': { 'id': 'iti_uah', 'symbol': 'ITI/UAH', 'base': 'ITI', 'quote': 'UAH' },
                            'KRB/UAH': { 'id': 'krb_uah', 'symbol': 'KRB/UAH', 'base': 'KRB', 'quote': 'UAH' },
                            'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                            'LTC/UAH': { 'id': 'ltc_uah', 'symbol': 'LTC/UAH', 'base': 'LTC', 'quote': 'UAH' },
                            'NVC/BTC': { 'id': 'nvc_btc', 'symbol': 'NVC/BTC', 'base': 'NVC', 'quote': 'BTC' },
                            'NVC/UAH': { 'id': 'nvc_uah', 'symbol': 'NVC/UAH', 'base': 'NVC', 'quote': 'UAH' },
                            'PPC/BTC': { 'id': 'ppc_btc', 'symbol': 'PPC/BTC', 'base': 'PPC', 'quote': 'BTC' },
                            'SIB/UAH': { 'id': 'sib_uah', 'symbol': 'SIB/UAH', 'base': 'SIB', 'quote': 'UAH' },
                            'XMR/UAH': { 'id': 'xmr_uah', 'symbol': 'XMR/UAH', 'base': 'XMR', 'quote': 'UAH' },
                            'ZEC/UAH': { 'id': 'zec_uah', 'symbol': 'ZEC/UAH', 'base': 'ZEC', 'quote': 'UAH' },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.1 / 100,
                                'taker': 0.1 / 100,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.0006,
                                    'LTC': 0.01,
                                    'NVC': 0.01,
                                    'DOGE': 10,
                                },
                            },
                        },
                    });
                };
                btctradeua.prototype.signIn = function () {
                    return this.privatePostAuth();
                };
                btctradeua.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, accounts, b, account, currency, balance;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostBalance()];
                                case 1:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    if ('accounts' in response) {
                                        accounts = response['accounts'];
                                        for (b = 0; b < accounts.length; b++) {
                                            account = accounts[b];
                                            currency = account['currency'];
                                            balance = parseFloat(account['balance']);
                                            result[currency] = {
                                                'free': balance,
                                                'used': 0.0,
                                                'total': balance,
                                            };
                                        }
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                btctradeua.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, bids, asks, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradesBuySymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 1:
                                    bids = _a.sent();
                                    return [4, this.publicGetTradesSellSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    asks = _a.sent();
                                    orderbook = {
                                        'bids': [],
                                        'asks': [],
                                    };
                                    if (bids) {
                                        if ('list' in bids)
                                            orderbook['bids'] = bids['list'];
                                    }
                                    if (asks) {
                                        if ('list' in asks)
                                            orderbook['asks'] = asks['list'];
                                    }
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price', 'currency_trade')];
                            }
                        });
                    });
                };
                btctradeua.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, ticker, timestamp, result, tickerLength, start, t, candle, last;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetJapanStatHighSymbol(this.extend({
                                        'symbol': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    ticker = response['trades'];
                                    timestamp = this.milliseconds();
                                    result = {
                                        'symbol': symbol,
                                        'timestamp': timestamp,
                                        'datetime': this.iso8601(timestamp),
                                        'high': undefined,
                                        'low': undefined,
                                        'bid': undefined,
                                        'ask': undefined,
                                        'vwap': undefined,
                                        'open': undefined,
                                        'close': undefined,
                                        'last': undefined,
                                        'previousClose': undefined,
                                        'change': undefined,
                                        'percentage': undefined,
                                        'average': undefined,
                                        'baseVolume': undefined,
                                        'quoteVolume': undefined,
                                        'info': ticker,
                                    };
                                    tickerLength = ticker.length;
                                    if (tickerLength > 0) {
                                        start = Math.max(tickerLength - 48, 0);
                                        for (t = start; t < ticker.length; t++) {
                                            candle = ticker[t];
                                            if (typeof result['open'] === 'undefined')
                                                result['open'] = candle[1];
                                            if ((typeof result['high'] === 'undefined') || (result['high'] < candle[2]))
                                                result['high'] = candle[2];
                                            if ((typeof result['low'] === 'undefined') || (result['low'] > candle[3]))
                                                result['low'] = candle[3];
                                            if (typeof result['baseVolume'] === 'undefined')
                                                result['baseVolume'] = -candle[5];
                                            else
                                                result['baseVolume'] -= candle[5];
                                        }
                                        last = tickerLength - 1;
                                        result['last'] = ticker[last][4];
                                        result['close'] = result['last'];
                                        result['baseVolume'] = -1 * result['baseVolume'];
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                btctradeua.prototype.convertCyrillicMonthNameToString = function (cyrillic) {
                    var months = {
                        'января': '01',
                        'февраля': '02',
                        'марта': '03',
                        'апреля': '04',
                        'мая': '05',
                        'июня': '06',
                        'июля': '07',
                        'августа': '08',
                        'сентября': '09',
                        'октября': '10',
                        'ноября': '11',
                        'декабря': '12',
                    };
                    var month = undefined;
                    if (cyrillic in months)
                        month = months[cyrillic];
                    return month;
                };
                btctradeua.prototype.parseCyrillicDatetime = function (cyrillic) {
                    var parts = cyrillic.split(' ');
                    var day = parts[0];
                    var month = this.convertCyrillicMonthNameToString(parts[1]);
                    if (!month)
                        throw new ExchangeError(this.id + ' parseTrade() undefined month name: ' + cyrillic);
                    var year = parts[2];
                    var hms = parts[4];
                    var hmsLength = hms.length;
                    if (hmsLength === 7) {
                        hms = '0' + hms;
                    }
                    if (day.length === 1) {
                        day = '0' + day;
                    }
                    var ymd = [year, month, day].join('-');
                    var ymdhms = ymd + 'T' + hms;
                    var timestamp = this.parse8601(ymdhms);
                    var md = [month, day].join('');
                    md = parseInt(md);
                    if (md < 325 || md > 1028)
                        return timestamp - 7200000;
                    return timestamp - 10800000;
                };
                btctradeua.prototype.parseTrade = function (trade, market) {
                    var timestamp = this.parseCyrillicDatetime(trade['pub_date']);
                    return {
                        'id': trade['id'].toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': 'limit',
                        'side': trade['type'],
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amnt_trade']),
                    };
                };
                btctradeua.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, trades, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetDealsSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    trades = [];
                                    for (i = 0; i < response.length; i++) {
                                        if (response[i]['id'] % 2) {
                                            trades.push(response[i]);
                                        }
                                    }
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                btctradeua.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, order;
                        return __generator(this, function (_a) {
                            if (type === 'market')
                                throw new ExchangeError(this.id + ' allows limit orders only');
                            market = this.market(symbol);
                            method = 'privatePost' + this.capitalize(side) + 'Id';
                            order = {
                                'count': amount,
                                'currency1': market['quote'],
                                'currency': market['base'],
                                'price': price,
                            };
                            return [2, this[method](this.extend(order, params))];
                        });
                    });
                };
                btctradeua.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostRemoveOrderId({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                btctradeua.prototype.parseOrder = function (trade, market) {
                    var timestamp = this.milliseconds;
                    return {
                        'id': trade['id'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': 'open',
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['type'],
                        'price': trade['price'],
                        'amount': trade['amnt_trade'],
                        'filled': 0,
                        'remaining': trade['amnt_trade'],
                        'trades': undefined,
                        'info': trade,
                    };
                };
                btctradeua.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOpenOrders requires a symbol param');
                                    market = this.market(symbol);
                                    return [4, this.privatePostMyOrdersSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    orders = response['your_open_orders'];
                                    return [2, this.parseOrders(orders, market, since, limit)];
                            }
                        });
                    });
                };
                btctradeua.prototype.nonce = function () {
                    return this.milliseconds();
                };
                btctradeua.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += this.implodeParams(path, query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({
                            'out_order_id': nonce,
                            'nonce': nonce,
                        }, query));
                        var auth = body + this.secret;
                        headers = {
                            'public-key': this.apiKey,
                            'api-sign': this.hash(this.encode(auth), 'sha256'),
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return btctradeua;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 48: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(btcturk, _super);
                function btcturk() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                btcturk.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'btcturk',
                        'name': 'BTCTurk',
                        'countries': 'TR',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': true,
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                        },
                        'timeframes': {
                            '1d': '1d',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27992709-18e15646-64a3-11e7-9fa2-b0950ec7712f.jpg',
                            'api': 'https://www.btcturk.com/api',
                            'www': 'https://www.btcturk.com',
                            'doc': 'https://github.com/BTCTrader/broker-api-docs',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'ohlcdata',
                                    'orderbook',
                                    'ticker',
                                    'trades',
                                ],
                            },
                            'private': {
                                'get': [
                                    'balance',
                                    'openOrders',
                                    'userTransactions',
                                ],
                                'post': [
                                    'exchange',
                                    'cancelOrder',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/TRY': { 'id': 'BTCTRY', 'symbol': 'BTC/TRY', 'base': 'BTC', 'quote': 'TRY', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
                            'ETH/TRY': { 'id': 'ETHTRY', 'symbol': 'ETH/TRY', 'base': 'ETH', 'quote': 'TRY', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
                            'XRP/TRY': { 'id': 'XRPTRY', 'symbol': 'XRP/TRY', 'base': 'XRP', 'quote': 'TRY', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
                            'ETH/BTC': { 'id': 'ETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
                        },
                    });
                };
                btcturk.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, base, quote, symbol, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetBalance()];
                                case 1:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    base = {
                                        'free': response['bitcoin_available'],
                                        'used': response['bitcoin_reserved'],
                                        'total': response['bitcoin_balance'],
                                    };
                                    quote = {
                                        'free': response['money_available'],
                                        'used': response['money_reserved'],
                                        'total': response['money_balance'],
                                    };
                                    symbol = this.symbols[0];
                                    market = this.markets[symbol];
                                    result[market['base']] = base;
                                    result[market['quote']] = quote;
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                btcturk.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetOrderbook(this.extend({
                                            'pairSymbol': market['id'],
                                        }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    timestamp = parseInt(orderbook['timestamp'] * 1000);
                                    return [2, this.parseOrderBook(orderbook, timestamp)];
                            }
                        });
                    });
                };
                btcturk.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = parseInt(ticker['timestamp']) * 1000;
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['bid']),
                        'ask': parseFloat(ticker['ask']),
                        'vwap': undefined,
                        'open': parseFloat(ticker['open']),
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': parseFloat(ticker['average']),
                        'baseVolume': parseFloat(ticker['volume']),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                btcturk.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result, i, ticker, symbol, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    result = {};
                                    for (i = 0; i < tickers.length; i++) {
                                        ticker = tickers[i];
                                        symbol = ticker['pair'];
                                        market = undefined;
                                        if (symbol in this.markets_by_id) {
                                            market = this.markets_by_id[symbol];
                                            symbol = market['symbol'];
                                        }
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                btcturk.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.fetchTickers()];
                                case 2:
                                    tickers = _a.sent();
                                    result = undefined;
                                    if (symbol in tickers)
                                        result = tickers[symbol];
                                    return [2, result];
                            }
                        });
                    });
                };
                btcturk.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['date'] * 1000;
                    return {
                        'id': trade['tid'],
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                btcturk.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrades(this.extend({
                                            'pairSymbol': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                btcturk.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1d'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var timestamp = this.parse8601(ohlcv['Time']);
                    return [
                        timestamp,
                        ohlcv['Open'],
                        ohlcv['High'],
                        ohlcv['Low'],
                        ohlcv['Close'],
                        ohlcv['Volume'],
                    ];
                };
                btcturk.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1d'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {};
                                    if (typeof limit !== 'undefined')
                                        request['last'] = limit;
                                    return [4, this.publicGetOhlcdata(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                btcturk.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'PairSymbol': this.marketId(symbol),
                                        'OrderType': (side === 'buy') ? 0 : 1,
                                        'OrderMethod': (type === 'market') ? 1 : 0,
                                    };
                                    if (type === 'market') {
                                        if (!('Total' in params))
                                            throw new ExchangeError(this.id + ' createOrder requires the "Total" extra parameter for market orders (amount and price are both ignored)');
                                    }
                                    else {
                                        order['Price'] = price;
                                        order['Amount'] = amount;
                                    }
                                    return [4, this.privatePostExchange(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                btcturk.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancelOrder({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                btcturk.prototype.nonce = function () {
                    return this.milliseconds();
                };
                btcturk.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    if (this.id === 'btctrader')
                        throw new ExchangeError(this.id + ' is an abstract base API for BTCExchange, BTCTurk');
                    var url = this.urls['api'] + '/' + path;
                    if (api === 'public') {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        body = this.urlencode(params);
                        var secret = this.base64ToBinary(this.secret);
                        var auth = this.apiKey + nonce;
                        headers = {
                            'X-PCK': this.apiKey,
                            'X-Stamp': nonce,
                            'X-Signature': this.stringToBase64(this.hmac(this.encode(auth), secret, 'sha256', 'binary')),
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return btcturk;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 49: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(btcx, _super);
                function btcx() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                btcx.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'btcx',
                        'name': 'BTCX',
                        'countries': ['IS', 'US', 'EU'],
                        'rateLimit': 1500,
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766385-9fdcc98c-5ed6-11e7-8f14-66d5e5cd47e6.jpg',
                            'api': 'https://btc-x.is/api',
                            'www': 'https://btc-x.is',
                            'doc': 'https://btc-x.is/custom/api-document.html',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'depth/{id}/{limit}',
                                    'ticker/{id}',
                                    'trade/{id}/{limit}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balance',
                                    'cancel',
                                    'history',
                                    'order',
                                    'redeem',
                                    'trade',
                                    'withdraw',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/USD': { 'id': 'btc/usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                            'BTC/EUR': { 'id': 'btc/eur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                        },
                    });
                };
                btcx.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, currencies, c, currency, uppercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostBalance()];
                                case 1:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    currencies = Object.keys(balances);
                                    for (c = 0; c < currencies.length; c++) {
                                        currency = currencies[c];
                                        uppercase = currency.toUpperCase();
                                        account = {
                                            'free': balances[currency],
                                            'used': 0.0,
                                            'total': balances[currency],
                                        };
                                        result[uppercase] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                btcx.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    request = {
                                        'id': this.marketId(symbol),
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetDepthIdLimit(this.extend(request, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price', 'amount')];
                            }
                        });
                    });
                };
                btcx.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTickerId(this.extend({
                                        'id': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = ticker['time'] * 1000;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['sell']),
                                            'ask': parseFloat(ticker['buy']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': undefined,
                                            'quoteVolume': parseFloat(ticker['volume']),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                btcx.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(trade['date']) * 1000;
                    var side = (trade['type'] === 'ask') ? 'sell' : 'buy';
                    return {
                        'id': trade['id'],
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': side,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                btcx.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradeIdLimit(this.extend({
                                            'id': market['id'],
                                            'limit': 1000,
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                btcx.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostTrade(this.extend({
                                        'type': side.toUpperCase(),
                                        'market': this.marketId(symbol),
                                        'amount': amount,
                                        'price': price,
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['order']['id'],
                                        }];
                            }
                        });
                    });
                };
                btcx.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancel({ 'order': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                btcx.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/';
                    if (api === 'public') {
                        url += this.implodeParams(path, params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        url += api;
                        body = this.urlencode(this.extend({
                            'Method': path.toUpperCase(),
                            'Nonce': nonce,
                        }, params));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Key': this.apiKey,
                            'Signature': this.hmac(this.encode(body), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                btcx.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('error' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return btcx;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 50: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(bxinth, _super);
                function bxinth() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                bxinth.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'bxinth',
                        'name': 'BX.in.th',
                        'countries': 'TH',
                        'rateLimit': 1500,
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                            'fetchOpenOrders': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766412-567b1eb4-5ed7-11e7-94a8-ff6a3884f6c5.jpg',
                            'api': 'https://bx.in.th/api',
                            'www': 'https://bx.in.th',
                            'doc': 'https://bx.in.th/info/api',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    '',
                                    'options',
                                    'optionbook',
                                    'orderbook',
                                    'pairing',
                                    'trade',
                                    'tradehistory',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balance',
                                    'biller',
                                    'billgroup',
                                    'billpay',
                                    'cancel',
                                    'deposit',
                                    'getorders',
                                    'history',
                                    'option-issue',
                                    'option-bid',
                                    'option-sell',
                                    'option-myissue',
                                    'option-mybid',
                                    'option-myoptions',
                                    'option-exercise',
                                    'option-cancel',
                                    'option-history',
                                    'order',
                                    'withdrawal',
                                    'withdrawal-history',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'taker': 0.25 / 100,
                                'maker': 0.25 / 100,
                            },
                        },
                    });
                };
                bxinth.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, keys, result, p, market, id, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetPairing()];
                                case 1:
                                    markets = _a.sent();
                                    keys = Object.keys(markets);
                                    result = [];
                                    for (p = 0; p < keys.length; p++) {
                                        market = markets[keys[p]];
                                        id = market['pairing_id'].toString();
                                        base = market['secondary_currency'];
                                        quote = market['primary_currency'];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bxinth.prototype.commonCurrencyCode = function (currency) {
                    if (currency === 'DAS')
                        return 'DASH';
                    if (currency === 'DOG')
                        return 'DOGE';
                    return currency;
                };
                bxinth.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balance, result, currencies, c, currency, code, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostBalance()];
                                case 2:
                                    response = _a.sent();
                                    balance = response['balance'];
                                    result = { 'info': balance };
                                    currencies = Object.keys(balance);
                                    for (c = 0; c < currencies.length; c++) {
                                        currency = currencies[c];
                                        code = this.commonCurrencyCode(currency);
                                        account = {
                                            'free': parseFloat(balance[currency]['available']),
                                            'used': 0.0,
                                            'total': parseFloat(balance[currency]['total']),
                                        };
                                        account['used'] = account['total'] - account['free'];
                                        result[code] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                bxinth.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderbook(this.extend({
                                            'pairing': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                bxinth.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': undefined,
                        'low': undefined,
                        'bid': parseFloat(ticker['orderbook']['bids']['highbid']),
                        'ask': parseFloat(ticker['orderbook']['asks']['highbid']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last_price']),
                        'change': parseFloat(ticker['change']),
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['volume_24hours']),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                bxinth.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result, ids, i, id, ticker, market, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGet(params)];
                                case 2:
                                    tickers = _a.sent();
                                    result = {};
                                    ids = Object.keys(tickers);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        ticker = tickers[id];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                bxinth.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, tickers, id, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGet(this.extend({
                                            'pairing': market['id'],
                                        }, params))];
                                case 2:
                                    tickers = _a.sent();
                                    id = market['id'].toString();
                                    ticker = tickers[id];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                bxinth.prototype.parseTrade = function (trade, market) {
                    var timestamp = this.parse8601(trade['trade_date']);
                    return {
                        'id': trade['trade_id'],
                        'info': trade,
                        'order': trade['order_id'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['trade_type'],
                        'price': parseFloat(trade['rate']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                bxinth.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrade(this.extend({
                                            'pairing': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['trades'], market, since, limit)];
                            }
                        });
                    });
                };
                bxinth.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrder(this.extend({
                                            'pairing': this.marketId(symbol),
                                            'type': side,
                                            'amount': amount,
                                            'rate': price,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['order_id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                bxinth.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var pairing;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    pairing = undefined;
                                    return [4, this.privatePostCancel({
                                            'order_id': id,
                                            'pairing': pairing,
                                        })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                bxinth.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var side, symbol, marketId, timestamp, price, amount;
                        return __generator(this, function (_a) {
                            side = this.safeString(order, 'order_type');
                            symbol = undefined;
                            if (typeof market === 'undefined') {
                                marketId = this.safeString(order, 'pairing_id');
                                if (typeof marketId !== 'undefined')
                                    if (marketId in this.markets_by_id)
                                        market = this.markets_by_id[marketId];
                            }
                            if (typeof market !== 'undefined')
                                symbol = market['symbol'];
                            timestamp = this.parse8601(order['date']);
                            price = this.safeFloat(order, 'rate');
                            amount = this.safeFloat(order, 'amount');
                            return [2, {
                                    'info': order,
                                    'id': order['order_id'],
                                    'timestamp': timestamp,
                                    'datetime': this.iso8601(timestamp),
                                    'symbol': symbol,
                                    'type': 'limit',
                                    'side': side,
                                    'price': price,
                                    'amount': amount,
                                }];
                        });
                    });
                };
                bxinth.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    market = undefined;
                                    if (typeof symbol !== 'undefined') {
                                        market = this.market(symbol);
                                        request['pairing'] = market['id'];
                                    }
                                    response = this.privatePostGetorders(this.extend(request, params));
                                    orders = this.parseOrders(response['orders'], market, since, limit);
                                    return [2, this.filterBySymbol(orders, symbol)];
                            }
                        });
                    });
                };
                bxinth.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/';
                    if (path)
                        url += path + '/';
                    if (Object.keys(params).length)
                        url += '?' + this.urlencode(params);
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var auth = this.apiKey + nonce.toString() + this.secret;
                        var signature = this.hash(this.encode(auth), 'sha256');
                        body = this.urlencode(this.extend({
                            'key': this.apiKey,
                            'nonce': nonce,
                            'signature': signature,
                        }, params));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                bxinth.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (api === 'public')
                                        return [2, response];
                                    if ('success' in response)
                                        if (response['success'])
                                            return [2, response];
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                return bxinth;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 51: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(ccex, _super);
                function ccex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ccex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'ccex',
                        'name': 'C-CEX',
                        'countries': ['DE', 'EU'],
                        'rateLimit': 1500,
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                            'fetchOrderBooks': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766433-16881f90-5ed8-11e7-92f8-3d92cc747a6c.jpg',
                            'api': {
                                'tickers': 'https://c-cex.com/t',
                                'public': 'https://c-cex.com/t/api_pub.html',
                                'private': 'https://c-cex.com/t/api.html',
                            },
                            'www': 'https://c-cex.com',
                            'doc': 'https://c-cex.com/?id=api',
                        },
                        'api': {
                            'tickers': {
                                'get': [
                                    'coinnames',
                                    '{market}',
                                    'pairs',
                                    'prices',
                                    'volume_{coin}',
                                ],
                            },
                            'public': {
                                'get': [
                                    'balancedistribution',
                                    'markethistory',
                                    'markets',
                                    'marketsummaries',
                                    'orderbook',
                                    'fullorderbook',
                                ],
                            },
                            'private': {
                                'get': [
                                    'buylimit',
                                    'cancel',
                                    'getbalance',
                                    'getbalances',
                                    'getopenorders',
                                    'getorder',
                                    'getorderhistory',
                                    'mytrades',
                                    'selllimit',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'taker': 0.2 / 100,
                                'maker': 0.2 / 100,
                            },
                        },
                    });
                };
                ccex.prototype.commonCurrencyCode = function (currency) {
                    if (currency === 'IOT')
                        return 'IoTcoin';
                    if (currency === 'BLC')
                        return 'Cryptobullcoin';
                    if (currency === 'XID')
                        return 'InternationalDiamond';
                    return currency;
                };
                ccex.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarkets()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets['result'].length; p++) {
                                        market = markets['result'][p];
                                        id = market['MarketName'];
                                        base = market['MarketCurrency'];
                                        quote = market['BaseCurrency'];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                ccex.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, code, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetGetbalances()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['result'];
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        code = balance['Currency'];
                                        currency = this.commonCurrencyCode(code);
                                        account = {
                                            'free': balance['Available'],
                                            'used': balance['Pending'],
                                            'total': balance['Balance'],
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                ccex.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'market': this.marketId(symbol),
                                        'type': 'both',
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['depth'] = limit;
                                    return [4, this.publicGetOrderbook(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['result'];
                                    return [2, this.parseOrderBook(orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity')];
                            }
                        });
                    });
                };
                ccex.prototype.fetchOrderBooks = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbooks, response, types, i, type, bidasks, bidasksByMarketId, marketIds, j, marketId, symbol, side, market, _a, base, quote, invertedId, market, result, keys, k, key;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _c.sent();
                                    orderbooks = {};
                                    return [4, this.publicGetFullorderbook()];
                                case 2:
                                    response = _c.sent();
                                    types = Object.keys(response['result']);
                                    for (i = 0; i < types.length; i++) {
                                        type = types[i];
                                        bidasks = response['result'][type];
                                        bidasksByMarketId = this.groupBy(bidasks, 'Market');
                                        marketIds = Object.keys(bidasksByMarketId);
                                        for (j = 0; j < marketIds.length; j++) {
                                            marketId = marketIds[j];
                                            symbol = marketId.toUpperCase();
                                            side = type;
                                            if (symbol in this.markets_by_id) {
                                                market = this.markets_by_id[symbol];
                                                symbol = market['symbol'];
                                            }
                                            else {
                                                _a = __read(symbol.split('-'), 2), base = _a[0], quote = _a[1];
                                                invertedId = quote + '-' + base;
                                                if (invertedId in this.markets_by_id) {
                                                    market = this.markets_by_id[invertedId];
                                                    symbol = market['symbol'];
                                                }
                                            }
                                            if (!(symbol in orderbooks))
                                                orderbooks[symbol] = {};
                                            orderbooks[symbol][side] = bidasksByMarketId[marketId];
                                        }
                                    }
                                    result = {};
                                    keys = Object.keys(orderbooks);
                                    for (k = 0; k < keys.length; k++) {
                                        key = keys[k];
                                        result[key] = this.parseOrderBook(orderbooks[key], undefined, 'buy', 'sell', 'Rate', 'Quantity');
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                ccex.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['updated'] * 1000;
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['buy']),
                        'ask': parseFloat(ticker['sell']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['lastprice']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': parseFloat(ticker['avg']),
                        'baseVolume': undefined,
                        'quoteVolume': this.safeFloat(ticker, 'buysupport'),
                        'info': ticker,
                    };
                };
                ccex.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result, ids, i, id, ticker, uppercase, market, symbol, _a, base, quote;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _c.sent();
                                    return [4, this.tickersGetPrices(params)];
                                case 2:
                                    tickers = _c.sent();
                                    result = { 'info': tickers };
                                    ids = Object.keys(tickers);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        ticker = tickers[id];
                                        uppercase = id.toUpperCase();
                                        market = undefined;
                                        symbol = undefined;
                                        if (uppercase in this.markets_by_id) {
                                            market = this.markets_by_id[uppercase];
                                            symbol = market['symbol'];
                                        }
                                        else {
                                            _a = __read(uppercase.split('-'), 2), base = _a[0], quote = _a[1];
                                            base = this.commonCurrencyCode(base);
                                            quote = this.commonCurrencyCode(quote);
                                            symbol = base + '/' + quote;
                                        }
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                ccex.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.tickersGetMarket(this.extend({
                                            'market': market['id'].toLowerCase(),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['ticker'];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                ccex.prototype.parseTrade = function (trade, market) {
                    var timestamp = this.parse8601(trade['TimeStamp']);
                    return {
                        'id': trade['Id'].toString(),
                        'info': trade,
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['OrderType'].toLowerCase(),
                        'price': trade['Price'],
                        'amount': trade['Quantity'],
                    };
                };
                ccex.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarkethistory(this.extend({
                                            'market': market['id'],
                                            'type': 'both',
                                            'depth': 100,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['result'], market, since, limit)];
                            }
                        });
                    });
                };
                ccex.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = 'privateGet' + this.capitalize(side) + type;
                                    return [4, this[method](this.extend({
                                            'market': this.marketId(symbol),
                                            'quantity': amount,
                                            'rate': price,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['result']['uuid'],
                                        }];
                            }
                        });
                    });
                };
                ccex.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetCancel({ 'uuid': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                ccex.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var query = this.keysort(this.extend({
                            'a': path,
                            'apikey': this.apiKey,
                            'nonce': nonce,
                        }, params));
                        url += '?' + this.urlencode(query);
                        headers = { 'apisign': this.hmac(this.encode(url), this.encode(this.secret), 'sha512') };
                    }
                    else if (api === 'public') {
                        url += '?' + this.urlencode(this.extend({
                            'a': 'get' + path,
                        }, params));
                    }
                    else {
                        url += '/' + this.implodeParams(path, params) + '.json';
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                ccex.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (api === 'tickers')
                                        return [2, response];
                                    if ('success' in response)
                                        if (response['success'])
                                            return [2, response];
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                return ccex;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 52: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InvalidOrder = _a.InvalidOrder;
            module.exports = (function (_super) {
                __extends(cex, _super);
                function cex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                cex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'cex',
                        'name': 'CEX.IO',
                        'countries': ['GB', 'EU', 'CY', 'RU'],
                        'rateLimit': 1500,
                        'has': {
                            'CORS': true,
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                            'fetchOpenOrders': true,
                            'fetchOrders': true,
                        },
                        'timeframes': {
                            '1m': '1m',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg',
                            'api': 'https://cex.io/api',
                            'www': 'https://cex.io',
                            'doc': 'https://cex.io/cex-api',
                            'fees': [
                                'https://cex.io/fee-schedule',
                                'https://cex.io/limits-commissions',
                            ],
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': true,
                            'uid': true,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'currency_limits/',
                                    'last_price/{pair}/',
                                    'last_prices/{currencies}/',
                                    'ohlcv/hd/{yyyymmdd}/{pair}',
                                    'order_book/{pair}/',
                                    'ticker/{pair}/',
                                    'tickers/{currencies}/',
                                    'trade_history/{pair}/',
                                ],
                                'post': [
                                    'convert/{pair}',
                                    'price_stats/{pair}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'active_orders_status/',
                                    'archived_orders/{pair}/',
                                    'balance/',
                                    'cancel_order/',
                                    'cancel_orders/{pair}/',
                                    'cancel_replace_order/{pair}/',
                                    'close_position/{pair}/',
                                    'get_address/',
                                    'get_myfee/',
                                    'get_order/',
                                    'get_order_tx/',
                                    'open_orders/{pair}/',
                                    'open_orders/',
                                    'open_position/{pair}/',
                                    'open_positions/{pair}/',
                                    'place_order/{pair}/',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.16 / 100,
                                'taker': 0.25 / 100,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.001,
                                    'ETH': 0.01,
                                    'BCH': 0.001,
                                    'DASH': 0.01,
                                    'BTG': 0.001,
                                    'ZEC': 0.001,
                                    'XRP': 0.02,
                                },
                                'deposit': {
                                    'BTC': 0.0,
                                    'ETH': 0.0,
                                    'BCH': 0.0,
                                    'DASH': 0.0,
                                    'BTG': 0.0,
                                    'ZEC': 0.0,
                                    'XRP': 0.0,
                                    'XLM': 0.0,
                                },
                            },
                        },
                    });
                };
                cex.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, symbol, _a, base, quote;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetCurrencyLimits()];
                                case 1:
                                    markets = _c.sent();
                                    result = [];
                                    for (p = 0; p < markets['data']['pairs'].length; p++) {
                                        market = markets['data']['pairs'][p];
                                        id = market['symbol1'] + '/' + market['symbol2'];
                                        symbol = id;
                                        _a = __read(symbol.split('/'), 2), base = _a[0], quote = _a[1];
                                        result.push({
                                            'id': id,
                                            'info': market,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'lot': market['minLotSize'],
                                            'precision': {
                                                'price': this.precisionFromString(market['minPrice']),
                                                'amount': -1 * Math.log10(market['minLotSize']),
                                            },
                                            'limits': {
                                                'amount': {
                                                    'min': market['minLotSize'],
                                                    'max': market['maxLotSize'],
                                                },
                                                'price': {
                                                    'min': parseFloat(market['minPrice']),
                                                    'max': parseFloat(market['maxPrice']),
                                                },
                                                'cost': {
                                                    'min': market['minLotSizeS2'],
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cex.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, ommited, balances, currencies, i, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostBalance()];
                                case 2:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    ommited = ['username', 'timestamp'];
                                    balances = this.omit(response, ommited);
                                    currencies = Object.keys(balances);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        if (currency in balances) {
                                            account = {
                                                'free': this.safeFloat(balances[currency], 'available', 0.0),
                                                'used': this.safeFloat(balances[currency], 'orders', 0.0),
                                                'total': 0.0,
                                            };
                                            account['total'] = this.sum(account['free'], account['used']);
                                            result[currency] = account;
                                        }
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                cex.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderBookPair(this.extend({
                                            'pair': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = orderbook['timestamp'] * 1000;
                                    return [2, this.parseOrderBook(orderbook, timestamp)];
                            }
                        });
                    });
                };
                cex.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv[0] * 1000,
                        ohlcv[1],
                        ohlcv[2],
                        ohlcv[3],
                        ohlcv[4],
                        ohlcv[5],
                    ];
                };
                cex.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ymd, request, response, key, ohlcvs;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    if (!since)
                                        since = this.milliseconds() - 86400000;
                                    ymd = this.ymd(since);
                                    ymd = ymd.split('-');
                                    ymd = ymd.join('');
                                    request = {
                                        'pair': market['id'],
                                        'yyyymmdd': ymd,
                                    };
                                    return [4, this.publicGetOhlcvHdYyyymmddPair(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    key = 'data' + this.timeframes[timeframe];
                                    ohlcvs = JSON.parse(response[key]);
                                    return [2, this.parseOHLCVs(ohlcvs, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                cex.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = undefined;
                    var iso8601 = undefined;
                    if ('timestamp' in ticker) {
                        timestamp = parseInt(ticker['timestamp']) * 1000;
                        iso8601 = this.iso8601(timestamp);
                    }
                    var volume = this.safeFloat(ticker, 'volume');
                    var high = this.safeFloat(ticker, 'high');
                    var low = this.safeFloat(ticker, 'low');
                    var bid = this.safeFloat(ticker, 'bid');
                    var ask = this.safeFloat(ticker, 'ask');
                    var last = this.safeFloat(ticker, 'last');
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': iso8601,
                        'high': high,
                        'low': low,
                        'bid': bid,
                        'ask': ask,
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': last,
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': volume,
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                cex.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencies, response, tickers, result, t, ticker, symbol, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currencies = Object.keys(this.currencies);
                                    return [4, this.publicGetTickersCurrencies(this.extend({
                                            'currencies': currencies.join('/'),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    tickers = response['data'];
                                    result = {};
                                    for (t = 0; t < tickers.length; t++) {
                                        ticker = tickers[t];
                                        symbol = ticker['pair'].replace(':', '/');
                                        market = this.markets[symbol];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cex.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTickerPair(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                cex.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = parseInt(trade['date']) * 1000;
                    return {
                        'info': trade,
                        'id': trade['tid'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['type'],
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                cex.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradeHistoryPair(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                cex.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'pair': this.marketId(symbol),
                                        'type': side,
                                        'amount': amount,
                                    };
                                    if (type === 'limit') {
                                        order['price'] = price;
                                    }
                                    else {
                                        if (side === 'buy') {
                                            if (!price) {
                                                throw new InvalidOrder('For market buy orders ' + this.id + " requires the amount of quote currency to spend, to calculate proper costs call createOrder (symbol, 'market', 'buy', amount, price)");
                                            }
                                            order['amount'] = amount * price;
                                        }
                                        order['order_type'] = type;
                                    }
                                    return [4, this.privatePostPlaceOrderPair(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                cex.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCancelOrder({ 'id': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                cex.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = parseInt(order['time']);
                    var symbol = undefined;
                    if (!market) {
                        var symbol_1 = order['symbol1'] + '/' + order['symbol2'];
                        if (symbol_1 in this.markets)
                            market = this.market(symbol_1);
                    }
                    var status = order['status'];
                    if (status === 'a') {
                        status = 'open';
                    }
                    else if (status === 'cd') {
                        status = 'canceled';
                    }
                    else if (status === 'c') {
                        status = 'canceled';
                    }
                    else if (status === 'd') {
                        status = 'closed';
                    }
                    var price = this.safeFloat(order, 'price');
                    var amount = this.safeFloat(order, 'amount');
                    var remaining = this.safeFloat(order, 'pending');
                    if (!remaining)
                        remaining = this.safeFloat(order, 'remains');
                    var filled = amount - remaining;
                    var fee = undefined;
                    var cost = undefined;
                    if (market) {
                        symbol = market['symbol'];
                        cost = this.safeFloat(order, 'ta:' + market['quote']);
                        if (typeof cost === 'undefined')
                            cost = this.safeFloat(order, 'tta:' + market['quote']);
                        var baseFee = 'fa:' + market['base'];
                        var baseTakerFee = 'tfa:' + market['base'];
                        var quoteFee = 'fa:' + market['quote'];
                        var quoteTakerFee = 'tfa:' + market['quote'];
                        var feeRate = this.safeFloat(order, 'tradingFeeMaker');
                        if (!feeRate)
                            feeRate = this.safeFloat(order, 'tradingFeeTaker', feeRate);
                        if (feeRate)
                            feeRate /= 100.0;
                        if ((baseFee in order) || (baseTakerFee in order)) {
                            var baseFeeCost = this.safeFloat(order, baseFee);
                            if (typeof baseFeeCost === 'undefined')
                                baseFeeCost = this.safeFloat(order, baseTakerFee);
                            fee = {
                                'currency': market['base'],
                                'rate': feeRate,
                                'cost': baseFeeCost,
                            };
                        }
                        else if ((quoteFee in order) || (quoteTakerFee in order)) {
                            var quoteFeeCost = this.safeFloat(order, quoteFee);
                            if (typeof quoteFeeCost === 'undefined')
                                quoteFeeCost = this.safeFloat(order, quoteTakerFee);
                            fee = {
                                'currency': market['quote'],
                                'rate': feeRate,
                                'cost': quoteFeeCost,
                            };
                        }
                    }
                    if (!cost)
                        cost = price * filled;
                    return {
                        'id': order['id'],
                        'datetime': this.iso8601(timestamp),
                        'timestamp': timestamp,
                        'status': status,
                        'symbol': symbol,
                        'type': undefined,
                        'side': order['type'],
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'trades': undefined,
                        'fee': fee,
                        'info': order,
                    };
                };
                cex.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, method, market, orders, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    method = 'privatePostOpenOrders';
                                    market = undefined;
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['pair'] = market['id'];
                                        method += 'Pair';
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    orders = _a.sent();
                                    for (i = 0; i < orders.length; i++) {
                                        orders[i] = this.extend(orders[i], { 'status': 'open' });
                                    }
                                    return [2, this.parseOrders(orders, market, since, limit)];
                            }
                        });
                    });
                };
                cex.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetOrder(this.extend({
                                            'id': id.toString(),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response)];
                            }
                        });
                    });
                };
                cex.prototype.nonce = function () {
                    return this.milliseconds();
                };
                cex.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var auth = nonce + this.uid + this.apiKey;
                        var signature = this.hmac(this.encode(auth), this.encode(this.secret));
                        body = this.urlencode(this.extend({
                            'key': this.apiKey,
                            'signature': signature.toUpperCase(),
                            'nonce': nonce,
                        }, query));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                cex.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (!response) {
                                        throw new ExchangeError(this.id + ' returned ' + this.json(response));
                                    }
                                    else if (response === true) {
                                        return [2, response];
                                    }
                                    else if ('e' in response) {
                                        if ('ok' in response)
                                            if (response['ok'] === 'ok')
                                                return [2, response];
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                    else if ('error' in response) {
                                        if (response['error'])
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return cex;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 53: [function (require, module, exports) {
            'use strict';
            var zb = require('./zb.js');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(chbtc, _super);
                function chbtc() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                chbtc.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'chbtc',
                        'name': 'CHBTC',
                        'countries': 'CN',
                        'rateLimit': 1000,
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                            'fetchOrder': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28555659-f0040dc2-7109-11e7-9d99-688a438bf9f4.jpg',
                            'api': {
                                'public': 'http://api.chbtc.com/data',
                                'private': 'https://trade.chbtc.com/api',
                            },
                            'www': 'https://trade.chbtc.com/api',
                            'doc': 'https://www.chbtc.com/i/developer',
                        },
                        'markets': {
                            'BTC/CNY': { 'id': 'btc_cny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY' },
                            'LTC/CNY': { 'id': 'ltc_cny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY' },
                            'ETH/CNY': { 'id': 'eth_cny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY' },
                            'ETC/CNY': { 'id': 'etc_cny', 'symbol': 'ETC/CNY', 'base': 'ETC', 'quote': 'CNY' },
                            'BTS/CNY': { 'id': 'bts_cny', 'symbol': 'BTS/CNY', 'base': 'BTS', 'quote': 'CNY' },
                            'BCH/CNY': { 'id': 'bcc_cny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY' },
                            'HSR/CNY': { 'id': 'hsr_cny', 'symbol': 'HSR/CNY', 'base': 'HSR', 'quote': 'CNY' },
                            'QTUM/CNY': { 'id': 'qtum_cny', 'symbol': 'QTUM/CNY', 'base': 'QTUM', 'quote': 'CNY' },
                        },
                    });
                };
                chbtc.prototype.getMarketFieldName = function () {
                    return 'currency';
                };
                chbtc.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (api === 'private') {
                                        if ('code' in response)
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                    if ('result' in response) {
                                        if (!response['result'])
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return chbtc;
            }(zb));
        }, { "./base/errors": 10, "./zb.js": 118 }], 54: [function (require, module, exports) {
            'use strict';
            var foxbit = require('./foxbit.js');
            module.exports = (function (_super) {
                __extends(chilebit, _super);
                function chilebit() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                chilebit.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'chilebit',
                        'name': 'ChileBit',
                        'countries': 'CL',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27991414-1298f0d8-647f-11e7-9c40-d56409266336.jpg',
                            'api': {
                                'public': 'https://api.blinktrade.com/api',
                                'private': 'https://api.blinktrade.com/tapi',
                            },
                            'www': 'https://chilebit.net',
                            'doc': 'https://blinktrade.com/docs',
                        },
                    });
                };
                return chilebit;
            }(foxbit));
        }, { "./foxbit.js": 70 }], 55: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(cobinhood, _super);
                function cobinhood() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                cobinhood.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'cobinhood',
                        'name': 'COBINHOOD',
                        'countries': 'TW',
                        'rateLimit': 1000 / 10,
                        'has': {
                            'fetchCurrencies': true,
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'fetchOrder': true,
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': false,
                        },
                        'timeframes': {
                            '1m': '1m',
                            '5m': '5m',
                            '15m': '15m',
                            '30m': '30m',
                            '1h': '1h',
                            '3h': '3h',
                            '6h': '6h',
                            '12h': '12h',
                            '1d': '1D',
                            '7d': '7D',
                            '14d': '14D',
                            '1M': '1M',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/35755576-dee02e5c-0878-11e8-989f-1595d80ba47f.jpg',
                            'api': {
                                'web': 'https://api.cobinhood.com/v1',
                                'ws': 'wss://feed.cobinhood.com',
                            },
                            'test': {
                                'web': 'https://sandbox-api.cobinhood.com',
                                'ws': 'wss://sandbox-feed.cobinhood.com',
                            },
                            'www': 'https://cobinhood.com',
                            'doc': 'https://cobinhood.github.io/api-public',
                        },
                        'api': {
                            'system': {
                                'get': [
                                    'info',
                                    'time',
                                    'messages',
                                    'messages/{message_id}',
                                ],
                            },
                            'admin': {
                                'get': [
                                    'system/messages',
                                    'system/messages/{message_id}',
                                ],
                                'post': [
                                    'system/messages',
                                ],
                                'patch': [
                                    'system/messages/{message_id}',
                                ],
                                'delete': [
                                    'system/messages/{message_id}',
                                ],
                            },
                            'public': {
                                'get': [
                                    'market/currencies',
                                    'market/trading_pairs',
                                    'market/orderbooks/{trading_pair_id}',
                                    'market/stats',
                                    'market/tickers/{trading_pair_id}',
                                    'market/trades/{trading_pair_id}',
                                    'chart/candles/{trading_pair_id}',
                                ],
                            },
                            'private': {
                                'get': [
                                    'trading/orders/{order_id}',
                                    'trading/orders/{order_id}/trades',
                                    'trading/orders',
                                    'trading/order_history',
                                    'trading/trades/{trade_id}',
                                    'wallet/balances',
                                    'wallet/ledger',
                                    'wallet/deposit_addresses',
                                    'wallet/withdrawal_addresses',
                                    'wallet/withdrawals/{withdrawal_id}',
                                    'wallet/withdrawals',
                                    'wallet/deposits/{deposit_id}',
                                    'wallet/deposits',
                                ],
                                'post': [
                                    'trading/orders',
                                    'wallet/deposit_addresses',
                                    'wallet/withdrawal_addresses',
                                    'wallet/withdrawals',
                                ],
                                'delete': [
                                    'trading/orders/{order_id}',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.0,
                                'taker': 0.0,
                            },
                        },
                        'precision': {
                            'amount': 8,
                            'price': 8,
                        },
                    });
                };
                cobinhood.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, currencies, result, i, currency, id, code, fundingNotFrozen, active, minUnit;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarketCurrencies(params)];
                                case 1:
                                    response = _a.sent();
                                    currencies = response['result']['currencies'];
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['currency'];
                                        code = this.commonCurrencyCode(id);
                                        fundingNotFrozen = !currency['funding_frozen'];
                                        active = currency['is_active'] && fundingNotFrozen;
                                        minUnit = parseFloat(currency['min_unit']);
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'name': currency['name'],
                                            'active': active,
                                            'status': 'ok',
                                            'fiat': false,
                                            'precision': this.precisionFromString(currency['min_unit']),
                                            'limits': {
                                                'amount': {
                                                    'min': minUnit,
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': minUnit,
                                                    'max': undefined,
                                                },
                                                'deposit': {
                                                    'min': minUnit,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': minUnit,
                                                    'max': undefined,
                                                },
                                            },
                                            'funding': {
                                                'withdraw': {
                                                    'active': fundingNotFrozen,
                                                    'fee': parseFloat(currency['withdrawal_fee']),
                                                },
                                                'deposit': {
                                                    'active': fundingNotFrozen,
                                                    'fee': parseFloat(currency['deposit_fee']),
                                                },
                                            },
                                            'info': currency,
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cobinhood.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, i, market, id, _a, baseId, quoteId, base, quote, symbol, precision;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetMarketTradingPairs()];
                                case 1:
                                    response = _c.sent();
                                    markets = response['result']['trading_pairs'];
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        id = market['id'];
                                        _a = __read(id.split('-'), 2), baseId = _a[0], quoteId = _a[1];
                                        base = this.commonCurrencyCode(baseId);
                                        quote = this.commonCurrencyCode(quoteId);
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': 8,
                                            'price': this.precisionFromString(market['quote_increment']),
                                        };
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'active': market['is_active'],
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': parseFloat(market['base_min_size']),
                                                    'max': parseFloat(market['base_max_size']),
                                                },
                                                'price': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                            },
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cobinhood.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = market['symbol'];
                    var timestamp = undefined;
                    if ('timestamp' in ticker) {
                        timestamp = ticker['timestamp'];
                    }
                    else {
                        timestamp = this.milliseconds();
                    }
                    var info = ticker;
                    if ('info' in ticker)
                        info = ticker['info'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high_24hr']),
                        'low': parseFloat(ticker['low_24hr']),
                        'bid': parseFloat(ticker['highest_bid']),
                        'ask': parseFloat(ticker['lowest_ask']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last_price'),
                        'change': this.safeFloat(ticker, 'percentChanged24hr'),
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['base_volume']),
                        'quoteVolume': this.safeFloat(ticker, 'quote_volume'),
                        'info': info,
                    };
                };
                cobinhood.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketTickersTradingPairId(this.extend({
                                            'trading_pair_id': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['result']['ticker'];
                                    ticker = {
                                        'last_price': ticker['last_trade_price'],
                                        'highest_bid': ticker['highest_bid'],
                                        'lowest_ask': ticker['lowest_ask'],
                                        'base_volume': ticker['24h_volume'],
                                        'high_24hr': ticker['24h_high'],
                                        'low_24hr': ticker['24h_low'],
                                        'timestamp': ticker['timestamp'],
                                        'info': response,
                                    };
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                cobinhood.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, ids, result, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetMarketStats(params)];
                                case 2:
                                    response = _a.sent();
                                    tickers = response['result'];
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cobinhood.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'trading_pair_id': this.marketId(symbol),
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetMarketOrderbooksTradingPairId(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrderBook(response['result']['orderbook'], undefined, 'bids', 'asks', 0, 2)];
                            }
                        });
                    });
                };
                cobinhood.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = trade['timestamp'];
                    var price = parseFloat(trade['price']);
                    var amount = parseFloat(trade['size']);
                    var cost = parseFloat(this.costToPrecision(symbol, price * amount));
                    var side = trade['maker_side'] === 'bid' ? 'sell' : 'buy';
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'id': trade['id'],
                        'order': undefined,
                        'type': undefined,
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'fee': undefined,
                    };
                };
                cobinhood.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 50; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketTradesTradingPairId(this.extend({
                                            'trading_pair_id': market['id'],
                                            'limit': limit,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    trades = response['result']['trades'];
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                cobinhood.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '5m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv['timestamp'],
                        parseFloat(ohlcv['open']),
                        parseFloat(ohlcv['high']),
                        parseFloat(ohlcv['low']),
                        parseFloat(ohlcv['close']),
                        parseFloat(ohlcv['volume']),
                    ];
                };
                cobinhood.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, endTime, request, response, ohlcv;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    endTime = this.milliseconds();
                                    request = {
                                        'trading_pair_id': market['id'],
                                        'timeframe': this.timeframes[timeframe],
                                        'end_time': endTime,
                                    };
                                    if (typeof since !== 'undefined')
                                        request['start_time'] = since;
                                    return [4, this.publicGetChartCandlesTradingPairId(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    ohlcv = response['result']['candles'];
                                    return [2, this.parseOHLCVs(ohlcv, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                cobinhood.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, balances, i, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetWalletBalances(params)];
                                case 2:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    balances = response['result']['balances'];
                                    for (i = 0; i < balances.length; i++) {
                                        balance = balances[i];
                                        currency = balance['currency'];
                                        if (currency in this.currencies_by_id)
                                            currency = this.currencies_by_id[currency]['code'];
                                        account = {
                                            'used': parseFloat(balance['on_order']),
                                            'total': parseFloat(balance['total']),
                                        };
                                        account['free'] = parseFloat(account['total'] - account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                cobinhood.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (!market) {
                        var marketId = order['trading_pair'];
                        market = this.markets_by_id[marketId];
                    }
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = order['timestamp'];
                    var price = parseFloat(order['price']);
                    var amount = parseFloat(order['size']);
                    var filled = parseFloat(order['filled']);
                    var remaining = amount - filled;
                    var status = order['state'];
                    if (status === 'filled') {
                        status = 'closed';
                    }
                    else if (status === 'cancelled') {
                        status = 'canceled';
                    }
                    else {
                        status = 'open';
                    }
                    var side = (order['side'] === 'bid') ? 'buy' : 'sell';
                    return {
                        'id': order['id'],
                        'datetime': this.iso8601(timestamp),
                        'timestamp': timestamp,
                        'status': status,
                        'symbol': symbol,
                        'type': order['type'],
                        'side': side,
                        'price': price,
                        'cost': price * amount,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'trades': undefined,
                        'fee': undefined,
                        'info': order,
                    };
                };
                cobinhood.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, order, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    side = (side === 'sell') ? 'ask' : 'bid';
                                    request = {
                                        'trading_pair_id': market['id'],
                                        'type': type,
                                        'side': side,
                                        'size': this.amountToString(symbol, amount),
                                    };
                                    if (type !== 'market')
                                        request['price'] = this.priceToPrecision(symbol, price);
                                    return [4, this.privatePostTradingOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    order = this.parseOrder(response['result']['order'], market);
                                    id = order['id'];
                                    this.orders[id] = order;
                                    return [2, order];
                            }
                        });
                    });
                };
                cobinhood.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateDeleteTradingOrdersOrderId(this.extend({
                                        'order_id': id,
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                cobinhood.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetTradingOrdersOrderId(this.extend({
                                            'order_id': id.toString(),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response['result']['order'])];
                            }
                        });
                    });
                };
                cobinhood.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var result, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetTradingOrders(params)];
                                case 2:
                                    result = _a.sent();
                                    orders = this.parseOrders(result['result']['orders'], undefined, since, limit);
                                    if (typeof symbol !== 'undefined')
                                        return [2, this.filterBySymbol(orders, symbol)];
                                    return [2, orders];
                            }
                        });
                    });
                };
                cobinhood.prototype.fetchOrderTrades = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetTradingOrdersOrderIdTrades(this.extend({
                                            'order_id': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    market = (typeof symbol === 'undefined') ? undefined : this.market(symbol);
                                    return [2, this.parseTrades(response['result'], market)];
                            }
                        });
                    });
                };
                cobinhood.prototype.createDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privatePostWalletDepositAddresses({
                                            'currency': currency['id'],
                                        })];
                                case 2:
                                    response = _a.sent();
                                    address = this.safeString(response['result']['deposit_address'], 'address');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': code,
                                            'address': address,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                cobinhood.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privateGetWalletDepositAddresses(this.extend({
                                            'currency': currency['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    address = this.safeString(response['result']['deposit_addresses'], 'address');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': code,
                                            'address': address,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                cobinhood.prototype.withdraw = function (code, amount, address, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privatePostWalletWithdrawals(this.extend({
                                            'currency': currency['id'],
                                            'amount': amount,
                                            'address': address,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'id': response['result']['withdrawal_id'],
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                cobinhood.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api']['web'] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    headers = {};
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        headers['nonce'] = this.nonce().toString();
                        headers['Authorization'] = this.apiKey;
                    }
                    if (method === 'GET') {
                        query = this.urlencode(query);
                        if (query.length)
                            url += '?' + query;
                    }
                    else {
                        headers['Content-type'] = 'application/json; charset=UTF-8';
                        body = this.json(query);
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                cobinhood.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code < 400 || code >= 600) {
                        return;
                    }
                    if (body[0] !== '{') {
                        throw new ExchangeError(this.id + ' ' + body);
                    }
                    var response = this.unjson(body);
                    var message = this.safeValue(response['error'], 'error_code');
                    throw new ExchangeError(this.id + ' ' + message);
                };
                return cobinhood;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 56: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, NotSupported = _a.NotSupported;
            module.exports = (function (_super) {
                __extends(coincheck, _super);
                function coincheck() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coincheck.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coincheck',
                        'name': 'coincheck',
                        'countries': ['JP', 'ID'],
                        'rateLimit': 1500,
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766464-3b5c3c74-5ed9-11e7-840e-31b32968e1da.jpg',
                            'api': 'https://coincheck.com/api',
                            'www': 'https://coincheck.com',
                            'doc': 'https://coincheck.com/documents/exchange/api',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'exchange/orders/rate',
                                    'order_books',
                                    'rate/{pair}',
                                    'ticker',
                                    'trades',
                                ],
                            },
                            'private': {
                                'get': [
                                    'accounts',
                                    'accounts/balance',
                                    'accounts/leverage_balance',
                                    'bank_accounts',
                                    'deposit_money',
                                    'exchange/orders/opens',
                                    'exchange/orders/transactions',
                                    'exchange/orders/transactions_pagination',
                                    'exchange/leverage/positions',
                                    'lending/borrows/matches',
                                    'send_money',
                                    'withdraws',
                                ],
                                'post': [
                                    'bank_accounts',
                                    'deposit_money/{id}/fast',
                                    'exchange/orders',
                                    'exchange/transfers/to_leverage',
                                    'exchange/transfers/from_leverage',
                                    'lending/borrows',
                                    'lending/borrows/{id}/repay',
                                    'send_money',
                                    'withdraws',
                                ],
                                'delete': [
                                    'bank_accounts/{id}',
                                    'exchange/orders/{id}',
                                    'withdraws/{id}',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/JPY': { 'id': 'btc_jpy', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
                        },
                    });
                };
                coincheck.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, currencies, i, currency, lowercase, account, reserved;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetAccountsBalance()];
                                case 1:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        account = this.account();
                                        if (lowercase in balances)
                                            account['free'] = parseFloat(balances[lowercase]);
                                        reserved = lowercase + '_reserved';
                                        if (reserved in balances)
                                            account['used'] = parseFloat(balances[reserved]);
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                coincheck.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (symbol !== 'BTC/JPY')
                                        throw new NotSupported(this.id + ' fetchOrderBook () supports BTC/JPY only');
                                    return [4, this.publicGetOrderBooks(params)];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                coincheck.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (symbol !== 'BTC/JPY')
                                        throw new NotSupported(this.id + ' fetchTicker () supports BTC/JPY only');
                                    return [4, this.publicGetTicker(params)];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = ticker['timestamp'] * 1000;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['volume']),
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                coincheck.prototype.parseTrade = function (trade, market) {
                    var timestamp = this.parse8601(trade['created_at']);
                    return {
                        'id': trade['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['order_type'],
                        'price': parseFloat(trade['rate']),
                        'amount': parseFloat(trade['amount']),
                        'info': trade,
                    };
                };
                coincheck.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (symbol !== 'BTC/JPY')
                                        throw new NotSupported(this.id + ' fetchTrades () supports BTC/JPY only');
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrades(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    if ('success' in response)
                                        if (response['success'])
                                            if (typeof response['data'] !== 'undefined')
                                                return [2, this.parseTrades(response['data'], market, since, limit)];
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                coincheck.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, order_type, prefix, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    order = {
                                        'pair': this.marketId(symbol),
                                    };
                                    if (type === 'market') {
                                        order_type = type + '_' + side;
                                        order['order_type'] = order_type;
                                        prefix = (side === 'buy') ? (order_type + '_') : '';
                                        order[prefix + 'amount'] = amount;
                                    }
                                    else {
                                        order['order_type'] = side;
                                        order['rate'] = price;
                                        order['amount'] = amount;
                                    }
                                    return [4, this.privatePostExchangeOrders(this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                coincheck.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateDeleteExchangeOrdersId({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                coincheck.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var queryString = '';
                        if (method === 'GET') {
                            if (Object.keys(query).length)
                                url += '?' + this.urlencode(this.keysort(query));
                        }
                        else {
                            if (Object.keys(query).length) {
                                body = this.urlencode(this.keysort(query));
                                queryString = body;
                            }
                        }
                        var auth = nonce + url + queryString;
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'ACCESS-KEY': this.apiKey,
                            'ACCESS-NONCE': nonce,
                            'ACCESS-SIGNATURE': this.hmac(this.encode(auth), this.encode(this.secret)),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                coincheck.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (api === 'public')
                                        return [2, response];
                                    if ('success' in response)
                                        if (response['success'])
                                            return [2, response];
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                return coincheck;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 57: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError, InvalidNonce = _a.InvalidNonce, InsufficientFunds = _a.InsufficientFunds, InvalidOrder = _a.InvalidOrder, OrderNotFound = _a.OrderNotFound, DDoSProtection = _a.DDoSProtection;
            module.exports = (function (_super) {
                __extends(coinegg, _super);
                function coinegg() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coinegg.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coinegg',
                        'name': 'CoinEgg',
                        'countries': ['CN', 'UK'],
                        'has': {
                            'fetchOpenOrders': true,
                            'fetchMyTrades': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/36770310-adfa764e-1c5a-11e8-8e09-449daac3d2fb.jpg',
                            'api': {
                                'web': 'https://www.coinegg.com/coin',
                                'rest': 'https://api.coinegg.com/api/v1',
                            },
                            'www': 'https://www.coinegg.com',
                            'doc': 'https://www.coinegg.com/explain.api.html',
                            'fees': 'https://www.coinegg.com/fee.html',
                        },
                        'api': {
                            'web': {
                                'get': [
                                    '{quote}/allcoin',
                                    '{quote}/trends',
                                    '{quote}/{base}/order',
                                    '{quote}/{base}/trades',
                                    '{quote}/{base}/depth.js',
                                ],
                            },
                            'public': {
                                'get': [
                                    'ticker/{quote}',
                                    'depth/{quote}',
                                    'orders/{quote}',
                                ],
                            },
                            'private': {
                                'get': [
                                    'balance',
                                ],
                                'post': [
                                    'trade_add/{quote}',
                                    'trade_cancel/{quote}',
                                    'trade_view/{quote}',
                                    'trade_list/{quote}',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.1 / 100,
                                'taker': 0.1 / 100,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.008,
                                    'BCH': 0.002,
                                    'LTC': 0.001,
                                    'ETH': 0.01,
                                    'ETC': 0.01,
                                    'NEO': 0,
                                    'QTUM': '1%',
                                    'XRP': '1%',
                                    'DOGE': '1%',
                                    'LSK': '1%',
                                    'XAS': '1%',
                                    'BTS': '1%',
                                    'GAME': '1%',
                                    'GOOC': '1%',
                                    'NXT': '1%',
                                    'IFC': '1%',
                                    'DNC': '1%',
                                    'BLK': '1%',
                                    'VRC': '1%',
                                    'XPM': '1%',
                                    'VTC': '1%',
                                    'TFC': '1%',
                                    'PLC': '1%',
                                    'EAC': '1%',
                                    'PPC': '1%',
                                    'FZ': '1%',
                                    'ZET': '1%',
                                    'RSS': '1%',
                                    'PGC': '1%',
                                    'SKT': '1%',
                                    'JBC': '1%',
                                    'RIO': '1%',
                                    'LKC': '1%',
                                    'ZCC': '1%',
                                    'MCC': '1%',
                                    'QEC': '1%',
                                    'MET': '1%',
                                    'YTC': '1%',
                                    'HLB': '1%',
                                    'MRYC': '1%',
                                    'MTC': '1%',
                                    'KTC': 0,
                                },
                            },
                        },
                        'exceptions': {
                            '103': AuthenticationError,
                            '104': AuthenticationError,
                            '105': AuthenticationError,
                            '106': InvalidNonce,
                            '200': InsufficientFunds,
                            '201': InvalidOrder,
                            '202': InvalidOrder,
                            '203': OrderNotFound,
                            '402': DDoSProtection,
                        },
                    });
                };
                coinegg.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var quoteIds, result, b, quoteId, bases, baseIds, numBaseIds, i, baseId, market, base, quote, id, symbol, precision, lot;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    quoteIds = ['btc', 'usc'];
                                    result = [];
                                    b = 0;
                                    _a.label = 1;
                                case 1:
                                    if (!(b < quoteIds.length)) return [3, 4];
                                    quoteId = quoteIds[b];
                                    return [4, this.webGetQuoteAllcoin({
                                            'quote': quoteId,
                                        })];
                                case 2:
                                    bases = _a.sent();
                                    baseIds = Object.keys(bases);
                                    numBaseIds = baseIds.length;
                                    if (numBaseIds < 1)
                                        throw new ExchangeError(this.id + ' fetchMarkets() failed for ' + quoteId);
                                    for (i = 0; i < baseIds.length; i++) {
                                        baseId = baseIds[i];
                                        market = bases[baseId];
                                        base = baseId.toUpperCase();
                                        quote = quoteId.toUpperCase();
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        id = baseId + quoteId;
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': 8,
                                            'price': 8,
                                        };
                                        lot = Math.pow(10, -precision['amount']);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'active': true,
                                            'lot': lot,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': lot,
                                                    'max': Math.pow(10, precision['amount']),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision['price']),
                                                    'max': Math.pow(10, precision['price']),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                            },
                                            'info': market,
                                        });
                                    }
                                    _a.label = 3;
                                case 3:
                                    b++;
                                    return [3, 1];
                                case 4: return [2, result];
                            }
                        });
                    });
                };
                coinegg.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = market['symbol'];
                    var timestamp = this.milliseconds();
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['buy']),
                        'ask': parseFloat(ticker['sell']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last']),
                        'change': this.safeFloat(ticker, 'change'),
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['vol']),
                        'quoteVolume': this.safeFloat(ticker, 'quoteVol'),
                        'info': ticker,
                    };
                };
                coinegg.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTickerQuote(this.extend({
                                            'coin': market['baseId'],
                                            'quote': market['quoteId'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                coinegg.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var quoteIds, result, b, quoteId, tickers, baseIds, i, baseId, ticker, id, market, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    quoteIds = ['btc', 'usc'];
                                    result = {};
                                    b = 0;
                                    _a.label = 2;
                                case 2:
                                    if (!(b < quoteIds.length)) return [3, 5];
                                    quoteId = quoteIds[b];
                                    return [4, this.webGetQuoteAllcoin({
                                            'quote': quoteId,
                                        })];
                                case 3:
                                    tickers = _a.sent();
                                    baseIds = Object.keys(tickers);
                                    if (!baseIds.length) {
                                        throw new ExchangeError('fetchTickers failed');
                                    }
                                    for (i = 0; i < baseIds.length; i++) {
                                        baseId = baseIds[i];
                                        ticker = tickers[baseId];
                                        id = baseId + quoteId;
                                        market = this.marketsById[id];
                                        symbol = market['symbol'];
                                        result[symbol] = this.parseTicker({
                                            'high': ticker[4],
                                            'low': ticker[5],
                                            'buy': ticker[2],
                                            'sell': ticker[3],
                                            'last': ticker[1],
                                            'change': ticker[8],
                                            'vol': ticker[6],
                                            'quoteVol': ticker[7],
                                        }, market);
                                    }
                                    _a.label = 4;
                                case 4:
                                    b++;
                                    return [3, 2];
                                case 5: return [2, result];
                            }
                        });
                    });
                };
                coinegg.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetDepthQuote(this.extend({
                                            'coin': market['baseId'],
                                            'quote': market['quoteId'],
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                coinegg.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = parseInt(trade['date']) * 1000;
                    var price = parseFloat(trade['price']);
                    var amount = parseFloat(trade['amount']);
                    var symbol = market['symbol'];
                    var cost = this.costToPrecision(symbol, price * amount);
                    return {
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'id': this.safeString(trade, 'tid'),
                        'order': undefined,
                        'type': 'limit',
                        'side': trade['type'],
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'fee': undefined,
                        'info': trade,
                    };
                };
                coinegg.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetOrdersQuote(this.extend({
                                            'coin': market['baseId'],
                                            'quote': market['quoteId'],
                                        }, params))];
                                case 2:
                                    trades = _a.sent();
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                coinegg.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, rows, i, row, _a, id, type, currency, currencies, i, currency;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _c.sent();
                                    return [4, this.privateGetBalance(params)];
                                case 2:
                                    balances = _c.sent();
                                    result = { 'info': balances };
                                    balances = this.omit(balances['data'], 'uid');
                                    rows = Object.keys(balances);
                                    for (i = 0; i < rows.length; i++) {
                                        row = rows[i];
                                        _a = __read(row.split('_'), 2), id = _a[0], type = _a[1];
                                        id = id.toUpperCase();
                                        type = type.toUpperCase();
                                        currency = this.commonCurrencyCode(id);
                                        if (currency in this.currencies) {
                                            if (!(currency in result)) {
                                                result[currency] = {
                                                    'free': undefined,
                                                    'used': undefined,
                                                    'total': undefined,
                                                };
                                            }
                                            type = (type === 'LOCK' ? 'used' : 'free');
                                            result[currency][type] = parseFloat(balances[row]);
                                        }
                                    }
                                    currencies = Object.keys(result);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        result[currency]['total'] = this.sum(result[currency]['free'], result[currency]['used']);
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                coinegg.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = market['symbol'];
                    var timestamp = this.parse8601(order['datetime']);
                    var price = parseFloat(order['price']);
                    var amount = parseFloat(order['amount_original']);
                    var remaining = parseFloat(order['amount_outstanding']);
                    var filled = amount - remaining;
                    var status = this.safeString(order, 'status');
                    if (status === 'cancelled') {
                        status = 'canceled';
                    }
                    else {
                        status = remaining ? 'open' : 'closed';
                    }
                    var info = this.safeValue(order, 'info', order);
                    return {
                        'id': this.safeString(order, 'id'),
                        'datetime': this.iso8601(timestamp),
                        'timestamp': timestamp,
                        'status': status,
                        'symbol': symbol,
                        'type': 'limit',
                        'side': order['type'],
                        'price': price,
                        'cost': undefined,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'trades': undefined,
                        'fee': undefined,
                        'info': info,
                    };
                };
                coinegg.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, id, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostTradeAddQuote(this.extend({
                                            'coin': market['baseId'],
                                            'quote': market['quoteId'],
                                            'type': side,
                                            'amount': amount,
                                            'price': price,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    if (!response['status']) {
                                        throw new InvalidOrder(this.json(response));
                                    }
                                    id = response['id'];
                                    order = this.parseOrder({
                                        'id': id,
                                        'datetime': this.ymdhms(this.milliseconds()),
                                        'amount_original': amount,
                                        'amount_outstanding': amount,
                                        'price': price,
                                        'type': side,
                                        'info': response,
                                    }, market);
                                    this.orders[id] = order;
                                    return [2, order];
                            }
                        });
                    });
                };
                coinegg.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostTradeCancelQuote(this.extend({
                                            'id': id,
                                            'coin': market['baseId'],
                                            'quote': market['quoteId'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    if (!response['status']) {
                                        throw new ExchangeError(this.json(response));
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                coinegg.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostTradeViewQuote(this.extend({
                                            'id': id,
                                            'coin': market['baseId'],
                                            'quote': market['quoteId'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response['data'], market)];
                            }
                        });
                    });
                };
                coinegg.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'coin': market['baseId'],
                                        'quote': market['quoteId'],
                                    };
                                    if (typeof since !== 'undefined')
                                        request['since'] = since / 1000;
                                    return [4, this.privatePostTradeListQuote(this.extend(request, params))];
                                case 2:
                                    orders = _a.sent();
                                    return [2, this.parseOrders(orders['data'], market, since, limit)];
                            }
                        });
                    });
                };
                coinegg.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, this.extend({
                                        'type': 'open',
                                    }, params))];
                                case 1:
                                    result = _a.sent();
                                    return [2, result];
                            }
                        });
                    });
                };
                coinegg.prototype.nonce = function () {
                    return this.milliseconds();
                };
                coinegg.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var apiType = 'rest';
                    if (api === 'web') {
                        apiType = api;
                    }
                    var url = this.urls['api'][apiType] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public' || api === 'web') {
                        if (api === 'web')
                            query['t'] = this.nonce();
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        query = this.urlencode(this.extend({
                            'key': this.apiKey,
                            'nonce': this.nonce(),
                        }, query));
                        var secret = this.hash(this.secret);
                        var signature = this.hmac(this.encode(query), this.encode(secret));
                        query += '&' + 'signature=' + signature;
                        if (method === 'GET') {
                            url += '?' + query;
                        }
                        else {
                            headers = {
                                'Content-type': 'application/x-www-form-urlencoded',
                            };
                            body = query;
                        }
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                coinegg.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    var errorMessages = {
                        '100': 'Required parameters can not be empty',
                        '101': 'Illegal parameter',
                        '102': 'coin does not exist',
                        '103': 'Key does not exist',
                        '104': 'Signature does not match',
                        '105': 'Insufficient permissions',
                        '106': 'Request expired(nonce error)',
                        '200': 'Lack of balance',
                        '201': 'Too small for the number of trading',
                        '202': 'Price must be in 0 - 1000000',
                        '203': 'Order does not exist',
                        '204': 'Pending order amount must be above 0.001 BTC',
                        '205': 'Restrict pending order prices',
                        '206': 'Decimal place error',
                        '401': 'System error',
                        '402': 'Requests are too frequent',
                        '403': 'Non-open API',
                        '404': 'IP restriction does not request the resource',
                        '405': 'Currency transactions are temporarily closed',
                    };
                    if (typeof body === 'string') {
                        if (body.length > 0) {
                            if (body[0] === '{') {
                                var response = JSON.parse(body);
                                var error = this.safeString(response, 'code');
                                var message = this.safeString(errorMessages, code, 'Error');
                                if (typeof error !== 'undefined') {
                                    if (error in this.exceptions) {
                                        throw new this.exceptions[error](this.id + ' ' + message);
                                    }
                                    else {
                                        throw new ExchangeError(this.id + message);
                                    }
                                }
                            }
                        }
                    }
                };
                return coinegg;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 58: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(coinexchange, _super);
                function coinexchange() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coinexchange.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coinexchange',
                        'name': 'CoinExchange',
                        'countries': ['IN', 'JP', 'KR', 'VN', 'US'],
                        'rateLimit': 1000,
                        'has': {
                            'privateAPI': false,
                            'createOrder': false,
                            'createMarketOrder': false,
                            'createLimitOrder': false,
                            'cancelOrder': false,
                            'editOrder': false,
                            'fetchTrades': false,
                            'fetchOHLCV': false,
                            'fetchCurrencies': true,
                            'fetchTickers': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/34842303-29c99fca-f71c-11e7-83c1-09d900cb2334.jpg',
                            'api': 'https://www.coinexchange.io/api/v1',
                            'www': 'https://www.coinexchange.io',
                            'doc': 'https://coinexchangeio.github.io/slate/',
                            'fees': 'https://www.coinexchange.io/fees',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'getcurrency',
                                    'getcurrencies',
                                    'getmarkets',
                                    'getmarketsummaries',
                                    'getmarketsummary',
                                    'getorderbook',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.0015,
                                'taker': 0.0015,
                            },
                            'funding': {
                                'withdraw': {
                                    '1337': 0.01,
                                    '420G': 0.01,
                                    '611': 0.1,
                                    'ACC': 0.01,
                                    'ACES': 0.01,
                                    'ACO': 0.01,
                                    'ACP': 0.01,
                                    'ADCN': 500.0,
                                    'ADST': 1.0,
                                    'ADZ': 0.1,
                                    'AGRI': 0.01,
                                    'AI': 1.0,
                                    'AKY': 0.01,
                                    'ALIS': 1.0,
                                    'ALL': 0.2,
                                    'AMC': 0.1,
                                    'AMMO': 0.01,
                                    'AMS': 0.01,
                                    'ANTX': 0.01,
                                    'ANY': 1.0,
                                    'ARG': 0.1,
                                    'ARGUS': 0.01,
                                    'ARGUSOLD': 0.01,
                                    'ASN': 0.01,
                                    'ATOM': 0.01,
                                    'ATX': 0.01,
                                    'AU': 0.01,
                                    'B2B': 1.0,
                                    'B3': 0.01,
                                    'BAKED': 0.01,
                                    'BCC': 0.01,
                                    'BCH': 0.001,
                                    'BCM': 0.01,
                                    'BDL': 0.01,
                                    'BEER': 0.01,
                                    'BELA': 0.01,
                                    'BENJI': 0.05,
                                    'BET': 0.01,
                                    'BFI': 1.0,
                                    'BIGUP': 1.0,
                                    'BIRDS': 0.01,
                                    'BITB': 0.1,
                                    'BIXC': 0.01,
                                    'BIZ': 0.01,
                                    'BLAS': 0.1,
                                    'BLAZR': 0.2,
                                    'BLK': 0.01,
                                    'BLN': 1.0,
                                    'BLUE': 1.0,
                                    'BOAT': 1.0,
                                    'BON': 0.01,
                                    'BONPAY': 1.0,
                                    'BOPS': 0.01,
                                    'BPOK': 0.1,
                                    'BQ': 1.0,
                                    'BRAT': 0.01,
                                    'BRC': 1.0,
                                    'BRIT': 0.01,
                                    'BSN': 1.0,
                                    'BSR': 0.01,
                                    'BTBc': 0.01,
                                    'BTC': 0.001,
                                    'BTCRED': 1.0,
                                    'BTCRF': 0.01,
                                    'BTDX': 0.1,
                                    'BTE': 1.0,
                                    'BTPL': 0.01,
                                    'BULLS': 0.01,
                                    'BUZZ': 0.01,
                                    'BXT': 0.01,
                                    'C47': 1.0,
                                    'CACH': 0.2,
                                    'CALC': 0.01,
                                    'CANN': 0.01,
                                    'CBANK': 1.0,
                                    'CDX': 1.0,
                                    'CHEAP': 0.01,
                                    'CHESS': 0.01,
                                    'CHILI': 0.01,
                                    'CHIPS': 0.1,
                                    'CJ': 0.1,
                                    'CLT': 0.1,
                                    'CMPCO': 0.2,
                                    'CMX': 0.01,
                                    'CNNC': 0.02,
                                    'CNT': 0.01,
                                    'CO2': 1.0,
                                    'COOC': 0.01,
                                    'COUPE': 0.01,
                                    'CQST': 0.1,
                                    'CRACKERS': 0.01,
                                    'CRDNC': 0.01,
                                    'CREA': 0.02,
                                    'CREAK': 0.01,
                                    'CREVA2': 0.01,
                                    'CRMSN': 0.01,
                                    'CRN': 0.01,
                                    'CRW': 0.01,
                                    'CTIC2': 0.01,
                                    'CUBE': 0.01,
                                    'CXT': 0.01,
                                    'CYCLONE': 0.01,
                                    'CYDER': 0.01,
                                    'DAG': 0.01,
                                    'DALC': 1.0,
                                    'DARI': 0.01,
                                    'DASH': 0.01,
                                    'DAV': 0.01,
                                    'DBIC': 0.1,
                                    'DCN': 1.0,
                                    'DEM': 0.01,
                                    'DFS': 0.01,
                                    'DGB': 0.1,
                                    'DGC': 0.1,
                                    'DIME': 0.01,
                                    'DMB': 0.01,
                                    'DMC': 0.1,
                                    'DNCV2': 0.01,
                                    'DNE': 1.0,
                                    'DNR': 0.01,
                                    'DOGE': 2.0,
                                    'DOGEJ': 1.0,
                                    'DP': 0.01,
                                    'DRGN': 1.0,
                                    'DRS': 0.1,
                                    'DSE': 0.01,
                                    'DSR': 0.01,
                                    'DTCT': 1.0,
                                    'DUTCH': 0.01,
                                    'EBC': 0.01,
                                    'EBT': 0.01,
                                    'ECC': 0.1,
                                    'ECN': 0.01,
                                    'EDRC': 0.01,
                                    'EECN': 0.01,
                                    'EGC': 0.1,
                                    'ELCO': 0.1,
                                    'ELIX': 1.0,
                                    'ELS': 0.01,
                                    'ELT': 1.0,
                                    'EMC': 0.01,
                                    'EMIRG': 0.01,
                                    'ENTRC': 1.0,
                                    'ENZO': 0.1,
                                    'EQL': 1.0,
                                    'EQT': 0.1,
                                    'ERSO': 0.01,
                                    'ERT': 1.0,
                                    'ERY': 0.01,
                                    'ESP': 0.1,
                                    'ETBS': 1.0,
                                    'ETC': 0.1,
                                    'ETG': 1.0,
                                    'ETH': 0.01,
                                    'ETHD': 0.01,
                                    'ETHOS': 1.0,
                                    'ETN': 2.0,
                                    'EUROP': 0.1,
                                    'EXCL': 0.1,
                                    'EXTN': 0.01,
                                    'FAIR': 0.01,
                                    'FAP': 1.0,
                                    'FAZZ': 0.01,
                                    'FCH': 0.01,
                                    'FGZ': 0.1,
                                    'FLASH': 0.01,
                                    'FLIK': 1.0,
                                    'FRT': 0.1,
                                    'FSX': 0.1,
                                    'FTC': 0.01,
                                    'FXE': 2.0,
                                    'GAIN': 1.0,
                                    'GB': 0.1,
                                    'GBX': 0.01,
                                    'GDC': 1.0,
                                    'GEERT': 0.01,
                                    'GET': 0.01,
                                    'GFC': 1.0,
                                    'GLS': 0.01,
                                    'GLT': 0.01,
                                    'GLTC': 0.01,
                                    'GMB': 0.01,
                                    'GMX': 0.01,
                                    'GOKUOLD': 0.1,
                                    'GOLD': 0.01,
                                    'GOLF': 0.1,
                                    'GOOD': 2.0,
                                    'GP': 0.01,
                                    'GRE': 0.01,
                                    'GREENF': 0.01,
                                    'GRMD': 1.0,
                                    'GRS': 0.01,
                                    'GRX': 1.0,
                                    'GTC': 0.01,
                                    'GWC': 0.2,
                                    'HALLO': 0.01,
                                    'HBC': 0.01,
                                    'HC': 0.01,
                                    'HEALTHY': 0.01,
                                    'HIGH': 0.01,
                                    'HMC': 0.01,
                                    'HNC': 0.01,
                                    'HOC': 0.01,
                                    'HODL': 0.01,
                                    'HOLLY': 1.0,
                                    'HONEY': 0.01,
                                    'HOPE': 0.01,
                                    'HPC': 0.01,
                                    'HUB': 1.0,
                                    'HYP': 0.01,
                                    'HYPER': 0.01,
                                    'IBC': 1.0,
                                    'ICE': 1.0,
                                    'ICOT': 1.0,
                                    'IFT': 1.0,
                                    'ILC': 0.01,
                                    'IMX': 0.01,
                                    'INDIA': 0.01,
                                    'INFO': 0.01,
                                    'INSN': 0.01,
                                    'INXT': 1.0,
                                    'IOE': 0.01,
                                    'IQT': 1.0,
                                    'IXC': 0.01,
                                    'JAPAN': 0.01,
                                    'JEDI': 0.01,
                                    'JET': 1.0,
                                    'JIN': 0.2,
                                    'KAYI': 0.01,
                                    'KB3': 0.01,
                                    'KGB': 0.01,
                                    'KLC': 0.1,
                                    'KMD': 0.01,
                                    'KOBO': 1.0,
                                    'KOI': 0.01,
                                    'KORUNA': 0.1,
                                    'KRA': 0.01,
                                    'KUBO': 0.01,
                                    'KURT': 0.01,
                                    'LA': 1.0,
                                    'LAMBO': 0.01,
                                    'LCT': 1.0,
                                    'LDC': 0.01,
                                    'LEVO': 0.1,
                                    'LIFE': 1.0,
                                    'LINDA': 0.01,
                                    'LINX': 0.01,
                                    'LIZ': 0.01,
                                    'LMC': 0.1,
                                    'LNK': 0.05,
                                    'LRC': 1.0,
                                    'LTC': 0.01,
                                    'LTG': 1.0,
                                    'LUCK': 0.01,
                                    'LUNA': 0.01,
                                    'LVPS': 0.01,
                                    'MAC': 2.0,
                                    'MAG': 0.01,
                                    'MALC': 0.01,
                                    'MARS': 0.01,
                                    'MARS2': 0.01,
                                    'MAXI': 0.01,
                                    'MAY': 0.01,
                                    'MBC': 0.01,
                                    'MBIT': 0.01,
                                    'MCB': 1.0,
                                    'MEC': 0.1,
                                    'MENTAL': 0.1,
                                    'MER': 0.1,
                                    'MET': 0.01,
                                    'MGM': 0.01,
                                    'MGT': 0.01,
                                    'MILO': 0.5,
                                    'MINEX': 1.0,
                                    'MINT': 1.0,
                                    'MIPS': 1.0,
                                    'MNX': 0.01,
                                    'MOIN': 0.1,
                                    'MOON': 0.1,
                                    'MSCN': 0.01,
                                    'MSP': 1.0,
                                    'MST': 0.1,
                                    'MTH': 1.0,
                                    'MUE': 0.1,
                                    'MUX': 1.0,
                                    'MXC': 0.01,
                                    'MXT': 0.1,
                                    'MYB': 1.0,
                                    'NBIT': 0.1,
                                    'NBX': 0.01,
                                    'NEOG': 1.0,
                                    'NEON': 0.01,
                                    'NLC2': 0.01,
                                    'NLG': 0.1,
                                    'NRN': 0.01,
                                    'NRO': 0.01,
                                    'NTC': 1.0,
                                    'NTO': 1.0,
                                    'NUA': 1.0,
                                    'NUMUS': 0.01,
                                    'OC': 0.01,
                                    'OGN': 0.01,
                                    'ORO': 0.01,
                                    'PARIS': 0.01,
                                    'PAYU': 0.1,
                                    'PCN': 1.0,
                                    'PCS': 0.01,
                                    'PDG': 0.01,
                                    'PEC': 0.01,
                                    'PGL': 1.0,
                                    'PHN': 1.0,
                                    'PICO': 0.1,
                                    'PIE': 0.01,
                                    'PIGGY': 0.1,
                                    'PIVX': 0.2,
                                    'PIX': 1.0,
                                    'PKT': 1.0,
                                    'PLACO': 0.01,
                                    'PLX': 1.0,
                                    'POL': 0.01,
                                    'POLOB': 0.1,
                                    'POS': 1.0,
                                    'POST': 1.0,
                                    'POSW': 0.01,
                                    'POT': 0.1,
                                    'PRE': 1.0,
                                    'PRIMU': 0.01,
                                    'PRL': 1.0,
                                    'PRN': 1.0,
                                    'PRX': 0.01,
                                    'PT': 1.0,
                                    'PTS': 1.0,
                                    'PURA': 1.0,
                                    'PURE': 0.01,
                                    'PUT': 0.1,
                                    'PWC': 0.01,
                                    'PWR': 0.1,
                                    'QTUM': 0.01,
                                    'QUANT': 0.01,
                                    'RAIN': 0.5,
                                    'RBL': 0.01,
                                    'RDC': 0.01,
                                    'REC': 0.01,
                                    'REGA': 0.1,
                                    'REX': 1.0,
                                    'RHO': 0.1,
                                    'RIYA': 1.0,
                                    'RMC': 2.0,
                                    'RNS': 0.01,
                                    'ROC': 0.0,
                                    'ROOFS': 0.01,
                                    'RUB': 0.01,
                                    'RUNE': 0.01,
                                    'RUNNERS': 0.01,
                                    'RUP': 0.01,
                                    'SBIT': 0.01,
                                    'SCL': 1.0,
                                    'SCORE': 0.01,
                                    'SCOREOLD': 0.01,
                                    'SDASH': 0.01,
                                    'SFC': 0.01,
                                    'SFE': 0.01,
                                    'SGR': 1.0,
                                    'SHIT': 0.1,
                                    'SHM': 0.1,
                                    'SHND': 0.1,
                                    'SHOT': 0.1,
                                    'SIC': 0.1,
                                    'SILK2': 0.01,
                                    'SIMP': 0.001,
                                    'SISA': 1.0,
                                    'SKOIN': 0.01,
                                    'SKULL': 0.01,
                                    'SLEVIN': 0.01,
                                    'SLR': 0.01,
                                    'SMART': 0.01,
                                    'SMS': 0.002,
                                    'SNOW': 0.01,
                                    'SOLAR': 0.01,
                                    'SPRTS': 1.0,
                                    'SRC': 0.01,
                                    'SST': 0.1,
                                    'STARS': 0.01,
                                    'STN': 0.01,
                                    'STO': 0.01,
                                    'STX': 1.0,
                                    'SUPER': 0.01,
                                    'SUPERMAN': 0.01,
                                    'SURGE': 0.01,
                                    'SWC': 0.1,
                                    'SYNQ': 0.01,
                                    'SYNX': 0.01,
                                    'TAAS': 2.0,
                                    'TBS': 0.01,
                                    'TCOIN': 0.01,
                                    'TELL': 0.1,
                                    'TER': 0.005,
                                    'TGT': 1.0,
                                    'TIGER': 0.01,
                                    'TIPS': 0.01,
                                    'TLE': 0.01,
                                    'TOPAZ': 0.01,
                                    'TOR': 0.01,
                                    'TPC': 0.01,
                                    'TPG': 0.01,
                                    'TPI': 1.0,
                                    'TRANCE': 0.01,
                                    'TRC': 0.01,
                                    'TRUX': 0.01,
                                    'TSE': 0.1,
                                    'TSTR': 0.01,
                                    'TURBO': 0.01,
                                    'UFO': 0.01,
                                    'UK': 0.01,
                                    'ULA': 0.01,
                                    'UNIFY': 0.0,
                                    'UNIT': 0.1,
                                    'UNO': 0.001,
                                    'UP': 0.01,
                                    'UQC': 1.0,
                                    'USA': 0.01,
                                    'VC': 0.01,
                                    'VGS': 0.01,
                                    'VIDZ': 0.01,
                                    'VISIO': 0.05,
                                    'VLTC': 0.1,
                                    'VOISE': 1.0,
                                    'VONE': 0.01,
                                    'VOX': 0.01,
                                    'VSX': 0.01,
                                    'VULCANO': 0.01,
                                    'WASH': 0.1,
                                    'WCL': 1.0,
                                    'WINK': 0.01,
                                    'WOMEN': 0.01,
                                    'WORM': 0.01,
                                    'WOW': 0.1,
                                    'WRP': 0.01,
                                    'WYV': 0.01,
                                    'XBC': 0.01,
                                    'XBL': 1.0,
                                    'XBU': 1.0,
                                    'XCHE': 0.1,
                                    'XCS': 0.01,
                                    'XCT': 0.01,
                                    'XCXT': 0.01,
                                    'XDE2': 0.01,
                                    'XEV': 0.1,
                                    'XGOX': 0.01,
                                    'XGTC': 0.01,
                                    'XLR': 0.1,
                                    'XMCC': 0.01,
                                    'XP': 1.0,
                                    'XPASC': 0.01,
                                    'XQN': 0.01,
                                    'XSA': 0.1,
                                    'XSTC': 2.0,
                                    'XTD': 0.01,
                                    'XVS': 0.01,
                                    'XXX': 0.1,
                                    'XYOC': 1.0,
                                    'XYZ': 0.01,
                                    'XZC': 0.1,
                                    'XZCD': 0.01,
                                    'YHC': 0.01,
                                    'ZCC': 0.01,
                                    'ZCG': 1.0,
                                    'ZCL': 0.001,
                                    'ZEC': 0.001,
                                    'ZEIT': 0.1,
                                    'ZENI': 0.01,
                                    'ZERO': 0.01,
                                    'ZMC': 0.1,
                                    'ZOI': 0.01,
                                    'ZSE': 0.01,
                                    'ZURMO': 0.1,
                                    'ZZC': 0.01,
                                },
                            },
                        },
                        'precision': {
                            'amount': 8,
                            'price': 8,
                        },
                    });
                };
                coinexchange.prototype.commonCurrencyCode = function (currency) {
                    var substitutions = {
                        'BON': 'BonPeKaO',
                        'ETN': 'Ethernex',
                        'HNC': 'Huncoin',
                        'MARS': 'MarsBux',
                    };
                    if (currency in substitutions)
                        return substitutions[currency];
                    return currency;
                };
                coinexchange.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, currencies, precision, result, i, currency, id, code, active, status_3;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetGetcurrencies(params)];
                                case 1:
                                    response = _a.sent();
                                    currencies = response['result'];
                                    precision = this.precision['amount'];
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['CurrencyID'];
                                        code = this.commonCurrencyCode(currency['TickerCode']);
                                        active = currency['WalletStatus'] === 'online';
                                        status_3 = 'ok';
                                        if (!active)
                                            status_3 = 'disabled';
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'name': currency['Name'],
                                            'active': active,
                                            'status': status_3,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': undefined,
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': undefined,
                                                    'max': Math.pow(10, precision),
                                                },
                                            },
                                            'info': currency,
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                coinexchange.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, i, market, id, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetGetmarkets()];
                                case 1:
                                    response = _a.sent();
                                    markets = response['result'];
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        id = market['MarketID'];
                                        base = this.commonCurrencyCode(market['MarketAssetCode']);
                                        quote = this.commonCurrencyCode(market['BaseCurrencyCode']);
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': market['MarketAssetID'],
                                            'quoteId': market['BaseCurrencyID'],
                                            'active': market['Active'],
                                            'lot': undefined,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                coinexchange.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (!market) {
                        var marketId = ticker['MarketID'];
                        if (marketId in this.markets_by_id)
                            market = this.markets_by_id[marketId];
                        else
                            symbol = marketId;
                    }
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = this.milliseconds();
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'HighPrice'),
                        'low': this.safeFloat(ticker, 'LowPrice'),
                        'bid': this.safeFloat(ticker, 'BidPrice'),
                        'ask': this.safeFloat(ticker, 'AskPrice'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'LastPrice'),
                        'change': this.safeFloat(ticker, 'Change'),
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': undefined,
                        'quoteVolume': this.safeFloat(ticker, 'Volume'),
                        'info': ticker,
                    };
                };
                coinexchange.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetGetmarketsummary(this.extend({
                                            'market_id': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker['result'], market)];
                            }
                        });
                    });
                };
                coinexchange.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, result, i, ticker, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetGetmarketsummaries(params)];
                                case 2:
                                    response = _a.sent();
                                    tickers = response['result'];
                                    result = {};
                                    for (i = 0; i < tickers.length; i++) {
                                        ticker = this.parseTicker(tickers[i]);
                                        symbol = ticker['symbol'];
                                        result[symbol] = ticker;
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                coinexchange.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetGetorderbook(this.extend({
                                            'market_id': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook['result'], undefined, 'BuyOrders', 'SellOrders', 'Price', 'Quantity')];
                            }
                        });
                    });
                };
                coinexchange.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + path;
                    if (api === 'public') {
                        params = this.urlencode(params);
                        if (params.length)
                            url += '?' + params;
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                coinexchange.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, success, message;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    success = this.safeInteger(response, 'success');
                                    if (success !== 1) {
                                        message = this.safeString(response, 'message', 'Error');
                                        throw new ExchangeError(message);
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return coinexchange;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 59: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(coinfloor, _super);
                function coinfloor() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coinfloor.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coinfloor',
                        'name': 'coinfloor',
                        'rateLimit': 1000,
                        'countries': 'UK',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28246081-623fc164-6a1c-11e7-913f-bac0d5576c90.jpg',
                            'api': 'https://webapi.coinfloor.co.uk:8090/bist',
                            'www': 'https://www.coinfloor.co.uk',
                            'doc': [
                                'https://github.com/coinfloor/api',
                                'https://www.coinfloor.co.uk/api',
                            ],
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': true,
                            'uid': true,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    '{id}/ticker/',
                                    '{id}/order_book/',
                                    '{id}/transactions/',
                                ],
                            },
                            'private': {
                                'post': [
                                    '{id}/balance/',
                                    '{id}/user_transactions/',
                                    '{id}/open_orders/',
                                    '{id}/cancel_order/',
                                    '{id}/buy/',
                                    '{id}/sell/',
                                    '{id}/buy_market/',
                                    '{id}/sell_market/',
                                    '{id}/estimate_sell_market/',
                                    '{id}/estimate_buy_market/',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/GBP': { 'id': 'XBT/GBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
                            'BTC/EUR': { 'id': 'XBT/EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                            'BTC/USD': { 'id': 'XBT/USD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                            'BTC/PLN': { 'id': 'XBT/PLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                            'BCH/GBP': { 'id': 'BCH/GBP', 'symbol': 'BCH/GBP', 'base': 'BCH', 'quote': 'GBP' },
                        },
                    });
                };
                coinfloor.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    var symbol = undefined;
                    if ('symbol' in params)
                        symbol = params['symbol'];
                    if ('id' in params)
                        symbol = params['id'];
                    if (!symbol)
                        throw new ExchangeError(this.id + ' fetchBalance requires a symbol param');
                    return this.privatePostIdBalance({
                        'id': this.marketId(symbol),
                    });
                };
                coinfloor.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetIdOrderBook(this.extend({
                                        'id': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                coinfloor.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var vwap = this.safeFloat(ticker, 'vwap');
                    var baseVolume = parseFloat(ticker['volume']);
                    var quoteVolume = undefined;
                    if (typeof vwap !== 'undefined') {
                        quoteVolume = baseVolume * vwap;
                    }
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['bid']),
                        'ask': parseFloat(ticker['ask']),
                        'vwap': vwap,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': baseVolume,
                        'quoteVolume': quoteVolume,
                        'info': ticker,
                    };
                };
                coinfloor.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetIdTicker(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                coinfloor.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['date'] * 1000;
                    return {
                        'info': trade,
                        'id': trade['tid'].toString(),
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                coinfloor.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetIdTransactions(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                coinfloor.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, method;
                        return __generator(this, function (_a) {
                            order = { 'id': this.marketId(symbol) };
                            method = 'privatePostId' + this.capitalize(side);
                            if (type === 'market') {
                                order['quantity'] = amount;
                                method += 'Market';
                            }
                            else {
                                order['price'] = price;
                                order['amount'] = amount;
                            }
                            return [2, this[method](this.extend(order, params))];
                        });
                    });
                };
                coinfloor.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostIdCancelOrder({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                coinfloor.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({ 'nonce': nonce }, query));
                        var auth = this.uid + '/' + this.apiKey + ':' + this.password;
                        var signature = this.stringToBase64(auth);
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Authorization': 'Basic ' + signature,
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return coinfloor;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 60: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(coingi, _super);
                function coingi() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coingi.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coingi',
                        'name': 'Coingi',
                        'rateLimit': 1000,
                        'countries': ['PA', 'BG', 'CN', 'US'],
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28619707-5c9232a8-7212-11e7-86d6-98fe5d15cc6e.jpg',
                            'api': {
                                'www': 'https://coingi.com',
                                'current': 'https://api.coingi.com',
                                'user': 'https://api.coingi.com',
                            },
                            'www': 'https://coingi.com',
                            'doc': 'http://docs.coingi.apiary.io/',
                        },
                        'api': {
                            'www': {
                                'get': [
                                    '',
                                ],
                            },
                            'current': {
                                'get': [
                                    'order-book/{pair}/{askCount}/{bidCount}/{depth}',
                                    'transactions/{pair}/{maxCount}',
                                    '24hour-rolling-aggregation',
                                ],
                            },
                            'user': {
                                'post': [
                                    'balance',
                                    'add-order',
                                    'cancel-order',
                                    'orders',
                                    'transactions',
                                    'create-crypto-withdrawal',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'taker': 0.2 / 100,
                                'maker': 0.2 / 100,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0.001,
                                    'LTC': 0.01,
                                    'DOGE': 2,
                                    'PPC': 0.02,
                                    'VTC': 0.2,
                                    'NMC': 2,
                                    'DASH': 0.002,
                                    'USD': 10,
                                    'EUR': 10,
                                },
                                'deposit': {
                                    'BTC': 0,
                                    'LTC': 0,
                                    'DOGE': 0,
                                    'PPC': 0,
                                    'VTC': 0,
                                    'NMC': 0,
                                    'DASH': 0,
                                    'USD': 5,
                                    'EUR': 1,
                                },
                            },
                        },
                    });
                };
                coingi.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, e_17, parts, currencyParts, result, i, currencyPart, idParts, id, symbol, _a, base, quote, precision, lot;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    response = undefined;
                                    _c.label = 1;
                                case 1:
                                    _c.trys.push([1, 3, , 4]);
                                    this.parseJsonResponse = false;
                                    return [4, this.wwwGet()];
                                case 2:
                                    response = _c.sent();
                                    this.parseJsonResponse = true;
                                    return [3, 4];
                                case 3:
                                    e_17 = _c.sent();
                                    this.parseJsonResponse = true;
                                    throw e_17;
                                case 4:
                                    parts = response.split('do=currencyPairSelector-selectCurrencyPair" class="active">');
                                    currencyParts = parts[1].split('<div class="currency-pair-label">');
                                    result = [];
                                    for (i = 1; i < currencyParts.length; i++) {
                                        currencyPart = currencyParts[i];
                                        idParts = currencyPart.split('</div>');
                                        id = idParts[0];
                                        symbol = id;
                                        id = id.replace('/', '-');
                                        id = id.toLowerCase();
                                        _a = __read(symbol.split('/'), 2), base = _a[0], quote = _a[1];
                                        precision = {
                                            'amount': 8,
                                            'price': 8,
                                        };
                                        lot = Math.pow(10, -precision['amount']);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': id,
                                            'lot': lot,
                                            'active': true,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': lot,
                                                    'max': Math.pow(10, precision['amount']),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision['price']),
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': 0,
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                coingi.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var lowercaseCurrencies, currencies, i, currency, balances, result, b, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    lowercaseCurrencies = [];
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercaseCurrencies.push(currency.toLowerCase());
                                    }
                                    return [4, this.userPostBalance({
                                            'currencies': lowercaseCurrencies.join(','),
                                        })];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency']['name'];
                                        currency = currency.toUpperCase();
                                        account = {
                                            'free': balance['available'],
                                            'used': balance['blocked'] + balance['inOrders'] + balance['withdrawing'],
                                            'total': 0.0,
                                        };
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                coingi.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = 512; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.currentGetOrderBookPairAskCountBidCountDepth(this.extend({
                                            'pair': market['id'],
                                            'depth': 32,
                                            'askCount': limit,
                                            'bidCount': limit,
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price', 'baseAmount')];
                            }
                        });
                    });
                };
                coingi.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': ticker['high'],
                        'low': ticker['low'],
                        'bid': ticker['highestBid'],
                        'ask': ticker['lowestAsk'],
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': undefined,
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': ticker['baseVolume'],
                        'quoteVolume': ticker['counterVolume'],
                        'info': ticker,
                    };
                };
                coingi.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, t, ticker, base, quote, symbol, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.currentGet24hourRollingAggregation(params)];
                                case 2:
                                    response = _a.sent();
                                    result = {};
                                    for (t = 0; t < response.length; t++) {
                                        ticker = response[t];
                                        base = ticker['currencyPair']['base'].toUpperCase();
                                        quote = ticker['currencyPair']['counter'].toUpperCase();
                                        symbol = base + '/' + quote;
                                        market = undefined;
                                        if (symbol in this.markets) {
                                            market = this.markets[symbol];
                                        }
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                coingi.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.fetchTickers(undefined, params)];
                                case 2:
                                    tickers = _a.sent();
                                    if (symbol in tickers)
                                        return [2, tickers[symbol]];
                                    throw new ExchangeError(this.id + ' return did not contain ' + symbol);
                            }
                        });
                    });
                };
                coingi.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    if (!market)
                        market = this.markets_by_id[trade['currencyPair']];
                    return {
                        'id': trade['id'],
                        'info': trade,
                        'timestamp': trade['timestamp'],
                        'datetime': this.iso8601(trade['timestamp']),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                coingi.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.currentGetTransactionsPairMaxCount(this.extend({
                                            'pair': market['id'],
                                            'maxCount': 128,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                coingi.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'currencyPair': this.marketId(symbol),
                                        'volume': amount,
                                        'price': price,
                                        'orderType': (side === 'buy') ? 0 : 1,
                                    };
                                    return [4, this.userPostAddOrder(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['result'],
                                        }];
                            }
                        });
                    });
                };
                coingi.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.userPostCancelOrder({ 'orderId': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                coingi.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'current'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    if (api !== 'www') {
                        url += '/' + api + '/' + this.implodeParams(path, params);
                    }
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'current') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else if (api === 'user') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var request = this.extend({
                            'token': this.apiKey,
                            'nonce': nonce,
                        }, query);
                        var auth = nonce.toString() + '$' + this.apiKey;
                        request['signature'] = this.hmac(this.encode(auth), this.encode(this.secret));
                        body = this.json(request);
                        headers = {
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                coingi.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'current'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (typeof response !== 'string') {
                                        if ('errors' in response)
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return coingi;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 61: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(coinmarketcap, _super);
                function coinmarketcap() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coinmarketcap.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coinmarketcap',
                        'name': 'CoinMarketCap',
                        'rateLimit': 10000,
                        'version': 'v1',
                        'countries': 'US',
                        'has': {
                            'CORS': true,
                            'privateAPI': false,
                            'createOrder': false,
                            'createMarketOrder': false,
                            'createLimitOrder': false,
                            'cancelOrder': false,
                            'editOrder': false,
                            'fetchBalance': false,
                            'fetchOrderBook': false,
                            'fetchOHLCV': false,
                            'fetchTrades': false,
                            'fetchTickers': true,
                            'fetchCurrencies': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28244244-9be6312a-69ed-11e7-99c1-7c1797275265.jpg',
                            'api': {
                                'public': 'https://api.coinmarketcap.com',
                                'files': 'https://files.coinmarketcap.com',
                                'charts': 'https://graph.coinmarketcap.com',
                            },
                            'www': 'https://coinmarketcap.com',
                            'doc': 'https://coinmarketcap.com/api',
                        },
                        'requiredCredentials': {
                            'apiKey': false,
                            'secret': false,
                        },
                        'api': {
                            'files': {
                                'get': [
                                    'generated/stats/global.json',
                                ],
                            },
                            'graphs': {
                                'get': [
                                    'currencies/{name}/',
                                ],
                            },
                            'public': {
                                'get': [
                                    'ticker/',
                                    'ticker/{id}/',
                                    'global/',
                                ],
                            },
                        },
                        'currencyCodes': [
                            'AUD',
                            'BRL',
                            'CAD',
                            'CHF',
                            'CNY',
                            'EUR',
                            'GBP',
                            'HKD',
                            'IDR',
                            'INR',
                            'JPY',
                            'KRW',
                            'MXN',
                            'RUB',
                            'USD',
                        ],
                    });
                };
                coinmarketcap.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new ExchangeError('Fetching order books is not supported by the API of ' + this.id);
                        });
                    });
                };
                coinmarketcap.prototype.currencyCode = function (base, name) {
                    var currencies = {
                        'BatCoin': 'BatCoin',
                        'Bitgem': 'Bitgem',
                        'BlockCAT': 'BlockCAT',
                        'Catcoin': 'Catcoin',
                        'Hi Mutual Society': 'Hi Mutual Society',
                        'iCoin': 'iCoin',
                        'NetCoin': 'NetCoin',
                        'MIOTA': 'IOTA',
                        'Maggie': 'Maggie',
                        'BlazeCoin': 'BlazeCoin',
                    };
                    if (name in currencies)
                        return currencies[name];
                    return base;
                };
                coinmarketcap.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, currencies, i, quote, quoteId, baseId, base, symbol, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTicker({
                                        'limit': 0,
                                    })];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        currencies = this.currencyCodes;
                                        for (i = 0; i < currencies.length; i++) {
                                            quote = currencies[i];
                                            quoteId = quote.toLowerCase();
                                            baseId = market['id'];
                                            base = this.currencyCode(market['symbol'], market['name']);
                                            symbol = base + '/' + quote;
                                            id = baseId + '/' + quoteId;
                                            result.push({
                                                'id': id,
                                                'symbol': symbol,
                                                'base': base,
                                                'quote': quote,
                                                'baseId': baseId,
                                                'quoteId': quoteId,
                                                'info': market,
                                            });
                                        }
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                coinmarketcap.prototype.fetchGlobal = function (currency) {
                    if (currency === void 0) { currency = 'USD'; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    if (currency)
                                        request['convert'] = currency;
                                    return [4, this.publicGetGlobal(request)];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                coinmarketcap.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    if ('last_updated' in ticker)
                        if (ticker['last_updated'])
                            timestamp = parseInt(ticker['last_updated']) * 1000;
                    var change = undefined;
                    if ('percent_change_24h' in ticker)
                        if (ticker['percent_change_24h'])
                            change = this.safeFloat(ticker, 'percent_change_24h');
                    var last = undefined;
                    var symbol = undefined;
                    var volume = undefined;
                    if (market) {
                        var priceKey = 'price_' + market['quoteId'];
                        if (priceKey in ticker)
                            if (ticker[priceKey])
                                last = this.safeFloat(ticker, priceKey);
                        symbol = market['symbol'];
                        var volumeKey = '24h_volume_' + market['quoteId'];
                        if (volumeKey in ticker)
                            if (ticker[volumeKey])
                                volume = this.safeFloat(ticker, volumeKey);
                    }
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': undefined,
                        'low': undefined,
                        'bid': undefined,
                        'ask': undefined,
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': last,
                        'change': change,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': undefined,
                        'quoteVolume': volume,
                        'info': ticker,
                    };
                };
                coinmarketcap.prototype.fetchTickers = function (currency, params) {
                    if (currency === void 0) { currency = 'USD'; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, tickers, t, ticker, id, symbol, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'limit': 10000,
                                    };
                                    if (currency)
                                        request['convert'] = currency;
                                    return [4, this.publicGetTicker(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    tickers = {};
                                    for (t = 0; t < response.length; t++) {
                                        ticker = response[t];
                                        id = ticker['id'] + '/' + currency;
                                        symbol = id;
                                        market = undefined;
                                        if (id in this.markets_by_id) {
                                            market = this.markets_by_id[id];
                                            symbol = market['symbol'];
                                        }
                                        tickers[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, tickers];
                            }
                        });
                    });
                };
                coinmarketcap.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = this.extend({
                                        'convert': market['quote'],
                                        'id': market['baseId'],
                                    }, params);
                                    return [4, this.publicGetTickerId(request)];
                                case 2:
                                    response = _a.sent();
                                    ticker = response[0];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                coinmarketcap.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencies, result, i, currency, id, name_1, precision, code;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTicker(this.extend({
                                        'limit': 0,
                                    }, params))];
                                case 1:
                                    currencies = _a.sent();
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['symbol'];
                                        name_1 = currency['name'];
                                        precision = 8;
                                        code = this.currencyCode(id, name_1);
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'info': currency,
                                            'name': name_1,
                                            'active': true,
                                            'status': 'ok',
                                            'fee': undefined,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                            },
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                coinmarketcap.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api] + '/' + this.version + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (Object.keys(query).length)
                        url += '?' + this.urlencode(query);
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                coinmarketcap.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('error' in response) {
                                        if (response['error']) {
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                        }
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return coinmarketcap;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 62: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(coinmate, _super);
                function coinmate() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coinmate.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coinmate',
                        'name': 'CoinMate',
                        'countries': ['GB', 'CZ', 'EU'],
                        'rateLimit': 1000,
                        'has': {
                            'CORS': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27811229-c1efb510-606c-11e7-9a36-84ba2ce412d8.jpg',
                            'api': 'https://coinmate.io/api',
                            'www': 'https://coinmate.io',
                            'doc': [
                                'http://docs.coinmate.apiary.io',
                                'https://coinmate.io/developers',
                            ],
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': true,
                            'uid': true,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'orderBook',
                                    'ticker',
                                    'transactions',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balances',
                                    'bitcoinWithdrawal',
                                    'bitcoinDepositAddresses',
                                    'buyInstant',
                                    'buyLimit',
                                    'cancelOrder',
                                    'cancelOrderWithInfo',
                                    'createVoucher',
                                    'openOrders',
                                    'redeemVoucher',
                                    'sellInstant',
                                    'sellLimit',
                                    'transactionHistory',
                                    'unconfirmedBitcoinDeposits',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/EUR': { 'id': 'BTC_EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'precision': { 'amount': 4, 'price': 2 } },
                            'BTC/CZK': { 'id': 'BTC_CZK', 'symbol': 'BTC/CZK', 'base': 'BTC', 'quote': 'CZK', 'precision': { 'amount': 4, 'price': 2 } },
                            'LTC/BTC': { 'id': 'LTC_BTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'precision': { 'amount': 4, 'price': 5 } },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.0005,
                                'taker': 0.0035,
                            },
                        },
                    });
                };
                coinmate.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, currencies, i, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostBalances()];
                                case 1:
                                    response = _a.sent();
                                    balances = response['data'];
                                    result = { 'info': balances };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        account = this.account();
                                        if (currency in balances) {
                                            account['free'] = balances[currency]['available'];
                                            account['used'] = balances[currency]['reserved'];
                                            account['total'] = balances[currency]['balance'];
                                        }
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                coinmate.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetOrderBook(this.extend({
                                        'currencyPair': this.marketId(symbol),
                                        'groupByPriceLimit': 'False',
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    orderbook = response['data'];
                                    timestamp = orderbook['timestamp'] * 1000;
                                    return [2, this.parseOrderBook(orderbook, timestamp, 'bids', 'asks', 'price', 'amount')];
                            }
                        });
                    });
                };
                coinmate.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTicker(this.extend({
                                        'currencyPair': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    ticker = response['data'];
                                    timestamp = ticker['timestamp'] * 1000;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['amount']),
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                coinmate.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    if (!market)
                        market = this.markets_by_id[trade['currencyPair']];
                    return {
                        'id': trade['transactionId'],
                        'info': trade,
                        'timestamp': trade['timestamp'],
                        'datetime': this.iso8601(trade['timestamp']),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                coinmate.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetTransactions(this.extend({
                                            'currencyPair': market['id'],
                                            'minutesIntoHistory': 10,
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['data'], market, since, limit)];
                            }
                        });
                    });
                };
                coinmate.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    method = 'privatePost' + this.capitalize(side);
                                    order = {
                                        'currencyPair': this.marketId(symbol),
                                    };
                                    if (type === 'market') {
                                        if (side === 'buy')
                                            order['total'] = amount;
                                        else
                                            order['amount'] = amount;
                                        method += 'Instant';
                                    }
                                    else {
                                        order['amount'] = amount;
                                        order['price'] = price;
                                        method += this.capitalize(type);
                                    }
                                    return [4, this[method](this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['data'].toString(),
                                        }];
                            }
                        });
                    });
                };
                coinmate.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancelOrder({ 'orderId': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                coinmate.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + path;
                    if (api === 'public') {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var auth = nonce + this.uid + this.apiKey;
                        var signature = this.hmac(this.encode(auth), this.encode(this.secret));
                        body = this.urlencode(this.extend({
                            'clientId': this.uid,
                            'nonce': nonce,
                            'publicKey': this.apiKey,
                            'signature': signature.toUpperCase(),
                        }, params));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                coinmate.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('error' in response)
                                        if (response['error'])
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return coinmate;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 63: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, NotSupported = _a.NotSupported;
            module.exports = (function (_super) {
                __extends(coinsecure, _super);
                function coinsecure() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coinsecure.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coinsecure',
                        'name': 'Coinsecure',
                        'countries': 'IN',
                        'rateLimit': 1000,
                        'version': 'v1',
                        'has': {
                            'CORS': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766472-9cbd200a-5ed9-11e7-9551-2267ad7bac08.jpg',
                            'api': 'https://api.coinsecure.in',
                            'www': 'https://coinsecure.in',
                            'doc': [
                                'https://api.coinsecure.in',
                                'https://github.com/coinsecure/plugins',
                            ],
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': false,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'bitcoin/search/confirmation/{txid}',
                                    'exchange/ask/low',
                                    'exchange/ask/orders',
                                    'exchange/bid/high',
                                    'exchange/bid/orders',
                                    'exchange/lastTrade',
                                    'exchange/max24Hr',
                                    'exchange/min24Hr',
                                    'exchange/ticker',
                                    'exchange/trades',
                                ],
                            },
                            'private': {
                                'get': [
                                    'mfa/authy/call',
                                    'mfa/authy/sms',
                                    'netki/search/{netkiName}',
                                    'user/bank/otp/{number}',
                                    'user/kyc/otp/{number}',
                                    'user/profile/phone/otp/{number}',
                                    'user/wallet/coin/address/{id}',
                                    'user/wallet/coin/deposit/confirmed/all',
                                    'user/wallet/coin/deposit/confirmed/{id}',
                                    'user/wallet/coin/deposit/unconfirmed/all',
                                    'user/wallet/coin/deposit/unconfirmed/{id}',
                                    'user/wallet/coin/wallets',
                                    'user/exchange/bank/fiat/accounts',
                                    'user/exchange/bank/fiat/balance/available',
                                    'user/exchange/bank/fiat/balance/pending',
                                    'user/exchange/bank/fiat/balance/total',
                                    'user/exchange/bank/fiat/deposit/cancelled',
                                    'user/exchange/bank/fiat/deposit/unverified',
                                    'user/exchange/bank/fiat/deposit/verified',
                                    'user/exchange/bank/fiat/withdraw/cancelled',
                                    'user/exchange/bank/fiat/withdraw/completed',
                                    'user/exchange/bank/fiat/withdraw/unverified',
                                    'user/exchange/bank/fiat/withdraw/verified',
                                    'user/exchange/ask/cancelled',
                                    'user/exchange/ask/completed',
                                    'user/exchange/ask/pending',
                                    'user/exchange/bid/cancelled',
                                    'user/exchange/bid/completed',
                                    'user/exchange/bid/pending',
                                    'user/exchange/bank/coin/addresses',
                                    'user/exchange/bank/coin/balance/available',
                                    'user/exchange/bank/coin/balance/pending',
                                    'user/exchange/bank/coin/balance/total',
                                    'user/exchange/bank/coin/deposit/cancelled',
                                    'user/exchange/bank/coin/deposit/unverified',
                                    'user/exchange/bank/coin/deposit/verified',
                                    'user/exchange/bank/coin/withdraw/cancelled',
                                    'user/exchange/bank/coin/withdraw/completed',
                                    'user/exchange/bank/coin/withdraw/unverified',
                                    'user/exchange/bank/coin/withdraw/verified',
                                    'user/exchange/bank/summary',
                                    'user/exchange/coin/fee',
                                    'user/exchange/fiat/fee',
                                    'user/exchange/kycs',
                                    'user/exchange/referral/coin/paid',
                                    'user/exchange/referral/coin/successful',
                                    'user/exchange/referral/fiat/paid',
                                    'user/exchange/referrals',
                                    'user/exchange/trade/summary',
                                    'user/login/token/{token}',
                                    'user/summary',
                                    'user/wallet/summary',
                                    'wallet/coin/withdraw/cancelled',
                                    'wallet/coin/withdraw/completed',
                                    'wallet/coin/withdraw/unverified',
                                    'wallet/coin/withdraw/verified',
                                ],
                                'post': [
                                    'login',
                                    'login/initiate',
                                    'login/password/forgot',
                                    'mfa/authy/initiate',
                                    'mfa/ga/initiate',
                                    'signup',
                                    'user/netki/update',
                                    'user/profile/image/update',
                                    'user/exchange/bank/coin/withdraw/initiate',
                                    'user/exchange/bank/coin/withdraw/newVerifycode',
                                    'user/exchange/bank/fiat/withdraw/initiate',
                                    'user/exchange/bank/fiat/withdraw/newVerifycode',
                                    'user/password/change',
                                    'user/password/reset',
                                    'user/wallet/coin/withdraw/initiate',
                                    'wallet/coin/withdraw/newVerifycode',
                                ],
                                'put': [
                                    'signup/verify/{token}',
                                    'user/exchange/kyc',
                                    'user/exchange/bank/fiat/deposit/new',
                                    'user/exchange/ask/new',
                                    'user/exchange/bid/new',
                                    'user/exchange/instant/buy',
                                    'user/exchange/instant/sell',
                                    'user/exchange/bank/coin/withdraw/verify',
                                    'user/exchange/bank/fiat/account/new',
                                    'user/exchange/bank/fiat/withdraw/verify',
                                    'user/mfa/authy/initiate/enable',
                                    'user/mfa/ga/initiate/enable',
                                    'user/netki/create',
                                    'user/profile/phone/new',
                                    'user/wallet/coin/address/new',
                                    'user/wallet/coin/new',
                                    'user/wallet/coin/withdraw/sendToExchange',
                                    'user/wallet/coin/withdraw/verify',
                                ],
                                'delete': [
                                    'user/gcm/{code}',
                                    'user/logout',
                                    'user/exchange/bank/coin/withdraw/unverified/cancel/{withdrawID}',
                                    'user/exchange/bank/fiat/deposit/cancel/{depositID}',
                                    'user/exchange/ask/cancel/{orderID}',
                                    'user/exchange/bid/cancel/{orderID}',
                                    'user/exchange/bank/fiat/withdraw/unverified/cancel/{withdrawID}',
                                    'user/mfa/authy/disable/{code}',
                                    'user/mfa/ga/disable/{code}',
                                    'user/profile/phone/delete',
                                    'user/profile/image/delete/{netkiName}',
                                    'user/wallet/coin/withdraw/unverified/cancel/{withdrawID}',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/INR': { 'id': 'BTC/INR', 'symbol': 'BTC/INR', 'base': 'BTC', 'quote': 'INR' },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.4 / 100,
                                'taker': 0.4 / 100,
                            },
                        },
                    });
                };
                coinsecure.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balance, coin, fiat, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetUserExchangeBankSummary()];
                                case 2:
                                    response = _a.sent();
                                    balance = response['message'];
                                    coin = {
                                        'free': balance['availableCoinBalance'],
                                        'used': balance['pendingCoinBalance'],
                                        'total': balance['totalCoinBalance'],
                                    };
                                    fiat = {
                                        'free': balance['availableFiatBalance'],
                                        'used': balance['pendingFiatBalance'],
                                        'total': balance['totalFiatBalance'],
                                    };
                                    result = {
                                        'info': balance,
                                        'BTC': coin,
                                        'INR': fiat,
                                    };
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                coinsecure.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var bids, asks, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetExchangeBidOrders(params)];
                                case 2:
                                    bids = _a.sent();
                                    return [4, this.publicGetExchangeAskOrders(params)];
                                case 3:
                                    asks = _a.sent();
                                    orderbook = {
                                        'bids': bids['message'],
                                        'asks': asks['message'],
                                    };
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'rate', 'vol')];
                            }
                        });
                    });
                };
                coinsecure.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, ticker, timestamp, baseVolume, satoshi, quoteVolume, vwap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetExchangeTicker(params)];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['message'];
                                    timestamp = ticker['timestamp'];
                                    baseVolume = parseFloat(ticker['coinvolume']);
                                    if (symbol === 'BTC/INR') {
                                        satoshi = 0.00000001;
                                        baseVolume = baseVolume * satoshi;
                                    }
                                    quoteVolume = parseFloat(ticker['fiatvolume']) / 100;
                                    vwap = quoteVolume / baseVolume;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']) / 100,
                                            'low': parseFloat(ticker['low']) / 100,
                                            'bid': parseFloat(ticker['bid']) / 100,
                                            'ask': parseFloat(ticker['ask']) / 100,
                                            'vwap': vwap,
                                            'open': parseFloat(ticker['open']) / 100,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['lastPrice']) / 100,
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                coinsecure.prototype.parseTrade = function (trade, symbol) {
                    if (symbol === void 0) { symbol = undefined; }
                    var timestamp = trade['time'];
                    var side = (trade['ordType'] === 'bid') ? 'buy' : 'sell';
                    return {
                        'id': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'order': undefined,
                        'symbol': symbol,
                        'type': undefined,
                        'side': side,
                        'price': this.safeFloat(trade, 'rate') / 100,
                        'amount': this.safeFloat(trade, 'vol') / 100000000,
                        'fee': undefined,
                        'info': trade,
                    };
                };
                coinsecure.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, result, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetExchangeTrades(params)];
                                case 2:
                                    result = _a.sent();
                                    if ('message' in result) {
                                        trades = result['message'];
                                        return [2, this.parseTrades(trades, market)];
                                    }
                                    return [2];
                            }
                        });
                    });
                };
                coinsecure.prototype.createOrder = function (market, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, order, direction, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = 'privatePutUserExchange';
                                    order = {};
                                    if (type === 'market') {
                                        method += 'Instant' + this.capitalize(side);
                                        if (side === 'buy')
                                            order['maxFiat'] = amount;
                                        else
                                            order['maxVol'] = amount;
                                    }
                                    else {
                                        direction = (side === 'buy') ? 'Bid' : 'Ask';
                                        method += direction + 'New';
                                        order['rate'] = price;
                                        order['vol'] = amount;
                                    }
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['message']['orderID'],
                                        }];
                            }
                        });
                    });
                };
                coinsecure.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    throw new NotSupported(this.id + ' cancelOrder () is not fully implemented yet');
                            }
                        });
                    });
                };
                coinsecure.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        headers = { 'Authorization': this.apiKey };
                        if (Object.keys(query).length) {
                            body = this.json(query);
                            headers['Content-Type'] = 'application/json';
                        }
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                coinsecure.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code === 200) {
                        if ((body[0] === '{') || (body[0] === '[')) {
                            var response = JSON.parse(body);
                            if ('success' in response) {
                                var success = response['success'];
                                if (!success) {
                                    throw new ExchangeError(this.id + ' error returned: ' + body);
                                }
                                if (!('message' in response)) {
                                    throw new ExchangeError(this.id + ' malformed response: no "message" in response: ' + body);
                                }
                            }
                            else {
                                throw new ExchangeError(this.id + ' malformed response: no "success" in response: ' + body);
                            }
                        }
                        else {
                            throw new ExchangeError(this.id + ' returned a non-JSON reply: ' + body);
                        }
                    }
                };
                return coinsecure;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 64: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError, NotSupported = _a.NotSupported;
            module.exports = (function (_super) {
                __extends(coinspot, _super);
                function coinspot() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coinspot.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coinspot',
                        'name': 'CoinSpot',
                        'countries': 'AU',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': false,
                            'createMarketOrder': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg',
                            'api': {
                                'public': 'https://www.coinspot.com.au/pubapi',
                                'private': 'https://www.coinspot.com.au/api',
                            },
                            'www': 'https://www.coinspot.com.au',
                            'doc': 'https://www.coinspot.com.au/api',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'latest',
                                ],
                            },
                            'private': {
                                'post': [
                                    'orders',
                                    'orders/history',
                                    'my/coin/deposit',
                                    'my/coin/send',
                                    'quote/buy',
                                    'quote/sell',
                                    'my/balances',
                                    'my/orders',
                                    'my/buy',
                                    'my/sell',
                                    'my/buy/cancel',
                                    'my/sell/cancel',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/AUD': { 'id': 'BTC', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
                            'LTC/AUD': { 'id': 'LTC', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD' },
                            'DOGE/AUD': { 'id': 'DOGE', 'symbol': 'DOGE/AUD', 'base': 'DOGE', 'quote': 'AUD' },
                        },
                    });
                };
                coinspot.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, balances, currencies, c, currency, uppercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostMyBalances()];
                                case 1:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    if ('balance' in response) {
                                        balances = response['balance'];
                                        currencies = Object.keys(balances);
                                        for (c = 0; c < currencies.length; c++) {
                                            currency = currencies[c];
                                            uppercase = currency.toUpperCase();
                                            account = {
                                                'free': balances[currency],
                                                'used': 0.0,
                                                'total': balances[currency],
                                            };
                                            if (uppercase === 'DRK')
                                                uppercase = 'DASH';
                                            result[uppercase] = account;
                                        }
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                coinspot.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.privatePostOrders(this.extend({
                                            'cointype': market['id'],
                                        }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    result = this.parseOrderBook(orderbook, undefined, 'buyorders', 'sellorders', 'rate', 'amount');
                                    result['bids'] = this.sortBy(result['bids'], 0, true);
                                    result['asks'] = this.sortBy(result['asks'], 0);
                                    return [2, result];
                            }
                        });
                    });
                };
                coinspot.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, id, ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetLatest(params)];
                                case 1:
                                    response = _a.sent();
                                    id = this.marketId(symbol);
                                    id = id.toLowerCase();
                                    ticker = response['prices'][id];
                                    timestamp = this.milliseconds();
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': undefined,
                                            'low': undefined,
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': undefined,
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                coinspot.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return this.privatePostOrdersHistory(this.extend({
                        'cointype': this.marketId(symbol),
                    }, params));
                };
                coinspot.prototype.createOrder = function (market, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    var method = 'privatePostMy' + this.capitalize(side);
                    if (type === 'market')
                        throw new ExchangeError(this.id + ' allows limit orders only');
                    var order = {
                        'cointype': this.marketId(market),
                        'amount': amount,
                        'rate': price,
                    };
                    return this[method](this.extend(order, params));
                };
                coinspot.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new NotSupported(this.id + ' cancelOrder () is not fully implemented yet');
                        });
                    });
                };
                coinspot.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    if (!this.apiKey)
                        throw new AuthenticationError(this.id + ' requires apiKey for all requests');
                    var url = this.urls['api'][api] + '/' + path;
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        body = this.json(this.extend({ 'nonce': nonce }, params));
                        headers = {
                            'Content-Type': 'application/json',
                            'key': this.apiKey,
                            'sign': this.hmac(this.encode(body), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return coinspot;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 65: [function (require, module, exports) {
            'use strict';
            var coinegg = require('./coinegg.js');
            module.exports = (function (_super) {
                __extends(coolcoin, _super);
                function coolcoin() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                coolcoin.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'coolcoin',
                        'name': 'CoolCoin',
                        'countries': 'HK',
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/36770529-be7b1a04-1c5b-11e8-9600-d11f1996b539.jpg',
                            'api': {
                                'web': 'https://www.coolcoin.com/coin',
                                'rest': 'https://www.coolcoin.com/api/v1',
                            },
                            'www': 'https://www.coolcoin.com',
                            'doc': 'https://www.coolcoin.com/help.api.html',
                            'fees': 'https://www.coolcoin.com/spend.price.html',
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.1 / 100,
                                'taker': 0.1 / 100,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.001,
                                    'BCH': 0.002,
                                    'ETH': 0.01,
                                    'ETC': 0.01,
                                    'LTC': 0.001,
                                    'TBC': '1%',
                                    'HSR': '1%',
                                    'NEO': '1%',
                                    'SDC': '1%',
                                    'EOS': '1%',
                                    'BTM': '1%',
                                    'XAS': '1%',
                                    'ACT': '1%',
                                    'SAK': '1%',
                                    'GCS': '1%',
                                    'HCC': '1%',
                                    'QTUM': '1%',
                                    'GEC': '1%',
                                    'TRX': '1%',
                                    'IFC': '1%',
                                    'PAY': '1%',
                                    'PGC': '1%',
                                    'KTC': '1%',
                                    'INT': '1%',
                                    'LSK': '0.5%',
                                    'SKT': '1%',
                                    'SSS': '1%',
                                    'BT1': '1%',
                                    'BT2': '1%',
                                },
                            },
                        },
                    });
                };
                return coolcoin;
            }(coinegg));
        }, { "./coinegg.js": 57 }], 66: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound, OrderNotCached = _a.OrderNotCached;
            module.exports = (function (_super) {
                __extends(cryptopia, _super);
                function cryptopia() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                cryptopia.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'cryptopia',
                        'name': 'Cryptopia',
                        'rateLimit': 1500,
                        'countries': 'NZ',
                        'has': {
                            'CORS': false,
                            'createMarketOrder': false,
                            'fetchClosedOrders': 'emulated',
                            'fetchCurrencies': true,
                            'fetchDepositAddress': true,
                            'fetchMyTrades': true,
                            'fetchOrder': 'emulated',
                            'fetchOrderBooks': true,
                            'fetchOrders': 'emulated',
                            'fetchOpenOrders': true,
                            'fetchTickers': true,
                            'deposit': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/29484394-7b4ea6e2-84c6-11e7-83e5-1fccf4b2dc81.jpg',
                            'api': 'https://www.cryptopia.co.nz/api',
                            'www': 'https://www.cryptopia.co.nz',
                            'doc': [
                                'https://www.cryptopia.co.nz/Forum/Category/45',
                                'https://www.cryptopia.co.nz/Forum/Thread/255',
                                'https://www.cryptopia.co.nz/Forum/Thread/256',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'GetCurrencies',
                                    'GetTradePairs',
                                    'GetMarkets',
                                    'GetMarkets/{id}',
                                    'GetMarkets/{hours}',
                                    'GetMarkets/{id}/{hours}',
                                    'GetMarket/{id}',
                                    'GetMarket/{id}/{hours}',
                                    'GetMarketHistory/{id}',
                                    'GetMarketHistory/{id}/{hours}',
                                    'GetMarketOrders/{id}',
                                    'GetMarketOrders/{id}/{count}',
                                    'GetMarketOrderGroups/{ids}',
                                    'GetMarketOrderGroups/{ids}/{count}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'CancelTrade',
                                    'GetBalance',
                                    'GetDepositAddress',
                                    'GetOpenOrders',
                                    'GetTradeHistory',
                                    'GetTransactions',
                                    'SubmitTip',
                                    'SubmitTrade',
                                    'SubmitTransfer',
                                    'SubmitWithdraw',
                                ],
                            },
                        },
                    });
                };
                cryptopia.prototype.commonCurrencyCode = function (currency) {
                    var currencies = {
                        'ACC': 'AdCoin',
                        'BAT': 'BatCoin',
                        'BLZ': 'BlazeCoin',
                        'CC': 'CCX',
                        'CMT': 'Comet',
                        'FCN': 'Facilecoin',
                        'NET': 'NetCoin',
                        'BTG': 'Bitgem',
                        'FUEL': 'FC2',
                        'QBT': 'Cubits',
                        'WRC': 'WarCoin',
                    };
                    if (currency in currencies)
                        return currencies[currency];
                    return currency;
                };
                cryptopia.prototype.currencyId = function (currency) {
                    var currencies = {
                        'AdCoin': 'ACC',
                        'BatCoin': 'BAT',
                        'BlazeCoin': 'BLZ',
                        'CCX': 'CC',
                        'Comet': 'CMT',
                        'Cubits': 'QBT',
                        'Facilecoin': 'FCN',
                        'NetCoin': 'NET',
                        'Bitgem': 'BTG',
                        'FC2': 'FUEL',
                    };
                    if (currency in currencies)
                        return currencies[currency];
                    return currency;
                };
                cryptopia.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, markets, i, market, id, symbol, base, quote, precision, lot, priceLimits, amountLimits, limits, active;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetGetTradePairs()];
                                case 1:
                                    response = _a.sent();
                                    result = [];
                                    markets = response['Data'];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        id = market['Id'];
                                        symbol = market['Label'];
                                        base = market['Symbol'];
                                        quote = market['BaseSymbol'];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': 8,
                                            'price': 8,
                                        };
                                        lot = market['MinimumTrade'];
                                        priceLimits = {
                                            'min': market['MinimumPrice'],
                                            'max': market['MaximumPrice'],
                                        };
                                        amountLimits = {
                                            'min': lot,
                                            'max': market['MaximumTrade'],
                                        };
                                        limits = {
                                            'amount': amountLimits,
                                            'price': priceLimits,
                                            'cost': {
                                                'min': priceLimits['min'] * amountLimits['min'],
                                                'max': undefined,
                                            },
                                        };
                                        active = market['Status'] === 'OK';
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                            'maker': market['TradeFee'] / 100,
                                            'taker': market['TradeFee'] / 100,
                                            'lot': limits['amount']['min'],
                                            'active': active,
                                            'precision': precision,
                                            'limits': limits,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cryptopia.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetGetMarketOrdersId(this.extend({
                                            'id': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['Data'];
                                    return [2, this.parseOrderBook(orderbook, undefined, 'Buy', 'Sell', 'Price', 'Volume')];
                            }
                        });
                    });
                };
                cryptopia.prototype.joinMarketIds = function (ids, glue) {
                    if (glue === void 0) { glue = '-'; }
                    var result = ids[0].toString();
                    for (var i = 1; i < ids.length; i++) {
                        result += glue + ids[i].toString();
                    }
                    return result;
                };
                cryptopia.prototype.fetchOrderBooks = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ids, numIds, response, orderbooks, result, i, orderbook, id, symbol, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    ids = undefined;
                                    if (!symbols) {
                                        numIds = this.ids.length;
                                        if (numIds > 2048)
                                            throw new ExchangeError(this.id + ' has ' + numIds.toString() + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks');
                                        ids = this.joinMarketIds(this.ids);
                                    }
                                    else {
                                        ids = this.joinMarketIds(this.marketIds(symbols));
                                    }
                                    return [4, this.publicGetGetMarketOrderGroupsIds(this.extend({
                                            'ids': ids,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbooks = response['Data'];
                                    result = {};
                                    for (i = 0; i < orderbooks.length; i++) {
                                        orderbook = orderbooks[i];
                                        id = this.safeInteger(orderbook, 'TradePairId');
                                        symbol = id;
                                        if (id in this.markets_by_id) {
                                            market = this.markets_by_id[id];
                                            symbol = market['symbol'];
                                        }
                                        result[symbol] = this.parseOrderBook(orderbook, undefined, 'Buy', 'Sell', 'Price', 'Volume');
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cryptopia.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var open = this.safeFloat(ticker, 'Open');
                    var last = this.safeFloat(ticker, 'LastPrice');
                    var change = last - open;
                    var baseVolume = this.safeFloat(ticker, 'Volume');
                    var quoteVolume = this.safeFloat(ticker, 'BaseVolume');
                    var vwap = undefined;
                    if (typeof quoteVolume !== 'undefined')
                        if (typeof baseVolume !== 'undefined')
                            if (baseVolume > 0)
                                vwap = quoteVolume / baseVolume;
                    return {
                        'symbol': symbol,
                        'info': ticker,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['High']),
                        'low': parseFloat(ticker['Low']),
                        'bid': parseFloat(ticker['BidPrice']),
                        'ask': parseFloat(ticker['AskPrice']),
                        'vwap': vwap,
                        'open': open,
                        'close': last,
                        'last': last,
                        'previousClose': undefined,
                        'change': change,
                        'percentage': parseFloat(ticker['Change']),
                        'average': this.sum(last, open) / 2,
                        'baseVolume': baseVolume,
                        'quoteVolume': quoteVolume,
                    };
                };
                cryptopia.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetGetMarketId(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['Data'];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                cryptopia.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, tickers, i, ticker, id, recognized, market, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetGetMarkets(params)];
                                case 2:
                                    response = _a.sent();
                                    result = {};
                                    tickers = response['Data'];
                                    for (i = 0; i < tickers.length; i++) {
                                        ticker = tickers[i];
                                        id = ticker['TradePairId'];
                                        recognized = (id in this.markets_by_id);
                                        if (!recognized)
                                            throw new ExchangeError(this.id + ' fetchTickers() returned unrecognized pair id ' + id.toString());
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cryptopia.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = undefined;
                    if ('Timestamp' in trade) {
                        timestamp = trade['Timestamp'] * 1000;
                    }
                    else if ('TimeStamp' in trade) {
                        timestamp = this.parse8601(trade['TimeStamp']);
                    }
                    var price = this.safeFloat(trade, 'Price');
                    if (!price)
                        price = this.safeFloat(trade, 'Rate');
                    var cost = this.safeFloat(trade, 'Total');
                    var id = this.safeString(trade, 'TradeId');
                    if (!market) {
                        if ('TradePairId' in trade)
                            if (trade['TradePairId'] in this.markets_by_id)
                                market = this.markets_by_id[trade['TradePairId']];
                    }
                    var symbol = undefined;
                    var fee = undefined;
                    if (market) {
                        symbol = market['symbol'];
                        if ('Fee' in trade) {
                            fee = {
                                'currency': market['quote'],
                                'cost': trade['Fee'],
                            };
                        }
                    }
                    return {
                        'id': id,
                        'info': trade,
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': 'limit',
                        'side': trade['Type'].toLowerCase(),
                        'price': price,
                        'cost': cost,
                        'amount': trade['Amount'],
                        'fee': fee,
                    };
                };
                cryptopia.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, hours, elapsed, hour, request, response, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    hours = 24;
                                    if (typeof since !== 'undefined') {
                                        elapsed = this.milliseconds() - since;
                                        hour = 1000 * 60 * 60;
                                        hours = parseInt(elapsed / hour);
                                    }
                                    request = {
                                        'id': market['id'],
                                        'hours': hours,
                                    };
                                    return [4, this.publicGetGetMarketHistoryIdHours(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    trades = response['Data'];
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                cryptopia.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    market = undefined;
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['TradePairId'] = market['id'];
                                    }
                                    return [4, this.privatePostGetTradeHistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['Data'], market, since, limit)];
                            }
                        });
                    });
                };
                cryptopia.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, currencies, result, i, currency, id, precision, code, active, status_4;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetGetCurrencies(params)];
                                case 1:
                                    response = _a.sent();
                                    currencies = response['Data'];
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['Symbol'];
                                        precision = 8;
                                        code = this.commonCurrencyCode(id);
                                        active = (currency['ListingStatus'] === 'Active');
                                        status_4 = currency['Status'].toLowerCase();
                                        if (status_4 !== 'ok')
                                            active = false;
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'info': currency,
                                            'name': currency['Name'],
                                            'active': active,
                                            'status': status_4,
                                            'fee': currency['WithdrawFee'],
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': currency['MinBaseTrade'],
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': currency['MinWithdraw'],
                                                    'max': currency['MaxWithdraw'],
                                                },
                                            },
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cryptopia.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, i, balance, code, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetBalance()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['Data'];
                                    result = { 'info': response };
                                    for (i = 0; i < balances.length; i++) {
                                        balance = balances[i];
                                        code = balance['Symbol'];
                                        currency = this.commonCurrencyCode(code);
                                        account = {
                                            'free': balance['Available'],
                                            'used': 0.0,
                                            'total': balance['Total'],
                                        };
                                        account['used'] = account['total'] - account['free'];
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                cryptopia.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, id, filled, filledOrders, filledOrdersLength, timestamp, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'TradePairId': market['id'],
                                        'Type': this.capitalize(side),
                                        'Rate': price,
                                        'Amount': amount,
                                    };
                                    return [4, this.privatePostSubmitTrade(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    if (!response)
                                        throw new ExchangeError(this.id + ' createOrder returned unknown error: ' + this.json(response));
                                    id = undefined;
                                    filled = 0.0;
                                    if ('Data' in response) {
                                        if ('OrderId' in response['Data']) {
                                            if (response['Data']['OrderId']) {
                                                id = response['Data']['OrderId'].toString();
                                            }
                                        }
                                        if ('FilledOrders' in response['Data']) {
                                            filledOrders = response['Data']['FilledOrders'];
                                            filledOrdersLength = filledOrders.length;
                                            if (filledOrdersLength) {
                                                filled = undefined;
                                            }
                                        }
                                    }
                                    timestamp = this.milliseconds();
                                    order = {
                                        'id': id,
                                        'timestamp': timestamp,
                                        'datetime': this.iso8601(timestamp),
                                        'status': 'open',
                                        'symbol': symbol,
                                        'type': type,
                                        'side': side,
                                        'price': price,
                                        'cost': price * amount,
                                        'amount': amount,
                                        'remaining': amount,
                                        'filled': filled,
                                        'fee': undefined,
                                    };
                                    if (id)
                                        this.orders[id] = order;
                                    return [2, this.extend({ 'info': response }, order)];
                            }
                        });
                    });
                };
                cryptopia.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, e_18, message;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    response = undefined;
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 4, , 5]);
                                    return [4, this.privatePostCancelTrade(this.extend({
                                            'Type': 'Trade',
                                            'OrderId': id,
                                        }, params))];
                                case 3:
                                    response = _a.sent();
                                    if (id in this.orders)
                                        this.orders[id]['status'] = 'canceled';
                                    return [3, 5];
                                case 4:
                                    e_18 = _a.sent();
                                    if (this.last_json_response) {
                                        message = this.safeString(this.last_json_response, 'Error');
                                        if (message) {
                                            if (message.indexOf('does not exist') >= 0)
                                                throw new OrderNotFound(this.id + ' cancelOrder() error: ' + this.last_http_response);
                                        }
                                    }
                                    throw e_18;
                                case 5: return [2, response];
                            }
                        });
                    });
                };
                cryptopia.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    else if ('Market' in order) {
                        var id = order['Market'];
                        if (id in this.markets_by_id) {
                            market = this.markets_by_id[id];
                            symbol = market['symbol'];
                        }
                    }
                    var timestamp = this.parse8601(order['TimeStamp']);
                    var amount = this.safeFloat(order, 'Amount');
                    var remaining = this.safeFloat(order, 'Remaining');
                    var filled = amount - remaining;
                    return {
                        'id': order['OrderId'].toString(),
                        'info': this.omit(order, 'status'),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': order['status'],
                        'symbol': symbol,
                        'type': 'limit',
                        'side': order['Type'].toLowerCase(),
                        'price': this.safeFloat(order, 'Rate'),
                        'cost': this.safeFloat(order, 'Total'),
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'fee': undefined,
                    };
                };
                cryptopia.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, orders, i, openOrders, j, openOrdersIndexedById, cachedOrderIds, result, k, id, order_1, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOrders requires a symbol param');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostGetOpenOrders({
                                            'TradePairId': market['id'],
                                        }, params)];
                                case 2:
                                    response = _a.sent();
                                    orders = [];
                                    for (i = 0; i < response['Data'].length; i++) {
                                        orders.push(this.extend(response['Data'][i], { 'status': 'open' }));
                                    }
                                    openOrders = this.parseOrders(orders, market);
                                    for (j = 0; j < openOrders.length; j++) {
                                        this.orders[openOrders[j]['id']] = openOrders[j];
                                    }
                                    openOrdersIndexedById = this.indexBy(openOrders, 'id');
                                    cachedOrderIds = Object.keys(this.orders);
                                    result = [];
                                    for (k = 0; k < cachedOrderIds.length; k++) {
                                        id = cachedOrderIds[k];
                                        if (id in openOrdersIndexedById) {
                                            this.orders[id] = this.extend(this.orders[id], openOrdersIndexedById[id]);
                                        }
                                        else {
                                            order_1 = this.orders[id];
                                            if (order_1['status'] === 'open') {
                                                this.orders[id] = this.extend(order_1, {
                                                    'status': 'closed',
                                                    'cost': order_1['amount'] * order_1['price'],
                                                    'filled': order_1['amount'],
                                                    'remaining': 0.0,
                                                });
                                            }
                                        }
                                        order = this.orders[id];
                                        if (order['symbol'] === symbol)
                                            result.push(order);
                                    }
                                    return [2, this.filterBySinceLimit(result, since, limit)];
                            }
                        });
                    });
                };
                cryptopia.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    id = id.toString();
                                    return [4, this.fetchOrders(symbol, undefined, undefined, params)];
                                case 1:
                                    orders = _a.sent();
                                    for (i = 0; i < orders.length; i++) {
                                        if (orders[i]['id'] === id)
                                            return [2, orders[i]];
                                    }
                                    throw new OrderNotCached(this.id + ' order ' + id + ' not found in cached .orders, fetchOrder requires .orders (de)serialization implemented for this method to work properly');
                            }
                        });
                    });
                };
                cryptopia.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders, result, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    result = [];
                                    for (i = 0; i < orders.length; i++) {
                                        if (orders[i]['status'] === 'open')
                                            result.push(orders[i]);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cryptopia.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders, result, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    result = [];
                                    for (i = 0; i < orders.length; i++) {
                                        if (orders[i]['status'] === 'closed')
                                            result.push(orders[i]);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                cryptopia.prototype.fetchDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencyId, response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    currencyId = this.currencyId(currency);
                                    return [4, this.privatePostGetDepositAddress(this.extend({
                                            'Currency': currencyId,
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    address = this.safeString(response['Data'], 'BaseAddress');
                                    if (!address)
                                        address = this.safeString(response['Data'], 'Address');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                cryptopia.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencyId, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    currencyId = this.currencyId(currency);
                                    request = {
                                        'Currency': currencyId,
                                        'Amount': amount,
                                        'Address': address,
                                    };
                                    if (tag)
                                        request['PaymentId'] = tag;
                                    return [4, this.privatePostSubmitWithdraw(this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['Data'],
                                        }];
                            }
                        });
                    });
                };
                cryptopia.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        body = this.json(query, { 'convertArraysToObjects': true });
                        var hash = this.hash(this.encode(body), 'md5', 'base64');
                        var secret = this.base64ToBinary(this.secret);
                        var uri = this.encodeURIComponent(url);
                        var lowercase = uri.toLowerCase();
                        hash = this.binaryToString(hash);
                        var payload = this.apiKey + method + lowercase + nonce + hash;
                        var signature = this.hmac(this.encode(payload), secret, 'sha256', 'base64');
                        var auth = 'amx ' + this.apiKey + ':' + this.binaryToString(signature) + ':' + nonce;
                        headers = {
                            'Content-Type': 'application/json',
                            'Authorization': auth,
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                cryptopia.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (response) {
                                        if ('Success' in response)
                                            if (response['Success']) {
                                                return [2, response];
                                            }
                                            else if ('Error' in response) {
                                                if (response['Error'] === 'Insufficient Funds.')
                                                    throw new InsufficientFunds(this.id + ' ' + this.json(response));
                                            }
                                    }
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                return cryptopia;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 67: [function (require, module, exports) {
            'use strict';
            var liqui = require('./liqui.js');
            module.exports = (function (_super) {
                __extends(dsx, _super);
                function dsx() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                dsx.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'dsx',
                        'name': 'DSX',
                        'countries': 'UK',
                        'rateLimit': 1500,
                        'has': {
                            'CORS': false,
                            'fetchOrder': true,
                            'fetchOrders': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'fetchTickers': true,
                            'fetchMyTrades': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27990275-1413158a-645a-11e7-931c-94717f7510e3.jpg',
                            'api': {
                                'public': 'https://dsx.uk/mapi',
                                'private': 'https://dsx.uk/tapi',
                                'dwapi': 'https://dsx.uk/dwapi',
                            },
                            'www': 'https://dsx.uk',
                            'doc': [
                                'https://api.dsx.uk',
                                'https://dsx.uk/api_docs/public',
                                'https://dsx.uk/api_docs/private',
                                '',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'barsFromMoment/{id}/{period}/{start}',
                                    'depth/{pair}',
                                    'info',
                                    'lastBars/{id}/{period}/{amount}',
                                    'periodBars/{id}/{period}/{start}/{end}',
                                    'ticker/{pair}',
                                    'trades/{pair}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'getInfo',
                                    'TransHistory',
                                    'TradeHistory',
                                    'OrderHistory',
                                    'ActiveOrders',
                                    'Trade',
                                    'CancelOrder',
                                ],
                            },
                            'dwapi': {
                                'post': [
                                    'getCryptoDepositAddress',
                                    'cryptoWithdraw',
                                    'fiatWithdraw',
                                    'getTransactionStatus',
                                    'getTransactions',
                                ],
                            },
                        },
                    });
                };
                dsx.prototype.getBaseQuoteFromMarketId = function (id) {
                    var uppercase = id.toUpperCase();
                    var base = uppercase.slice(0, 3);
                    var quote = uppercase.slice(3, 6);
                    base = this.commonCurrencyCode(base);
                    quote = this.commonCurrencyCode(quote);
                    return [base, quote];
                };
                dsx.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, funds, currencies, c, currency, uppercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetInfo()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['return'];
                                    result = { 'info': balances };
                                    funds = balances['funds'];
                                    currencies = Object.keys(funds);
                                    for (c = 0; c < currencies.length; c++) {
                                        currency = currencies[c];
                                        uppercase = currency.toUpperCase();
                                        uppercase = this.commonCurrencyCode(uppercase);
                                        account = {
                                            'free': funds[currency],
                                            'used': 0.0,
                                            'total': balances['total'][currency],
                                        };
                                        account['used'] = account['total'] - account['free'];
                                        result[uppercase] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                dsx.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['updated'] * 1000;
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var average = this.safeFloat(ticker, 'avg');
                    if (typeof average !== 'undefined')
                        if (average > 0)
                            average = 1 / average;
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high'),
                        'low': this.safeFloat(ticker, 'low'),
                        'bid': this.safeFloat(ticker, 'buy'),
                        'ask': this.safeFloat(ticker, 'sell'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last'),
                        'change': undefined,
                        'percentage': undefined,
                        'average': average,
                        'baseVolume': this.safeFloat(ticker, 'vol'),
                        'quoteVolume': this.safeFloat(ticker, 'vol_cur'),
                        'info': ticker,
                    };
                };
                dsx.prototype.getOrderIdKey = function () {
                    return 'orderId';
                };
                dsx.prototype.signBodyWithSecret = function (body) {
                    return this.decode(this.hmac(this.encode(body), this.encode(this.secret), 'sha512', 'base64'));
                };
                dsx.prototype.getVersionString = function () {
                    return '';
                };
                return dsx;
            }(liqui));
        }, { "./liqui.js": 90 }], 68: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(exmo, _super);
                function exmo() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                exmo.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'exmo',
                        'name': 'EXMO',
                        'countries': ['ES', 'RU'],
                        'rateLimit': 350,
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                            'fetchOrder': true,
                            'fetchOpenOrders': true,
                            'fetchOrderTrades': true,
                            'fetchOrderBooks': true,
                            'fetchMyTrades': true,
                            'fetchTickers': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg',
                            'api': 'https://api.exmo.com',
                            'www': 'https://exmo.me',
                            'doc': [
                                'https://exmo.me/en/api_doc',
                                'https://github.com/exmo-dev/exmo_api_lib/tree/master/nodejs',
                            ],
                            'fees': 'https://exmo.com/en/docs/fees',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'currency',
                                    'order_book',
                                    'pair_settings',
                                    'ticker',
                                    'trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    'user_info',
                                    'order_create',
                                    'order_cancel',
                                    'user_open_orders',
                                    'user_trades',
                                    'user_cancelled_orders',
                                    'order_trades',
                                    'required_amount',
                                    'deposit_address',
                                    'withdraw_crypt',
                                    'withdraw_get_txid',
                                    'excode_create',
                                    'excode_load',
                                    'wallet_history',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.2 / 100,
                                'taker': 0.2 / 100,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.001,
                                    'LTC': 0.01,
                                    'DOGE': 1,
                                    'DASH': 0.01,
                                    'ETH': 0.01,
                                    'WAVES': 0.001,
                                    'ZEC': 0.001,
                                    'USDT': 25,
                                    'XMR': 0.05,
                                    'XRP': 0.02,
                                    'KICK': 350,
                                    'ETC': 0.01,
                                    'BCH': 0.001,
                                },
                                'deposit': {
                                    'USDT': 15,
                                    'KICK': 50,
                                },
                            },
                        },
                    });
                };
                exmo.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, keys, result, p, id, market, symbol, _a, base, quote;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetPairSettings()];
                                case 1:
                                    markets = _c.sent();
                                    keys = Object.keys(markets);
                                    result = [];
                                    for (p = 0; p < keys.length; p++) {
                                        id = keys[p];
                                        market = markets[id];
                                        symbol = id.replace('_', '/');
                                        _a = __read(symbol.split('/'), 2), base = _a[0], quote = _a[1];
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'limits': {
                                                'amount': {
                                                    'min': market['min_quantity'],
                                                    'max': market['max_quantity'],
                                                },
                                                'price': {
                                                    'min': market['min_price'],
                                                    'max': market['max_price'],
                                                },
                                                'cost': {
                                                    'min': market['min_amount'],
                                                    'max': market['max_amount'],
                                                },
                                            },
                                            'precision': {
                                                'amount': 8,
                                                'price': 8,
                                            },
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                exmo.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, currencies, i, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostUserInfo()];
                                case 2:
                                    response = _a.sent();
                                    result = { 'info': response };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        account = this.account();
                                        if (currency in response['balances'])
                                            account['free'] = parseFloat(response['balances'][currency]);
                                        if (currency in response['reserved'])
                                            account['used'] = parseFloat(response['reserved'][currency]);
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                exmo.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, result, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = this.extend({
                                        'pair': market['id'],
                                    }, params);
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetOrderBook(request)];
                                case 2:
                                    response = _a.sent();
                                    result = response[market['id']];
                                    orderbook = this.parseOrderBook(result, undefined, 'bid', 'ask');
                                    return [2, this.extend(orderbook, {
                                            'bids': this.sortBy(orderbook['bids'], 0, true),
                                            'asks': this.sortBy(orderbook['asks'], 0),
                                        })];
                            }
                        });
                    });
                };
                exmo.prototype.fetchOrderBooks = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ids, numIds, response, result, i, id, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    ids = undefined;
                                    if (!symbols) {
                                        ids = this.ids.join(',');
                                        if (ids.length > 2048) {
                                            numIds = this.ids.length;
                                            throw new ExchangeError(this.id + ' has ' + numIds.toString() + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks');
                                        }
                                    }
                                    else {
                                        ids = this.marketIds(symbols);
                                        ids = ids.join(',');
                                    }
                                    return [4, this.publicGetOrderBook(this.extend({
                                            'pair': ids,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    result = {};
                                    ids = Object.keys(response);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        symbol = this.findSymbol(id);
                                        result[symbol] = this.parseOrderBook(response[id], undefined, 'bid', 'ask');
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                exmo.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['updated'] * 1000;
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var last = parseFloat(ticker['last_trade']);
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['buy_price']),
                        'ask': parseFloat(ticker['sell_price']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': last,
                        'last': last,
                        'previousClose': undefined,
                        'change': undefined,
                        'percentage': undefined,
                        'average': parseFloat(ticker['avg']),
                        'baseVolume': parseFloat(ticker['vol']),
                        'quoteVolume': parseFloat(ticker['vol_curr']),
                        'info': ticker,
                    };
                };
                exmo.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result, ids, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker(params)];
                                case 2:
                                    response = _a.sent();
                                    result = {};
                                    ids = Object.keys(response);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = response[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                exmo.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker(params)];
                                case 2:
                                    response = _a.sent();
                                    market = this.market(symbol);
                                    return [2, this.parseTicker(response[market['id']], market)];
                            }
                        });
                    });
                };
                exmo.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['date'] * 1000;
                    return {
                        'id': trade['trade_id'].toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'order': this.safeString(trade, 'order_id'),
                        'type': undefined,
                        'side': trade['type'],
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['quantity']),
                        'cost': this.safeFloat(trade, 'amount'),
                    };
                };
                exmo.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrades(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response[market['id']], market, since, limit)];
                            }
                        });
                    });
                };
                exmo.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    market = undefined;
                                    if (typeof symbol !== 'undefined') {
                                        market = this.market(symbol);
                                        request['pair'] = market['id'];
                                    }
                                    return [4, this.privatePostUserTrades(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    if (typeof market !== 'undefined')
                                        response = response[market['id']];
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                exmo.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (type === 'market') {
                                        price = '0';
                                        type = type + '_';
                                    }
                                    type += side;
                                    request = {
                                        'pair': this.marketId(symbol),
                                        'quantity': amount,
                                        'type': type,
                                        'price': price,
                                    };
                                    return [4, this.privatePostOrderCreate(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['order_id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                exmo.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrderCancel({ 'order_id': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                exmo.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (typeof symbol !== 'undefined')
                                        market = this.market(symbol);
                                    return [4, this.privatePostOrderTrades(this.extend({ 'order_id': id }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response, market)];
                            }
                        });
                    });
                };
                exmo.prototype.fetchOrderTrades = function (id, symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = undefined;
                                    if (!(typeof symbol !== 'undefined')) return [3, 2];
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    _a.label = 2;
                                case 2:
                                    request = {
                                        'order_id': id,
                                    };
                                    return [4, this.privatePostOrderTrades(this.extend(request, params))];
                                case 3:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['trades'], market, since, limit)];
                            }
                        });
                    });
                };
                exmo.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orders, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = undefined;
                                    if (!(typeof symbol !== 'undefined')) return [3, 2];
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    _a.label = 2;
                                case 2: return [4, this.privatePostUserOpenOrders()];
                                case 3:
                                    orders = _a.sent();
                                    if (typeof market !== 'undefined') {
                                        id = market['id'];
                                        orders = (id in orders) ? orders[id] : [];
                                    }
                                    return [2, this.parseOrders(orders, market, since, limit)];
                            }
                        });
                    });
                };
                exmo.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var id = this.safeString(order, 'order_id');
                    var timestamp = this.safeInteger(order, 'created');
                    if (typeof timestamp !== 'undefined')
                        timestamp *= 1000;
                    var iso8601 = undefined;
                    var symbol = undefined;
                    var side = this.safeString(order, 'type');
                    if (typeof market === 'undefined') {
                        var marketId = undefined;
                        if ('pair' in order) {
                            marketId = order['pair'];
                        }
                        else if (('in_currency' in order) && ('out_currency' in order)) {
                            if (side === 'buy')
                                marketId = order['in_currency'] + '_' + order['out_currency'];
                            else
                                marketId = order['out_currency'] + '_' + order['in_currency'];
                        }
                        if ((typeof marketId !== 'undefined') && (marketId in this.markets_by_id))
                            market = this.markets_by_id[marketId];
                    }
                    var amount = this.safeFloat(order, 'quantity');
                    if (typeof amount === 'undefined') {
                        var amountField = (side === 'buy') ? 'in_amount' : 'out_amount';
                        amount = this.safeFloat(order, amountField);
                    }
                    var price = this.safeFloat(order, 'price');
                    var cost = this.safeFloat(order, 'amount');
                    var filled = 0.0;
                    var trades = [];
                    var transactions = this.safeValue(order, 'trades');
                    var feeCost = undefined;
                    if (typeof transactions !== 'undefined') {
                        if (Array.isArray(transactions)) {
                            for (var i = 0; i < transactions.length; i++) {
                                var trade = this.parseTrade(transactions[i], market);
                                if (typeof id === 'undefined')
                                    id = trade['order'];
                                if (typeof timestamp === 'undefined')
                                    timestamp = trade['timestamp'];
                                if (timestamp > trade['timestamp'])
                                    timestamp = trade['timestamp'];
                                filled += trade['amount'];
                                if (typeof feeCost === 'undefined')
                                    feeCost = 0.0;
                                if (typeof cost === 'undefined')
                                    cost = 0.0;
                                cost += trade['cost'];
                                trades.push(trade);
                            }
                        }
                    }
                    if (typeof timestamp !== 'undefined')
                        iso8601 = this.iso8601(timestamp);
                    var remaining = undefined;
                    if (typeof amount !== 'undefined')
                        remaining = amount - filled;
                    var status = this.safeString(order, 'status');
                    if (filled >= amount)
                        status = 'closed';
                    else
                        status = 'open';
                    if (typeof market === 'undefined')
                        market = this.getMarketFromTrades(trades);
                    var feeCurrency = undefined;
                    if (typeof market !== 'undefined') {
                        symbol = market['symbol'];
                        feeCurrency = market['quote'];
                    }
                    if (typeof cost === 'undefined') {
                        if (typeof price !== 'undefined')
                            cost = price * filled;
                    }
                    else if (typeof price === 'undefined') {
                        if (filled > 0)
                            price = cost / filled;
                    }
                    var fee = {
                        'cost': feeCost,
                        'currency': feeCurrency,
                    };
                    return {
                        'id': id,
                        'datetime': iso8601,
                        'timestamp': timestamp,
                        'status': status,
                        'symbol': symbol,
                        'type': undefined,
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'trades': trades,
                        'fee': fee,
                        'info': order,
                    };
                };
                exmo.prototype.getMarketFromTrades = function (trades) {
                    var tradesBySymbol = this.indexBy(trades, 'pair');
                    var symbols = Object.keys(tradesBySymbol);
                    var numSymbols = symbols.length;
                    if (numSymbols === 1)
                        return this.markets[symbols[0]];
                    return undefined;
                };
                exmo.prototype.calculateFee = function (symbol, type, side, amount, price, takerOrMaker, params) {
                    if (takerOrMaker === void 0) { takerOrMaker = 'taker'; }
                    if (params === void 0) { params = {}; }
                    var market = this.markets[symbol];
                    var rate = market[takerOrMaker];
                    var cost = parseFloat(this.costToPrecision(symbol, amount * rate));
                    var key = 'quote';
                    if (side === 'sell') {
                        cost *= price;
                    }
                    else {
                        key = 'base';
                    }
                    return {
                        'type': takerOrMaker,
                        'currency': market[key],
                        'rate': rate,
                        'cost': parseFloat(this.feeToPrecision(symbol, cost)),
                    };
                };
                exmo.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'amount': amount,
                                        'currency': currency,
                                        'address': address,
                                    };
                                    if (typeof tag !== 'undefined')
                                        request['invoice'] = tag;
                                    return [4, this.privatePostWithdrawCrypt(this.extend(request, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result['task_id'],
                                        }];
                            }
                        });
                    });
                };
                exmo.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + path;
                    if (api === 'public') {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({ 'nonce': nonce }, params));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Key': this.apiKey,
                            'Sign': this.hmac(this.encode(body), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                exmo.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('result' in response) {
                                        if (response['result'])
                                            return [2, response];
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return exmo;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 69: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(flowbtc, _super);
                function flowbtc() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                flowbtc.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'flowbtc',
                        'name': 'flowBTC',
                        'countries': 'BR',
                        'version': 'v1',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28162465-cd815d4c-67cf-11e7-8e57-438bea0523a2.jpg',
                            'api': 'https://api.flowbtc.com:8405/ajax',
                            'www': 'https://trader.flowbtc.com',
                            'doc': 'http://www.flowbtc.com.br/api/',
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': true,
                            'uid': true,
                        },
                        'api': {
                            'public': {
                                'post': [
                                    'GetTicker',
                                    'GetTrades',
                                    'GetTradesByDate',
                                    'GetOrderBook',
                                    'GetProductPairs',
                                    'GetProducts',
                                ],
                            },
                            'private': {
                                'post': [
                                    'CreateAccount',
                                    'GetUserInfo',
                                    'SetUserInfo',
                                    'GetAccountInfo',
                                    'GetAccountTrades',
                                    'GetDepositAddresses',
                                    'Withdraw',
                                    'CreateOrder',
                                    'ModifyOrder',
                                    'CancelOrder',
                                    'CancelAllOrders',
                                    'GetAccountOpenOrders',
                                    'GetOrderFee',
                                ],
                            },
                        },
                    });
                };
                flowbtc.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, p, market, id, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicPostGetProductPairs()];
                                case 1:
                                    response = _a.sent();
                                    markets = response['productPairs'];
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['name'];
                                        base = market['product1Label'];
                                        quote = market['product2Label'];
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                flowbtc.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetAccountInfo()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['currencies'];
                                    result = { 'info': response };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['name'];
                                        account = {
                                            'free': balance['balance'],
                                            'used': balance['hold'],
                                            'total': 0.0,
                                        };
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                flowbtc.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicPostGetOrderBook(this.extend({
                                            'productPair': market['id'],
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'px', 'qty')];
                            }
                        });
                    });
                };
                flowbtc.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicPostGetTicker(this.extend({
                                            'productPair': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    timestamp = this.milliseconds();
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['volume24hr']),
                                            'quoteVolume': parseFloat(ticker['volume24hrProduct2']),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                flowbtc.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['unixtime'] * 1000;
                    var side = (trade['incomingOrderSide'] === 0) ? 'buy' : 'sell';
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'id': trade['tid'].toString(),
                        'order': undefined,
                        'type': undefined,
                        'side': side,
                        'price': trade['px'],
                        'amount': trade['qty'],
                    };
                };
                flowbtc.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicPostGetTrades(this.extend({
                                            'ins': market['id'],
                                            'startIndex': -1,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['trades'], market, since, limit)];
                            }
                        });
                    });
                };
                flowbtc.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderType, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    orderType = (type === 'market') ? 1 : 0;
                                    order = {
                                        'ins': this.marketId(symbol),
                                        'side': side,
                                        'orderType': orderType,
                                        'qty': amount,
                                        'px': price,
                                    };
                                    return [4, this.privatePostCreateOrder(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['serverOrderId'],
                                        }];
                            }
                        });
                    });
                };
                flowbtc.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (!('ins' in params)) return [3, 3];
                                    return [4, this.privatePostCancelOrder(this.extend({
                                            'serverOrderId': id,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                                case 3: throw new ExchangeError(this.id + ' requires `ins` symbol parameter for cancelling an order');
                            }
                        });
                    });
                };
                flowbtc.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + path;
                    if (api === 'public') {
                        if (Object.keys(params).length) {
                            body = this.json(params);
                        }
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var auth = nonce.toString() + this.uid + this.apiKey;
                        var signature = this.hmac(this.encode(auth), this.encode(this.secret));
                        body = this.json(this.extend({
                            'apiKey': this.apiKey,
                            'apiNonce': nonce,
                            'apiSig': signature.toUpperCase(),
                        }, params));
                        headers = {
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                flowbtc.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('isAccepted' in response)
                                        if (response['isAccepted'])
                                            return [2, response];
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                return flowbtc;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 70: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(foxbit, _super);
                function foxbit() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                foxbit.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'foxbit',
                        'name': 'FoxBit',
                        'countries': 'BR',
                        'has': {
                            'CORS': false,
                            'createMarketOrder': false,
                        },
                        'rateLimit': 1000,
                        'version': 'v1',
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27991413-11b40d42-647f-11e7-91ee-78ced874dd09.jpg',
                            'api': {
                                'public': 'https://api.blinktrade.com/api',
                                'private': 'https://api.blinktrade.com/tapi',
                            },
                            'www': 'https://foxbit.exchange',
                            'doc': 'https://blinktrade.com/docs',
                        },
                        'comment': 'Blinktrade API',
                        'api': {
                            'public': {
                                'get': [
                                    '{currency}/ticker',
                                    '{currency}/orderbook',
                                    '{currency}/trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    'D',
                                    'F',
                                    'U2',
                                    'U4',
                                    'U6',
                                    'U18',
                                    'U24',
                                    'U26',
                                    'U30',
                                    'U34',
                                    'U70',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/VEF': { 'id': 'BTCVEF', 'symbol': 'BTC/VEF', 'base': 'BTC', 'quote': 'VEF', 'brokerId': 1, 'broker': 'SurBitcoin' },
                            'BTC/VND': { 'id': 'BTCVND', 'symbol': 'BTC/VND', 'base': 'BTC', 'quote': 'VND', 'brokerId': 3, 'broker': 'VBTC' },
                            'BTC/BRL': { 'id': 'BTCBRL', 'symbol': 'BTC/BRL', 'base': 'BTC', 'quote': 'BRL', 'brokerId': 4, 'broker': 'FoxBit' },
                            'BTC/PKR': { 'id': 'BTCPKR', 'symbol': 'BTC/PKR', 'base': 'BTC', 'quote': 'PKR', 'brokerId': 8, 'broker': 'UrduBit' },
                            'BTC/CLP': { 'id': 'BTCCLP', 'symbol': 'BTC/CLP', 'base': 'BTC', 'quote': 'CLP', 'brokerId': 9, 'broker': 'ChileBit' },
                        },
                    });
                };
                foxbit.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return this.privatePostU2({
                        'BalanceReqID': this.nonce(),
                    });
                };
                foxbit.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetCurrencyOrderbook(this.extend({
                                            'currency': market['quote'],
                                            'crypto_currency': market['base'],
                                        }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                foxbit.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker, timestamp, lowercaseQuote, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetCurrencyTicker(this.extend({
                                            'currency': market['quote'],
                                            'crypto_currency': market['base'],
                                        }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = this.milliseconds();
                                    lowercaseQuote = market['quote'].toLowerCase();
                                    quoteVolume = 'vol_' + lowercaseQuote;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['buy']),
                                            'ask': parseFloat(ticker['sell']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['vol']),
                                            'quoteVolume': parseFloat(ticker[quoteVolume]),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                foxbit.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['date'] * 1000;
                    return {
                        'id': this.safeString(trade, 'tid'),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['side'],
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                foxbit.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetCurrencyTrades(this.extend({
                                            'currency': market['quote'],
                                            'crypto_currency': market['base'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                foxbit.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderSide, order, response, indexed, execution;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    market = this.market(symbol);
                                    orderSide = (side === 'buy') ? '1' : '2';
                                    order = {
                                        'ClOrdID': this.nonce(),
                                        'Symbol': market['id'],
                                        'Side': orderSide,
                                        'OrdType': '2',
                                        'Price': price,
                                        'OrderQty': amount,
                                        'BrokerID': market['brokerId'],
                                    };
                                    return [4, this.privatePostD(this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    indexed = this.indexBy(response['Responses'], 'MsgType');
                                    execution = indexed['8'];
                                    return [2, {
                                            'info': response,
                                            'id': execution['OrderID'],
                                        }];
                            }
                        });
                    });
                };
                foxbit.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostF(this.extend({
                                        'ClOrdID': id,
                                    }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                foxbit.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api] + '/' + this.version + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var request = this.extend({ 'MsgType': path }, query);
                        body = this.json(request);
                        headers = {
                            'APIKey': this.apiKey,
                            'Nonce': nonce,
                            'Signature': this.hmac(this.encode(nonce), this.encode(this.secret)),
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                foxbit.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('Status' in response)
                                        if (response['Status'] !== 200)
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return foxbit;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 71: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(fybse, _super);
                function fybse() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                fybse.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'fybse',
                        'name': 'FYB-SE',
                        'countries': 'SE',
                        'has': {
                            'CORS': false,
                        },
                        'rateLimit': 1500,
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766512-31019772-5edb-11e7-8241-2e675e6797f1.jpg',
                            'api': 'https://www.fybse.se/api/SEK',
                            'www': 'https://www.fybse.se',
                            'doc': 'http://docs.fyb.apiary.io',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'ticker',
                                    'tickerdetailed',
                                    'orderbook',
                                    'trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    'test',
                                    'getaccinfo',
                                    'getpendingorders',
                                    'getorderhistory',
                                    'cancelpendingorder',
                                    'placeorder',
                                    'withdraw',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/SEK': { 'id': 'SEK', 'symbol': 'BTC/SEK', 'base': 'BTC', 'quote': 'SEK' },
                        },
                    });
                };
                fybse.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balance, btc, symbol, quote, lowercase, fiat, crypto, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostGetaccinfo()];
                                case 1:
                                    balance = _a.sent();
                                    btc = parseFloat(balance['btcBal']);
                                    symbol = this.symbols[0];
                                    quote = this.markets[symbol]['quote'];
                                    lowercase = quote.toLowerCase() + 'Bal';
                                    fiat = parseFloat(balance[lowercase]);
                                    crypto = {
                                        'free': btc,
                                        'used': 0.0,
                                        'total': btc,
                                    };
                                    result = { 'BTC': crypto };
                                    result[quote] = {
                                        'free': fiat,
                                        'used': 0.0,
                                        'total': fiat,
                                    };
                                    result['info'] = balance;
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                fybse.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetOrderbook(params)];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                fybse.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp, last, volume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTickerdetailed(params)];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = this.milliseconds();
                                    last = undefined;
                                    volume = undefined;
                                    if ('last' in ticker)
                                        last = parseFloat(ticker['last']);
                                    if ('vol' in ticker)
                                        volume = parseFloat(ticker['vol']);
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': undefined,
                                            'low': undefined,
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': last,
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': volume,
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                fybse.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(trade['date']) * 1000;
                    return {
                        'info': trade,
                        'id': trade['tid'].toString(),
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                fybse.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrades(params)];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                fybse.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostPlaceorder(this.extend({
                                        'qty': amount,
                                        'price': price,
                                        'type': side[0].toUpperCase(),
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['pending_oid'],
                                        }];
                            }
                        });
                    });
                };
                fybse.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancelpendingorder({ 'orderNo': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                fybse.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + path;
                    if (api === 'public') {
                        url += '.json';
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({ 'timestamp': nonce }, params));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'key': this.apiKey,
                            'sig': this.hmac(this.encode(body), this.encode(this.secret), 'sha1'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                fybse.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (api === 'private')
                                        if ('error' in response)
                                            if (response['error'])
                                                throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return fybse;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 72: [function (require, module, exports) {
            'use strict';
            var fybse = require('./fybse.js');
            module.exports = (function (_super) {
                __extends(fybsg, _super);
                function fybsg() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                fybsg.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'fybsg',
                        'name': 'FYB-SG',
                        'countries': 'SG',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766513-3364d56a-5edb-11e7-9e6b-d5898bb89c81.jpg',
                            'api': 'https://www.fybsg.com/api/SGD',
                            'www': 'https://www.fybsg.com',
                            'doc': 'http://docs.fyb.apiary.io',
                        },
                        'markets': {
                            'BTC/SGD': { 'id': 'SGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
                        },
                    });
                };
                return fybsg;
            }(fybse));
        }, { "./fybse.js": 71 }], 73: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(gatecoin, _super);
                function gatecoin() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                gatecoin.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'gatecoin',
                        'name': 'Gatecoin',
                        'rateLimit': 2000,
                        'countries': 'HK',
                        'comment': 'a regulated/licensed exchange',
                        'has': {
                            'CORS': false,
                            'fetchOHLCV': true,
                            'fetchOpenOrders': true,
                            'fetchTickers': true,
                        },
                        'timeframes': {
                            '1m': '1m',
                            '15m': '15m',
                            '1h': '1h',
                            '6h': '6h',
                            '1d': '24h',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28646817-508457f2-726c-11e7-9eeb-3528d2413a58.jpg',
                            'api': 'https://api.gatecoin.com',
                            'www': 'https://gatecoin.com',
                            'doc': [
                                'https://gatecoin.com/api',
                                'https://github.com/Gatecoin/RESTful-API-Implementation',
                                'https://api.gatecoin.com/swagger-ui/index.html',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'Public/ExchangeRate',
                                    'Public/LiveTicker',
                                    'Public/LiveTicker/{CurrencyPair}',
                                    'Public/LiveTickers',
                                    'Public/MarketDepth/{CurrencyPair}',
                                    'Public/NetworkStatistics/{DigiCurrency}',
                                    'Public/StatisticHistory/{DigiCurrency}/{Typeofdata}',
                                    'Public/TickerHistory/{CurrencyPair}/{Timeframe}',
                                    'Public/Transactions/{CurrencyPair}',
                                    'Public/TransactionsHistory/{CurrencyPair}',
                                    'Reference/BusinessNatureList',
                                    'Reference/Countries',
                                    'Reference/Currencies',
                                    'Reference/CurrencyPairs',
                                    'Reference/CurrentStatusList',
                                    'Reference/IdentydocumentTypes',
                                    'Reference/IncomeRangeList',
                                    'Reference/IncomeSourceList',
                                    'Reference/VerificationLevelList',
                                    'Stream/PublicChannel',
                                ],
                                'post': [
                                    'Export/Transactions',
                                    'Ping',
                                    'Public/Unsubscribe/{EmailCode}',
                                    'RegisterUser',
                                ],
                            },
                            'private': {
                                'get': [
                                    'Account/CorporateData',
                                    'Account/DocumentAddress',
                                    'Account/DocumentCorporation',
                                    'Account/DocumentID',
                                    'Account/DocumentInformation',
                                    'Account/Email',
                                    'Account/FeeRate',
                                    'Account/Level',
                                    'Account/PersonalInformation',
                                    'Account/Phone',
                                    'Account/Profile',
                                    'Account/Questionnaire',
                                    'Account/Referral',
                                    'Account/ReferralCode',
                                    'Account/ReferralNames',
                                    'Account/ReferralReward',
                                    'Account/ReferredCode',
                                    'Account/ResidentInformation',
                                    'Account/SecuritySettings',
                                    'Account/User',
                                    'APIKey/APIKey',
                                    'Auth/ConnectionHistory',
                                    'Balance/Balances',
                                    'Balance/Balances/{Currency}',
                                    'Balance/Deposits',
                                    'Balance/Withdrawals',
                                    'Bank/Accounts/{Currency}/{Location}',
                                    'Bank/Transactions',
                                    'Bank/UserAccounts',
                                    'Bank/UserAccounts/{Currency}',
                                    'ElectronicWallet/DepositWallets',
                                    'ElectronicWallet/DepositWallets/{DigiCurrency}',
                                    'ElectronicWallet/Transactions',
                                    'ElectronicWallet/Transactions/{DigiCurrency}',
                                    'ElectronicWallet/UserWallets',
                                    'ElectronicWallet/UserWallets/{DigiCurrency}',
                                    'Info/ReferenceCurrency',
                                    'Info/ReferenceLanguage',
                                    'Notification/Messages',
                                    'Trade/Orders',
                                    'Trade/Orders/{OrderID}',
                                    'Trade/StopOrders',
                                    'Trade/StopOrdersHistory',
                                    'Trade/Trades',
                                    'Trade/UserTrades',
                                ],
                                'post': [
                                    'Account/DocumentAddress',
                                    'Account/DocumentCorporation',
                                    'Account/DocumentID',
                                    'Account/Email/RequestVerify',
                                    'Account/Email/Verify',
                                    'Account/GoogleAuth',
                                    'Account/Level',
                                    'Account/Questionnaire',
                                    'Account/Referral',
                                    'APIKey/APIKey',
                                    'Auth/ChangePassword',
                                    'Auth/ForgotPassword',
                                    'Auth/ForgotUserID',
                                    'Auth/Login',
                                    'Auth/Logout',
                                    'Auth/LogoutOtherSessions',
                                    'Auth/ResetPassword',
                                    'Bank/Transactions',
                                    'Bank/UserAccounts',
                                    'ElectronicWallet/DepositWallets/{DigiCurrency}',
                                    'ElectronicWallet/Transactions/Deposits/{DigiCurrency}',
                                    'ElectronicWallet/Transactions/Withdrawals/{DigiCurrency}',
                                    'ElectronicWallet/UserWallets/{DigiCurrency}',
                                    'ElectronicWallet/Withdrawals/{DigiCurrency}',
                                    'Notification/Messages',
                                    'Notification/Messages/{ID}',
                                    'Trade/Orders',
                                    'Trade/StopOrders',
                                ],
                                'put': [
                                    'Account/CorporateData',
                                    'Account/DocumentID',
                                    'Account/DocumentInformation',
                                    'Account/Email',
                                    'Account/PersonalInformation',
                                    'Account/Phone',
                                    'Account/Questionnaire',
                                    'Account/ReferredCode',
                                    'Account/ResidentInformation',
                                    'Account/SecuritySettings',
                                    'Account/User',
                                    'Bank/UserAccounts',
                                    'ElectronicWallet/DepositWallets/{DigiCurrency}/{AddressName}',
                                    'ElectronicWallet/UserWallets/{DigiCurrency}',
                                    'Info/ReferenceCurrency',
                                    'Info/ReferenceLanguage',
                                ],
                                'delete': [
                                    'APIKey/APIKey/{PublicKey}',
                                    'Bank/Transactions/{RequestID}',
                                    'Bank/UserAccounts/{Currency}/{Label}',
                                    'ElectronicWallet/DepositWallets/{DigiCurrency}/{AddressName}',
                                    'ElectronicWallet/UserWallets/{DigiCurrency}/{AddressName}',
                                    'Trade/Orders',
                                    'Trade/Orders/{OrderID}',
                                    'Trade/StopOrders',
                                    'Trade/StopOrders/{ID}',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.0025,
                                'taker': 0.0035,
                            },
                        },
                    });
                };
                gatecoin.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, i, market, id, baseId, quoteId, base, quote, symbol, precision, limits;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetReferenceCurrencyPairs()];
                                case 1:
                                    response = _a.sent();
                                    markets = response['currencyPairs'];
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        id = market['tradingCode'];
                                        baseId = market['baseCurrency'];
                                        quoteId = market['quoteCurrency'];
                                        base = baseId;
                                        quote = quoteId;
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': 8,
                                            'price': market['priceDecimalPlaces'],
                                        };
                                        limits = {
                                            'amount': {
                                                'min': Math.pow(10, -precision['amount']),
                                                'max': undefined,
                                            },
                                            'price': {
                                                'min': Math.pow(10, -precision['amount']),
                                                'max': undefined,
                                            },
                                            'cost': {
                                                'min': undefined,
                                                'max': undefined,
                                            },
                                        };
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'active': true,
                                            'precision': precision,
                                            'limits': limits,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                gatecoin.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetBalanceBalances()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['balances'];
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        account = {
                                            'free': balance['availableBalance'],
                                            'used': this.sum(balance['pendingIncoming'], balance['pendingOutgoing'], balance['openOrder']),
                                            'total': balance['balance'],
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                gatecoin.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetPublicMarketDepthCurrencyPair(this.extend({
                                            'CurrencyPair': market['id'],
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price', 'volume')];
                            }
                        });
                    });
                };
                gatecoin.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = parseInt(ticker['createDateTime']) * 1000;
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var baseVolume = parseFloat(ticker['volume']);
                    var vwap = parseFloat(ticker['vwap']);
                    var quoteVolume = baseVolume * vwap;
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['bid']),
                        'ask': parseFloat(ticker['ask']),
                        'vwap': vwap,
                        'open': parseFloat(ticker['open']),
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': baseVolume,
                        'quoteVolume': quoteVolume,
                        'info': ticker,
                    };
                };
                gatecoin.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, result, t, ticker, id, market, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetPublicLiveTickers(params)];
                                case 2:
                                    response = _a.sent();
                                    tickers = response['tickers'];
                                    result = {};
                                    for (t = 0; t < tickers.length; t++) {
                                        ticker = tickers[t];
                                        id = ticker['currencyPair'];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                gatecoin.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetPublicLiveTickerCurrencyPair(this.extend({
                                            'CurrencyPair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['ticker'];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                gatecoin.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var side = undefined;
                    var order = undefined;
                    if ('way' in trade) {
                        side = (trade['way'] === 'bid') ? 'buy' : 'sell';
                        var orderId = trade['way'] + 'OrderId';
                        order = trade[orderId];
                    }
                    var timestamp = parseInt(trade['transactionTime']) * 1000;
                    if (!market)
                        market = this.markets_by_id[trade['currencyPair']];
                    return {
                        'info': trade,
                        'id': trade['transactionId'].toString(),
                        'order': order,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': side,
                        'price': trade['price'],
                        'amount': trade['quantity'],
                    };
                };
                gatecoin.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetPublicTransactionsCurrencyPair(this.extend({
                                            'CurrencyPair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['transactions'], market, since, limit)];
                            }
                        });
                    });
                };
                gatecoin.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        parseInt(ohlcv['createDateTime']) * 1000,
                        ohlcv['open'],
                        ohlcv['high'],
                        ohlcv['low'],
                        undefined,
                        ohlcv['volume'],
                    ];
                };
                gatecoin.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'CurrencyPair': market['id'],
                                        'Timeframe': this.timeframes[timeframe],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['Count'] = limit;
                                    request = this.extend(request, params);
                                    return [4, this.publicGetPublicTickerHistoryCurrencyPairTimeframe(request)];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response['tickers'], market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                gatecoin.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'Code': this.marketId(symbol),
                                        'Way': (side === 'buy') ? 'Bid' : 'Ask',
                                        'Amount': amount,
                                    };
                                    if (type === 'limit')
                                        order['Price'] = price;
                                    if (this.twofa) {
                                        if ('ValidationCode' in params)
                                            order['ValidationCode'] = params['ValidationCode'];
                                        else
                                            throw new AuthenticationError(this.id + ' two-factor authentication requires a missing ValidationCode parameter');
                                    }
                                    return [4, this.privatePostTradeOrders(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['clOrderId'],
                                        }];
                            }
                        });
                    });
                };
                gatecoin.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateDeleteTradeOrdersOrderID({ 'OrderID': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                gatecoin.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = (order['side'] === 0) ? 'buy' : 'sell';
                    var type = (order['type'] === 0) ? 'limit' : 'market';
                    var symbol = undefined;
                    if (typeof market === 'undefined') {
                        var marketId = this.safeString(order, 'code');
                        if (marketId in this.markets_by_id)
                            market = this.markets_by_id[marketId];
                    }
                    if (typeof market !== 'undefined')
                        symbol = market['symbol'];
                    var timestamp = parseInt(order['date']) * 1000;
                    var amount = order['initialQuantity'];
                    var remaining = order['remainingQuantity'];
                    var filled = amount - remaining;
                    var price = order['price'];
                    var cost = price * filled;
                    var id = order['clOrderId'];
                    var status = 'open';
                    var result = {
                        'id': id,
                        'datetime': this.iso8601(timestamp),
                        'timestamp': timestamp,
                        'status': status,
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'cost': cost,
                        'trades': undefined,
                        'fee': undefined,
                        'info': order,
                    };
                    return result;
                };
                gatecoin.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetTradeOrders()];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response['orders'], undefined, since, limit);
                                    if (typeof symbol !== 'undefined')
                                        return [2, this.filterBySymbol(orders, symbol)];
                                    return [2, orders];
                            }
                        });
                    });
                };
                gatecoin.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var nonceString = nonce.toString();
                        var contentType = (method === 'GET') ? '' : 'application/json';
                        var auth = method + url + contentType + nonceString;
                        auth = auth.toLowerCase();
                        var signature = this.hmac(this.encode(auth), this.encode(this.secret), 'sha256', 'base64');
                        headers = {
                            'API_PUBLIC_KEY': this.apiKey,
                            'API_REQUEST_SIGNATURE': this.decode(signature),
                            'API_REQUEST_DATE': nonceString,
                        };
                        if (method !== 'GET') {
                            headers['Content-Type'] = contentType;
                            body = this.json(this.extend({ 'nonce': nonce }, params));
                        }
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                gatecoin.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('responseStatus' in response)
                                        if ('message' in response['responseStatus'])
                                            if (response['responseStatus']['message'] === 'OK')
                                                return [2, response];
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                return gatecoin;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 74: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(gateio, _super);
                function gateio() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                gateio.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'gateio',
                        'name': 'Gate.io',
                        'countries': 'CN',
                        'version': '2',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': false,
                            'createMarketOrder': false,
                            'fetchTickers': true,
                            'withdraw': true,
                            'createDepositAddress': true,
                            'fetchDepositAddress': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg',
                            'api': {
                                'public': 'https://data.gate.io/api',
                                'private': 'https://data.gate.io/api',
                            },
                            'www': 'https://gate.io/',
                            'doc': 'https://gate.io/api2',
                            'fees': 'https://gate.io/fee',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'pairs',
                                    'marketinfo',
                                    'marketlist',
                                    'tickers',
                                    'ticker/{id}',
                                    'orderBook/{id}',
                                    'trade/{id}',
                                    'tradeHistory/{id}',
                                    'tradeHistory/{id}/{tid}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balances',
                                    'depositAddress',
                                    'newAddress',
                                    'depositsWithdrawals',
                                    'buy',
                                    'sell',
                                    'cancelOrder',
                                    'cancelAllOrders',
                                    'getOrder',
                                    'openOrders',
                                    'tradeHistory',
                                    'withdraw',
                                ],
                            },
                        },
                    });
                };
                gateio.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, i, market, keys, id, details, _a, base, quote, symbol, precision, amountLimits, priceLimits, limits;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetMarketinfo()];
                                case 1:
                                    response = _c.sent();
                                    markets = this.safeValue(response, 'pairs');
                                    if (!markets)
                                        throw new ExchangeError(this.id + ' fetchMarkets got an unrecognized response');
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        keys = Object.keys(market);
                                        id = keys[0];
                                        details = market[id];
                                        _a = __read(id.split('_'), 2), base = _a[0], quote = _a[1];
                                        base = base.toUpperCase();
                                        quote = quote.toUpperCase();
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': details['decimal_places'],
                                            'price': details['decimal_places'],
                                        };
                                        amountLimits = {
                                            'min': details['min_amount'],
                                            'max': undefined,
                                        };
                                        priceLimits = {
                                            'min': undefined,
                                            'max': undefined,
                                        };
                                        limits = {
                                            'amount': amountLimits,
                                            'price': priceLimits,
                                        };
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                            'maker': details['fee'] / 100,
                                            'taker': details['fee'] / 100,
                                            'precision': precision,
                                            'limits': limits,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                gateio.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balance, result, currencies, i, currency, code, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostBalances()];
                                case 2:
                                    balance = _a.sent();
                                    result = { 'info': balance };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        code = this.commonCurrencyCode(currency);
                                        account = this.account();
                                        if ('available' in balance) {
                                            if (currency in balance['available']) {
                                                account['free'] = parseFloat(balance['available'][currency]);
                                            }
                                        }
                                        if ('locked' in balance) {
                                            if (currency in balance['locked']) {
                                                account['used'] = parseFloat(balance['locked'][currency]);
                                            }
                                        }
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[code] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                gateio.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderBookId(this.extend({
                                            'id': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    result = this.parseOrderBook(orderbook);
                                    result['asks'] = this.sortBy(result['asks'], 0);
                                    return [2, result];
                            }
                        });
                    });
                };
                gateio.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high24hr']),
                        'low': parseFloat(ticker['low24hr']),
                        'bid': parseFloat(ticker['highestBid']),
                        'ask': parseFloat(ticker['lowestAsk']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last']),
                        'change': parseFloat(ticker['percentChange']),
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['quoteVolume']),
                        'quoteVolume': parseFloat(ticker['baseVolume']),
                        'info': ticker,
                    };
                };
                gateio.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result, ids, i, id, _a, baseId, quoteId, base, quote, symbol, ticker, market;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _c.sent();
                                    return [4, this.publicGetTickers(params)];
                                case 2:
                                    tickers = _c.sent();
                                    result = {};
                                    ids = Object.keys(tickers);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        _a = __read(id.split('_'), 2), baseId = _a[0], quoteId = _a[1];
                                        base = baseId.toUpperCase();
                                        quote = quoteId.toUpperCase();
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        ticker = tickers[id];
                                        market = undefined;
                                        if (symbol in this.markets)
                                            market = this.markets[symbol];
                                        if (id in this.markets_by_id)
                                            market = this.markets_by_id[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                gateio.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTickerId(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                gateio.prototype.parseTrade = function (trade, market) {
                    var timestamp = this.parse8601(trade['date']) - 8 * 60 * 60 * 1000;
                    return {
                        'id': trade['tradeID'],
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['type'],
                        'price': trade['rate'],
                        'amount': this.safeFloat(trade, 'amount'),
                    };
                };
                gateio.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradeHistoryId(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['data'], market, since, limit)];
                            }
                        });
                    });
                };
                gateio.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = 'privatePost' + this.capitalize(side);
                                    order = {
                                        'currencyPair': this.marketId(symbol),
                                        'rate': price,
                                        'amount': amount,
                                    };
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['orderNumber'],
                                        }];
                            }
                        });
                    });
                };
                gateio.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCancelOrder({ 'orderNumber': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                gateio.prototype.queryDepositAddress = function (method, currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    method = 'privatePost' + method + 'Address';
                                    return [4, this[method](this.extend({
                                            'currency': currency,
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    address = undefined;
                                    if ('addr' in response)
                                        address = this.safeString(response, 'addr');
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'status': (typeof address !== 'undefined') ? 'ok' : 'none',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                gateio.prototype.createDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.queryDepositAddress('New', currency, params)];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                gateio.prototype.fetchDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.queryDepositAddress('Deposit', currency, params)];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                gateio.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostWithdraw(this.extend({
                                            'currency': currency.toLowerCase(),
                                            'amount': amount,
                                            'address': address,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                gateio.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var prefix = (api === 'private') ? (api + '/') : '';
                    var url = this.urls['api'][api] + this.version + '/1/' + prefix + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var request = { 'nonce': nonce };
                        body = this.urlencode(this.extend(request, query));
                        var signature = this.hmac(this.encode(body), this.encode(this.secret), 'sha512');
                        headers = {
                            'Key': this.apiKey,
                            'Sign': signature,
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                gateio.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('result' in response)
                                        if (response['result'] !== 'true')
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return gateio;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 75: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), InsufficientFunds = _a.InsufficientFunds, ExchangeError = _a.ExchangeError, InvalidOrder = _a.InvalidOrder, AuthenticationError = _a.AuthenticationError, NotSupported = _a.NotSupported, OrderNotFound = _a.OrderNotFound;
            module.exports = (function (_super) {
                __extends(gdax, _super);
                function gdax() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                gdax.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'gdax',
                        'name': 'GDAX',
                        'countries': 'US',
                        'rateLimit': 1000,
                        'userAgent': this.userAgents['chrome'],
                        'has': {
                            'CORS': true,
                            'fetchOHLCV': true,
                            'deposit': true,
                            'withdraw': true,
                            'fetchOrder': true,
                            'fetchOrders': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'fetchMyTrades': true,
                        },
                        'timeframes': {
                            '1m': 60,
                            '5m': 300,
                            '15m': 900,
                            '1h': 3600,
                            '6h': 21600,
                            '1d': 86400,
                        },
                        'urls': {
                            'test': 'https://api-public.sandbox.gdax.com',
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766527-b1be41c6-5edb-11e7-95f6-5b496c469e2c.jpg',
                            'api': 'https://api.gdax.com',
                            'www': 'https://www.gdax.com',
                            'doc': 'https://docs.gdax.com',
                            'fees': [
                                'https://www.gdax.com/fees',
                                'https://support.gdax.com/customer/en/portal/topics/939402-depositing-and-withdrawing-funds/articles',
                            ],
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': true,
                            'password': true,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'currencies',
                                    'products',
                                    'products/{id}/book',
                                    'products/{id}/candles',
                                    'products/{id}/stats',
                                    'products/{id}/ticker',
                                    'products/{id}/trades',
                                    'time',
                                ],
                            },
                            'private': {
                                'get': [
                                    'accounts',
                                    'accounts/{id}',
                                    'accounts/{id}/holds',
                                    'accounts/{id}/ledger',
                                    'accounts/{id}/transfers',
                                    'coinbase-accounts',
                                    'fills',
                                    'funding',
                                    'orders',
                                    'orders/{id}',
                                    'payment-methods',
                                    'position',
                                    'reports/{id}',
                                    'users/self/trailing-volume',
                                ],
                                'post': [
                                    'deposits/coinbase-account',
                                    'deposits/payment-method',
                                    'coinbase-accounts/{id}/addresses',
                                    'funding/repay',
                                    'orders',
                                    'position/close',
                                    'profiles/margin-transfer',
                                    'reports',
                                    'withdrawals/coinbase',
                                    'withdrawals/crypto',
                                    'withdrawals/payment-method',
                                ],
                                'delete': [
                                    'orders',
                                    'orders/{id}',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': true,
                                'percentage': true,
                                'maker': 0.0,
                                'taker': 0.25 / 100,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BCH': 0,
                                    'BTC': 0,
                                    'LTC': 0,
                                    'ETH': 0,
                                    'EUR': 0.15,
                                    'USD': 25,
                                },
                                'deposit': {
                                    'BCH': 0,
                                    'BTC': 0,
                                    'LTC': 0,
                                    'ETH': 0,
                                    'EUR': 0.15,
                                    'USD': 10,
                                },
                            },
                        },
                    });
                };
                gdax.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, base, quote, symbol, priceLimits, precision, taker, active;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetProducts()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['id'];
                                        base = market['base_currency'];
                                        quote = market['quote_currency'];
                                        symbol = base + '/' + quote;
                                        priceLimits = {
                                            'min': this.safeFloat(market, 'quote_increment'),
                                            'max': undefined,
                                        };
                                        precision = {
                                            'amount': 8,
                                            'price': this.precisionFromString(this.safeString(market, 'quote_increment')),
                                        };
                                        taker = this.fees['trading']['taker'];
                                        if ((base === 'ETH') || (base === 'LTC')) {
                                            taker = 0.003;
                                        }
                                        active = market['status'] === 'online';
                                        result.push(this.extend(this.fees['trading'], {
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': this.safeFloat(market, 'base_min_size'),
                                                    'max': this.safeFloat(market, 'base_max_size'),
                                                },
                                                'price': priceLimits,
                                                'cost': {
                                                    'min': this.safeFloat(market, 'min_market_funds'),
                                                    'max': this.safeFloat(market, 'max_market_funds'),
                                                },
                                            },
                                            'taker': taker,
                                            'active': active,
                                            'info': market,
                                        }));
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                gdax.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, b, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetAccounts()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        account = {
                                            'free': this.safeFloat(balance, 'available'),
                                            'used': this.safeFloat(balance, 'hold'),
                                            'total': this.safeFloat(balance, 'balance'),
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                gdax.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetProductsIdBook(this.extend({
                                            'id': this.marketId(symbol),
                                            'level': 2,
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                gdax.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, ticker, timestamp, bid, ask;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = this.extend({
                                        'id': market['id'],
                                    }, params);
                                    return [4, this.publicGetProductsIdTicker(request)];
                                case 2:
                                    ticker = _a.sent();
                                    timestamp = this.parse8601(ticker['time']);
                                    bid = undefined;
                                    ask = undefined;
                                    if ('bid' in ticker)
                                        bid = this.safeFloat(ticker, 'bid');
                                    if ('ask' in ticker)
                                        ask = this.safeFloat(ticker, 'ask');
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': undefined,
                                            'low': undefined,
                                            'bid': bid,
                                            'ask': ask,
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': this.safeFloat(ticker, 'price'),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': this.safeFloat(ticker, 'volume'),
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                gdax.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = undefined;
                    if ('time' in trade) {
                        timestamp = this.parse8601(trade['time']);
                    }
                    else if ('created_at' in trade) {
                        timestamp = this.parse8601(trade['created_at']);
                    }
                    var iso8601 = undefined;
                    if (typeof timestamp !== 'undefined')
                        iso8601 = this.iso8601(timestamp);
                    var symbol = undefined;
                    if (!market) {
                        if ('product_id' in trade) {
                            var marketId = trade['product_id'];
                            if (marketId in this.markets_by_id)
                                market = this.markets_by_id[marketId];
                        }
                    }
                    if (market)
                        symbol = market['symbol'];
                    var feeRate = undefined;
                    var feeCurrency = undefined;
                    if (market) {
                        feeCurrency = market['quote'];
                        if ('liquidity' in trade) {
                            var rateType = (trade['liquidity'] === 'T') ? 'taker' : 'maker';
                            feeRate = market[rateType];
                        }
                    }
                    var feeCost = this.safeFloat(trade, 'fill_fees');
                    if (typeof feeCost === 'undefined')
                        feeCost = this.safeFloat(trade, 'fee');
                    var fee = {
                        'cost': feeCost,
                        'currency': feeCurrency,
                        'rate': feeRate,
                    };
                    var type = undefined;
                    var id = this.safeString(trade, 'trade_id');
                    var side = (trade['side'] === 'buy') ? 'sell' : 'buy';
                    var orderId = this.safeString(trade, 'order_id');
                    if (typeof orderId !== 'undefined')
                        side = (trade['side'] === 'buy') ? 'buy' : 'sell';
                    return {
                        'id': id,
                        'order': orderId,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': iso8601,
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': this.safeFloat(trade, 'price'),
                        'amount': this.safeFloat(trade, 'size'),
                        'fee': fee,
                    };
                };
                gdax.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (typeof symbol !== 'undefined') {
                                        market = this.market(symbol);
                                        request['product_id'] = market['id'];
                                    }
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.privateGetFills(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                gdax.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetProductsIdTrades(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                gdax.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv[0] * 1000,
                        ohlcv[3],
                        ohlcv[2],
                        ohlcv[1],
                        ohlcv[4],
                        ohlcv[5],
                    ];
                };
                gdax.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, granularity, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    granularity = this.timeframes[timeframe];
                                    request = {
                                        'id': market['id'],
                                        'granularity': granularity,
                                    };
                                    if (typeof since !== 'undefined') {
                                        request['start'] = this.ymdhms(since);
                                        if (typeof limit === 'undefined') {
                                            limit = 350;
                                        }
                                        request['end'] = this.ymdhms(this.sum(limit * granularity * 1000, since));
                                    }
                                    return [4, this.publicGetProductsIdCandles(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                gdax.prototype.fetchTime = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTime()];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parse8601(response['iso'])];
                            }
                        });
                    });
                };
                gdax.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        'pending': 'open',
                        'active': 'open',
                        'open': 'open',
                        'done': 'closed',
                        'canceled': 'canceled',
                    };
                    return this.safeString(statuses, status, status);
                };
                gdax.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(order['created_at']);
                    var symbol = undefined;
                    if (!market) {
                        if (order['product_id'] in this.markets_by_id)
                            market = this.markets_by_id[order['product_id']];
                    }
                    var status = this.parseOrderStatus(order['status']);
                    var price = this.safeFloat(order, 'price');
                    var amount = this.safeFloat(order, 'size');
                    if (typeof amount === 'undefined')
                        amount = this.safeFloat(order, 'funds');
                    if (typeof amount === 'undefined')
                        amount = this.safeFloat(order, 'specified_funds');
                    var filled = this.safeFloat(order, 'filled_size');
                    var remaining = undefined;
                    if (typeof amount !== 'undefined')
                        if (typeof filled !== 'undefined')
                            remaining = amount - filled;
                    var cost = this.safeFloat(order, 'executed_value');
                    var fee = {
                        'cost': this.safeFloat(order, 'fill_fees'),
                        'currency': undefined,
                        'rate': undefined,
                    };
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'id': order['id'],
                        'info': order,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': status,
                        'symbol': symbol,
                        'type': order['type'],
                        'side': order['side'],
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'fee': fee,
                    };
                };
                gdax.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetOrdersId(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response)];
                            }
                        });
                    });
                };
                gdax.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'status': 'all',
                                    };
                                    market = undefined;
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['product_id'] = market['id'];
                                    }
                                    return [4, this.privateGetOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                gdax.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    market = undefined;
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['product_id'] = market['id'];
                                    }
                                    return [4, this.privateGetOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                gdax.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'status': 'done',
                                    };
                                    market = undefined;
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['product_id'] = market['id'];
                                    }
                                    return [4, this.privateGetOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                gdax.prototype.createOrder = function (market, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'product_id': this.marketId(market),
                                        'side': side,
                                        'size': amount,
                                        'type': type,
                                    };
                                    if (type === 'limit')
                                        order['price'] = price;
                                    return [4, this.privatePostOrders(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                gdax.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateDeleteOrdersId({ 'id': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                gdax.prototype.getPaymentMethods = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetPaymentMethods()];
                                case 1:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                gdax.prototype.deposit = function (currency, amount, address, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, method, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'currency': currency,
                                        'amount': amount,
                                    };
                                    method = 'privatePostDeposits';
                                    if ('payment_method_id' in params) {
                                        method += 'PaymentMethod';
                                    }
                                    else if ('coinbase_account_id' in params) {
                                        method += 'CoinbaseAccount';
                                    }
                                    else {
                                        throw new NotSupported(this.id + ' deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params');
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    if (!response)
                                        throw new ExchangeError(this.id + ' deposit() error: ' + this.json(response));
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                gdax.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, method, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'currency': currency,
                                        'amount': amount,
                                    };
                                    method = 'privatePostWithdrawals';
                                    if ('payment_method_id' in params) {
                                        method += 'PaymentMethod';
                                    }
                                    else if ('coinbase_account_id' in params) {
                                        method += 'CoinbaseAccount';
                                    }
                                    else {
                                        method += 'Crypto';
                                        request['crypto_address'] = address;
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    if (!response)
                                        throw new ExchangeError(this.id + ' withdraw() error: ' + this.json(response));
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                gdax.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var request = '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (method === 'GET') {
                        if (Object.keys(query).length)
                            request += '?' + this.urlencode(query);
                    }
                    var url = this.urls['api'] + request;
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var payload = '';
                        if (method !== 'GET') {
                            if (Object.keys(query).length) {
                                body = this.json(query);
                                payload = body;
                            }
                        }
                        var what = nonce + method + request + payload;
                        var secret = this.base64ToBinary(this.secret);
                        var signature = this.hmac(this.encode(what), secret, 'sha256', 'base64');
                        headers = {
                            'CB-ACCESS-KEY': this.apiKey,
                            'CB-ACCESS-SIGN': this.decode(signature),
                            'CB-ACCESS-TIMESTAMP': nonce,
                            'CB-ACCESS-PASSPHRASE': this.password,
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                gdax.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if ((code === 400) || (code === 404)) {
                        if (body[0] === '{') {
                            var response = JSON.parse(body);
                            var message = response['message'];
                            var error = this.id + ' ' + message;
                            if (message.indexOf('price too small') >= 0) {
                                throw new InvalidOrder(error);
                            }
                            else if (message.indexOf('price too precise') >= 0) {
                                throw new InvalidOrder(error);
                            }
                            else if (message === 'Insufficient funds') {
                                throw new InsufficientFunds(error);
                            }
                            else if (message === 'NotFound') {
                                throw new OrderNotFound(error);
                            }
                            else if (message === 'Invalid API Key') {
                                throw new AuthenticationError(error);
                            }
                            throw new ExchangeError(this.id + ' ' + message);
                        }
                        throw new ExchangeError(this.id + ' ' + body);
                    }
                };
                gdax.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('message' in response) {
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return gdax;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 76: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(gemini, _super);
                function gemini() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                gemini.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'gemini',
                        'name': 'Gemini',
                        'countries': 'US',
                        'rateLimit': 1500,
                        'version': 'v1',
                        'has': {
                            'fetchDepositAddress': false,
                            'CORS': false,
                            'fetchBidsAsks': false,
                            'fetchTickers': false,
                            'fetchMyTrades': true,
                            'fetchOrder': false,
                            'fetchOrders': false,
                            'fetchOpenOrders': false,
                            'fetchClosedOrders': false,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg',
                            'api': 'https://api.gemini.com',
                            'www': 'https://gemini.com',
                            'doc': [
                                'https://docs.gemini.com/rest-api',
                                'https://docs.sandbox.gemini.com',
                            ],
                            'test': 'https://api.sandbox.gemini.com',
                            'fees': [
                                'https://gemini.com/fee-schedule/',
                                'https://gemini.com/transfer-fees/',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'symbols',
                                    'pubticker/{symbol}',
                                    'book/{symbol}',
                                    'trades/{symbol}',
                                    'auction/{symbol}',
                                    'auction/{symbol}/history',
                                ],
                            },
                            'private': {
                                'post': [
                                    'order/new',
                                    'order/cancel',
                                    'order/cancel/session',
                                    'order/cancel/all',
                                    'order/status',
                                    'orders',
                                    'mytrades',
                                    'tradevolume',
                                    'balances',
                                    'deposit/{currency}/newAddress',
                                    'withdraw/{currency}',
                                    'heartbeat',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'taker': 0.0025,
                            },
                        },
                    });
                };
                gemini.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, id, market, uppercase, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetSymbols()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        id = markets[p];
                                        market = id;
                                        uppercase = market.toUpperCase();
                                        base = uppercase.slice(0, 3);
                                        quote = uppercase.slice(3, 6);
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                gemini.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetBookSymbol(this.extend({
                                            'symbol': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price', 'amount')];
                            }
                        });
                    });
                };
                gemini.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker, timestamp, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetPubtickerSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    timestamp = ticker['volume']['timestamp'];
                                    baseVolume = market['base'];
                                    quoteVolume = market['quote'];
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': undefined,
                                            'low': undefined,
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['volume'][baseVolume]),
                                            'quoteVolume': parseFloat(ticker['volume'][quoteVolume]),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                gemini.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['timestampms'];
                    var order = undefined;
                    if ('orderId' in trade)
                        order = trade['orderId'].toString();
                    var fee = this.safeFloat(trade, 'fee_amount');
                    if (typeof fee !== 'undefined') {
                        var currency = this.safeString(trade, 'fee_currency');
                        if (typeof currency !== 'undefined') {
                            if (currency in this.currencies_by_id)
                                currency = this.currencies_by_id[currency]['code'];
                            currency = this.commonCurrencyCode(currency);
                        }
                        fee = {
                            'cost': parseFloat(trade['fee_amount']),
                            'currency': currency,
                        };
                    }
                    var price = parseFloat(trade['price']);
                    var amount = parseFloat(trade['amount']);
                    return {
                        'id': trade['tid'].toString(),
                        'order': order,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['type'],
                        'price': price,
                        'cost': price * amount,
                        'amount': amount,
                        'fee': fee,
                    };
                };
                gemini.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradesSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                gemini.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, b, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostBalances()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        account = {
                                            'free': parseFloat(balance['available']),
                                            'used': 0.0,
                                            'total': parseFloat(balance['amount']),
                                        };
                                        account['used'] = account['total'] - account['free'];
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                gemini.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var nonce, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    nonce = this.nonce();
                                    order = {
                                        'client_order_id': nonce.toString(),
                                        'symbol': this.marketId(symbol),
                                        'amount': amount.toString(),
                                        'price': price.toString(),
                                        'side': side,
                                        'type': 'exchange limit',
                                    };
                                    return [4, this.privatePostOrderNew(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['order_id'],
                                        }];
                            }
                        });
                    });
                };
                gemini.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrderCancel({ 'order_id': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                gemini.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof symbol === 'undefined')
                                        throw new ExchangeError(this.id + ' fetchMyTrades requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.privatePostMytrades(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                gemini.prototype.withdraw = function (code, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privatePostWithdrawCurrency(this.extend({
                                            'currency': currency['id'],
                                            'amount': amount,
                                            'address': address,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': this.safeString(response, 'txHash'),
                                        }];
                            }
                        });
                    });
                };
                gemini.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = '/' + this.version + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var request = this.extend({
                            'request': url,
                            'nonce': nonce,
                        }, query);
                        var payload = this.json(request);
                        payload = this.stringToBase64(this.encode(payload));
                        var signature = this.hmac(payload, this.encode(this.secret), 'sha384');
                        headers = {
                            'Content-Type': 'text/plain',
                            'X-GEMINI-APIKEY': this.apiKey,
                            'X-GEMINI-PAYLOAD': this.decode(payload),
                            'X-GEMINI-SIGNATURE': signature,
                        };
                    }
                    url = this.urls['api'] + url;
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                gemini.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('result' in response)
                                        if (response['result'] === 'error')
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return gemini;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 77: [function (require, module, exports) {
            'use strict';
            var _1btcxe = require('./_1btcxe.js');
            module.exports = (function (_super) {
                __extends(getbtc, _super);
                function getbtc() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                getbtc.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'getbtc',
                        'name': 'GetBTC',
                        'countries': ['VC', 'RU'],
                        'rateLimit': 1000,
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/33801902-03c43462-dd7b-11e7-992e-077e4cd015b9.jpg',
                            'api': 'https://getbtc.org/api',
                            'www': 'https://getbtc.org',
                            'doc': 'https://getbtc.org/api-docs.php',
                        },
                        'has': {
                            'fetchTrades': false,
                            'fetchOHLCV': false,
                        },
                        'fees': {
                            'trading': {
                                'taker': 0.20 / 100,
                                'maker': 0.20 / 100,
                            },
                        },
                        'markets': {
                            'BTC/USD': { 'lot': 1e-08, 'symbol': 'BTC/USD', 'quote': 'USD', 'base': 'BTC', 'precision': { 'amount': 8, 'price': 8 }, 'id': 'USD', 'limits': { 'amount': { 'max': undefined, 'min': 1e-08 }, 'price': { 'max': 'undefined', 'min': 1e-08 } } },
                            'BTC/EUR': { 'lot': 1e-08, 'symbol': 'BTC/EUR', 'quote': 'EUR', 'base': 'BTC', 'precision': { 'amount': 8, 'price': 8 }, 'id': 'EUR', 'limits': { 'amount': { 'max': undefined, 'min': 1e-08 }, 'price': { 'max': 'undefined', 'min': 1e-08 } } },
                            'BTC/RUB': { 'lot': 1e-08, 'symbol': 'BTC/RUB', 'quote': 'RUB', 'base': 'BTC', 'precision': { 'amount': 8, 'price': 8 }, 'id': 'RUB', 'limits': { 'amount': { 'max': undefined, 'min': 1e-08 }, 'price': { 'max': 'undefined', 'min': 1e-08 } } },
                        },
                    });
                };
                return getbtc;
            }(_1btcxe));
        }, { "./_1btcxe.js": 4 }], 78: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound;
            module.exports = (function (_super) {
                __extends(hitbtc, _super);
                function hitbtc() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                hitbtc.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'hitbtc',
                        'name': 'HitBTC',
                        'countries': 'UK',
                        'rateLimit': 1500,
                        'version': '1',
                        'has': {
                            'CORS': false,
                            'fetchTrades': true,
                            'fetchOrder': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg',
                            'api': 'http://api.hitbtc.com',
                            'www': 'https://hitbtc.com',
                            'doc': 'https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv1.md',
                            'fees': [
                                'https://hitbtc.com/fees-and-limits',
                                'https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    '{symbol}/orderbook',
                                    '{symbol}/ticker',
                                    '{symbol}/trades',
                                    '{symbol}/trades/recent',
                                    'symbols',
                                    'ticker',
                                    'time',
                                ],
                            },
                            'trading': {
                                'get': [
                                    'balance',
                                    'orders/active',
                                    'orders/recent',
                                    'order',
                                    'trades/by/order',
                                    'trades',
                                ],
                                'post': [
                                    'new_order',
                                    'cancel_order',
                                    'cancel_orders',
                                ],
                            },
                            'payment': {
                                'get': [
                                    'balance',
                                    'address/{currency}',
                                    'transactions',
                                    'transactions/{transaction}',
                                ],
                                'post': [
                                    'transfer_to_trading',
                                    'transfer_to_main',
                                    'address/{currency}',
                                    'payout',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'maker': -0.01 / 100,
                                'taker': 0.1 / 100,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0.001,
                                    'BCC': 0.0018,
                                    'ETH': 0.00215,
                                    'BCH': 0.0018,
                                    'USDT': 100,
                                    'DASH': 0.03,
                                    'BTG': 0.0005,
                                    'LTC': 0.003,
                                    'ZEC': 0.0001,
                                    'XMR': 0.09,
                                    '1ST': 0.84,
                                    'ADX': 5.7,
                                    'AE': 6.7,
                                    'AEON': 0.01006,
                                    'AIR': 565,
                                    'AMP': 9,
                                    'ANT': 6.7,
                                    'ARDR': 1,
                                    'ARN': 18.5,
                                    'ART': 26,
                                    'ATB': 0.0004,
                                    'ATL': 27,
                                    'ATM': 504,
                                    'ATS': 860,
                                    'AVT': 1.9,
                                    'BAS': 113,
                                    'BCN': 0.1,
                                    'BET': 124,
                                    'BKB': 46,
                                    'BMC': 32,
                                    'BMT': 100,
                                    'BNT': 2.57,
                                    'BQX': 4.7,
                                    'BTM': 40,
                                    'BTX': 0.04,
                                    'BUS': 0.004,
                                    'CCT': 115,
                                    'CDT': 100,
                                    'CDX': 30,
                                    'CFI': 61,
                                    'CLD': 0.88,
                                    'CND': 574,
                                    'CNX': 0.04,
                                    'COSS': 65,
                                    'CSNO': 16,
                                    'CTR': 15,
                                    'CTX': 146,
                                    'CVC': 8.46,
                                    'DBIX': 0.0168,
                                    'DCN': 120000,
                                    'DCT': 0.02,
                                    'DDF': 342,
                                    'DENT': 6240,
                                    'DGB': 0.4,
                                    'DGD': 0.01,
                                    'DICE': 0.32,
                                    'DLT': 0.26,
                                    'DNT': 0.21,
                                    'DOGE': 2,
                                    'DOV': 34,
                                    'DRPU': 24,
                                    'DRT': 240,
                                    'DSH': 0.017,
                                    'EBET': 84,
                                    'EBTC': 20,
                                    'EBTCOLD': 6.6,
                                    'ECAT': 14,
                                    'EDG': 2,
                                    'EDO': 2.9,
                                    'ELE': 0.00172,
                                    'ELM': 0.004,
                                    'EMC': 0.03,
                                    'EMGO': 14,
                                    'ENJ': 163,
                                    'EOS': 1.5,
                                    'ERO': 34,
                                    'ETBS': 15,
                                    'ETC': 0.002,
                                    'ETP': 0.004,
                                    'EVX': 5.4,
                                    'EXN': 456,
                                    'FRD': 65,
                                    'FUEL': 123.00105,
                                    'FUN': 202.9598309,
                                    'FYN': 1.849,
                                    'FYP': 66.13,
                                    'GNO': 0.0034,
                                    'GUP': 4,
                                    'GVT': 1.2,
                                    'HAC': 144,
                                    'HDG': 7,
                                    'HGT': 1082,
                                    'HPC': 0.4,
                                    'HVN': 120,
                                    'ICN': 0.55,
                                    'ICO': 34,
                                    'ICOS': 0.35,
                                    'IND': 76,
                                    'INDI': 5913,
                                    'ITS': 15.0012,
                                    'IXT': 11,
                                    'KBR': 143,
                                    'KICK': 112,
                                    'LA': 41,
                                    'LAT': 1.44,
                                    'LIFE': 13000,
                                    'LRC': 27,
                                    'LSK': 0.3,
                                    'LUN': 0.34,
                                    'MAID': 5,
                                    'MANA': 143,
                                    'MCAP': 5.44,
                                    'MIPS': 43,
                                    'MNE': 1.33,
                                    'MSP': 121,
                                    'MTH': 92,
                                    'MYB': 3.9,
                                    'NDC': 165,
                                    'NEBL': 0.04,
                                    'NET': 3.96,
                                    'NTO': 998,
                                    'NXC': 13.39,
                                    'NXT': 3,
                                    'OAX': 15,
                                    'ODN': 0.004,
                                    'OMG': 2,
                                    'OPT': 335,
                                    'ORME': 2.8,
                                    'OTN': 0.57,
                                    'PAY': 3.1,
                                    'PIX': 96,
                                    'PLBT': 0.33,
                                    'PLR': 114,
                                    'PLU': 0.87,
                                    'POE': 784,
                                    'POLL': 3.5,
                                    'PPT': 2,
                                    'PRE': 32,
                                    'PRG': 39,
                                    'PRO': 41,
                                    'PRS': 60,
                                    'PTOY': 0.5,
                                    'QAU': 63,
                                    'QCN': 0.03,
                                    'QTUM': 0.04,
                                    'QVT': 64,
                                    'REP': 0.02,
                                    'RKC': 15,
                                    'RVT': 14,
                                    'SAN': 2.24,
                                    'SBD': 0.03,
                                    'SCL': 2.6,
                                    'SISA': 1640,
                                    'SKIN': 407,
                                    'SMART': 0.4,
                                    'SMS': 0.0375,
                                    'SNC': 36,
                                    'SNGLS': 4,
                                    'SNM': 48,
                                    'SNT': 233,
                                    'STEEM': 0.01,
                                    'STRAT': 0.01,
                                    'STU': 14,
                                    'STX': 11,
                                    'SUB': 17,
                                    'SUR': 3,
                                    'SWT': 0.51,
                                    'TAAS': 0.91,
                                    'TBT': 2.37,
                                    'TFL': 15,
                                    'TIME': 0.03,
                                    'TIX': 7.1,
                                    'TKN': 1,
                                    'TKR': 84,
                                    'TNT': 90,
                                    'TRST': 1.6,
                                    'TRX': 1395,
                                    'UET': 480,
                                    'UGT': 15,
                                    'VEN': 14,
                                    'VERI': 0.037,
                                    'VIB': 50,
                                    'VIBE': 145,
                                    'VOISE': 618,
                                    'WEALTH': 0.0168,
                                    'WINGS': 2.4,
                                    'WTC': 0.75,
                                    'XAUR': 3.23,
                                    'XDN': 0.01,
                                    'XEM': 15,
                                    'XUC': 0.9,
                                    'YOYOW': 140,
                                    'ZAP': 24,
                                    'ZRX': 23,
                                    'ZSC': 191,
                                },
                                'deposit': {
                                    'BTC': 0.0006,
                                    'ETH': 0.003,
                                    'BCH': 0,
                                    'USDT': 0,
                                    'BTG': 0,
                                    'LTC': 0,
                                    'ZEC': 0,
                                    'XMR': 0,
                                    '1ST': 0,
                                    'ADX': 0,
                                    'AE': 0,
                                    'AEON': 0,
                                    'AIR': 0,
                                    'AMP': 0,
                                    'ANT': 0,
                                    'ARDR': 0,
                                    'ARN': 0,
                                    'ART': 0,
                                    'ATB': 0,
                                    'ATL': 0,
                                    'ATM': 0,
                                    'ATS': 0,
                                    'AVT': 0,
                                    'BAS': 0,
                                    'BCN': 0,
                                    'BET': 0,
                                    'BKB': 0,
                                    'BMC': 0,
                                    'BMT': 0,
                                    'BNT': 0,
                                    'BQX': 0,
                                    'BTM': 0,
                                    'BTX': 0,
                                    'BUS': 0,
                                    'CCT': 0,
                                    'CDT': 0,
                                    'CDX': 0,
                                    'CFI': 0,
                                    'CLD': 0,
                                    'CND': 0,
                                    'CNX': 0,
                                    'COSS': 0,
                                    'CSNO': 0,
                                    'CTR': 0,
                                    'CTX': 0,
                                    'CVC': 0,
                                    'DBIX': 0,
                                    'DCN': 0,
                                    'DCT': 0,
                                    'DDF': 0,
                                    'DENT': 0,
                                    'DGB': 0,
                                    'DGD': 0,
                                    'DICE': 0,
                                    'DLT': 0,
                                    'DNT': 0,
                                    'DOGE': 0,
                                    'DOV': 0,
                                    'DRPU': 0,
                                    'DRT': 0,
                                    'DSH': 0,
                                    'EBET': 0,
                                    'EBTC': 0,
                                    'EBTCOLD': 0,
                                    'ECAT': 0,
                                    'EDG': 0,
                                    'EDO': 0,
                                    'ELE': 0,
                                    'ELM': 0,
                                    'EMC': 0,
                                    'EMGO': 0,
                                    'ENJ': 0,
                                    'EOS': 0,
                                    'ERO': 0,
                                    'ETBS': 0,
                                    'ETC': 0,
                                    'ETP': 0,
                                    'EVX': 0,
                                    'EXN': 0,
                                    'FRD': 0,
                                    'FUEL': 0,
                                    'FUN': 0,
                                    'FYN': 0,
                                    'FYP': 0,
                                    'GNO': 0,
                                    'GUP': 0,
                                    'GVT': 0,
                                    'HAC': 0,
                                    'HDG': 0,
                                    'HGT': 0,
                                    'HPC': 0,
                                    'HVN': 0,
                                    'ICN': 0,
                                    'ICO': 0,
                                    'ICOS': 0,
                                    'IND': 0,
                                    'INDI': 0,
                                    'ITS': 0,
                                    'IXT': 0,
                                    'KBR': 0,
                                    'KICK': 0,
                                    'LA': 0,
                                    'LAT': 0,
                                    'LIFE': 0,
                                    'LRC': 0,
                                    'LSK': 0,
                                    'LUN': 0,
                                    'MAID': 0,
                                    'MANA': 0,
                                    'MCAP': 0,
                                    'MIPS': 0,
                                    'MNE': 0,
                                    'MSP': 0,
                                    'MTH': 0,
                                    'MYB': 0,
                                    'NDC': 0,
                                    'NEBL': 0,
                                    'NET': 0,
                                    'NTO': 0,
                                    'NXC': 0,
                                    'NXT': 0,
                                    'OAX': 0,
                                    'ODN': 0,
                                    'OMG': 0,
                                    'OPT': 0,
                                    'ORME': 0,
                                    'OTN': 0,
                                    'PAY': 0,
                                    'PIX': 0,
                                    'PLBT': 0,
                                    'PLR': 0,
                                    'PLU': 0,
                                    'POE': 0,
                                    'POLL': 0,
                                    'PPT': 0,
                                    'PRE': 0,
                                    'PRG': 0,
                                    'PRO': 0,
                                    'PRS': 0,
                                    'PTOY': 0,
                                    'QAU': 0,
                                    'QCN': 0,
                                    'QTUM': 0,
                                    'QVT': 0,
                                    'REP': 0,
                                    'RKC': 0,
                                    'RVT': 0,
                                    'SAN': 0,
                                    'SBD': 0,
                                    'SCL': 0,
                                    'SISA': 0,
                                    'SKIN': 0,
                                    'SMART': 0,
                                    'SMS': 0,
                                    'SNC': 0,
                                    'SNGLS': 0,
                                    'SNM': 0,
                                    'SNT': 0,
                                    'STEEM': 0,
                                    'STRAT': 0,
                                    'STU': 0,
                                    'STX': 0,
                                    'SUB': 0,
                                    'SUR': 0,
                                    'SWT': 0,
                                    'TAAS': 0,
                                    'TBT': 0,
                                    'TFL': 0,
                                    'TIME': 0,
                                    'TIX': 0,
                                    'TKN': 0,
                                    'TKR': 0,
                                    'TNT': 0,
                                    'TRST': 0,
                                    'TRX': 0,
                                    'UET': 0,
                                    'UGT': 0,
                                    'VEN': 0,
                                    'VERI': 0,
                                    'VIB': 0,
                                    'VIBE': 0,
                                    'VOISE': 0,
                                    'WEALTH': 0,
                                    'WINGS': 0,
                                    'WTC': 0,
                                    'XAUR': 0,
                                    'XDN': 0,
                                    'XEM': 0,
                                    'XUC': 0,
                                    'YOYOW': 0,
                                    'ZAP': 0,
                                    'ZRX': 0,
                                    'ZSC': 0,
                                },
                            },
                        },
                    });
                };
                hitbtc.prototype.commonCurrencyCode = function (currency) {
                    var currencies = {
                        'XBT': 'BTC',
                        'DRK': 'DASH',
                        'CAT': 'BitClave',
                        'USD': 'USDT',
                        'EMGO': 'MGO',
                    };
                    if (currency in currencies)
                        return currencies[currency];
                    return currency;
                };
                hitbtc.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, baseId, quoteId, lot, step, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetSymbols()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets['symbols'].length; p++) {
                                        market = markets['symbols'][p];
                                        id = market['symbol'];
                                        baseId = market['commodity'];
                                        quoteId = market['currency'];
                                        lot = parseFloat(market['lot']);
                                        step = parseFloat(market['step']);
                                        base = this.commonCurrencyCode(baseId);
                                        quote = this.commonCurrencyCode(quoteId);
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'lot': lot,
                                            'step': step,
                                            'info': market,
                                            'maker': this.safeFloat(market, 'provideLiquidityRate'),
                                            'taker': this.safeFloat(market, 'takeLiquidityRate'),
                                            'precision': {
                                                'amount': this.precisionFromString(market['lot']),
                                                'price': this.precisionFromString(market['step']),
                                            },
                                            'limits': {
                                                'amount': {
                                                    'min': lot,
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': step,
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                hitbtc.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, query, response, balances, result, b, balance, code, currency, free, used, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = this.safeString(params, 'type', 'trading');
                                    method += 'GetBalance';
                                    query = this.omit(params, 'type');
                                    return [4, this[method](query)];
                                case 2:
                                    response = _a.sent();
                                    balances = response['balance'];
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        code = balance['currency_code'];
                                        currency = this.commonCurrencyCode(code);
                                        free = this.safeFloat(balance, 'cash', 0.0);
                                        free = this.safeFloat(balance, 'balance', free);
                                        used = this.safeFloat(balance, 'reserved', 0.0);
                                        account = {
                                            'free': free,
                                            'used': used,
                                            'total': this.sum(free, used),
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                hitbtc.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetSymbolOrderbook(this.extend({
                                            'symbol': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                hitbtc.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['timestamp'];
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high'),
                        'low': this.safeFloat(ticker, 'low'),
                        'bid': this.safeFloat(ticker, 'bid'),
                        'ask': this.safeFloat(ticker, 'ask'),
                        'vwap': undefined,
                        'open': this.safeFloat(ticker, 'open'),
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last'),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'volume'),
                        'quoteVolume': this.safeFloat(ticker, 'volume_quote'),
                        'info': ticker,
                    };
                };
                hitbtc.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, ids, result, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                hitbtc.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetSymbolTicker(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    if ('message' in ticker)
                                        throw new ExchangeError(this.id + ' ' + ticker['message']);
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                hitbtc.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    if (Array.isArray(trade))
                        return this.parsePublicTrade(trade, market);
                    return this.parseOrderTrade(trade, market);
                };
                hitbtc.prototype.parsePublicTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'info': trade,
                        'id': trade[0].toString(),
                        'timestamp': trade[3],
                        'datetime': this.iso8601(trade[3]),
                        'symbol': symbol,
                        'type': undefined,
                        'side': trade[4],
                        'price': parseFloat(trade[1]),
                        'amount': parseFloat(trade[2]),
                    };
                };
                hitbtc.prototype.parseOrderTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var amount = parseFloat(trade['execQuantity']);
                    if (market)
                        amount *= market['lot'];
                    var price = parseFloat(trade['execPrice']);
                    var cost = price * amount;
                    var fee = {
                        'cost': parseFloat(trade['fee']),
                        'currency': undefined,
                        'rate': undefined,
                    };
                    var timestamp = trade['timestamp'];
                    return {
                        'info': trade,
                        'id': trade['tradeId'],
                        'order': trade['clientOrderId'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': undefined,
                        'side': trade['side'],
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'fee': fee,
                    };
                };
                hitbtc.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetSymbolTrades(this.extend({
                                            'symbol': market['id'],
                                            'side': 'true',
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['trades'], market, since, limit)];
                            }
                        });
                    });
                };
                hitbtc.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, quantity, wholeLots, difference, clientOrderId, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    quantity = parseFloat(amount) / market['lot'];
                                    wholeLots = Math.round(quantity);
                                    difference = quantity - wholeLots;
                                    if (Math.abs(difference) > market['step'])
                                        throw new ExchangeError(this.id + ' order amount should be evenly divisible by lot unit size of ' + market['lot'].toString());
                                    clientOrderId = this.milliseconds();
                                    order = {
                                        'clientOrderId': clientOrderId.toString(),
                                        'symbol': market['id'],
                                        'side': side,
                                        'quantity': wholeLots.toString(),
                                        'type': type,
                                    };
                                    if (type === 'limit') {
                                        order['price'] = this.priceToPrecision(symbol, price);
                                    }
                                    else {
                                        order['timeInForce'] = 'FOK';
                                    }
                                    return [4, this.tradingPostNewOrder(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response['ExecutionReport'], market)];
                            }
                        });
                    });
                };
                hitbtc.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.tradingPostCancelOrder(this.extend({
                                            'clientOrderId': id,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                hitbtc.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        'new': 'open',
                        'partiallyFilled': 'open',
                        'filled': 'closed',
                        'canceled': 'canceled',
                        'rejected': 'rejected',
                        'expired': 'expired',
                    };
                    return this.safeString(statuses, status);
                };
                hitbtc.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.safeInteger(order, 'lastTimestamp');
                    if (typeof timestamp === 'undefined')
                        timestamp = this.safeInteger(order, 'timestamp');
                    var symbol = undefined;
                    if (!market)
                        market = this.markets_by_id[order['symbol']];
                    var status = this.safeString(order, 'orderStatus');
                    if (status)
                        status = this.parseOrderStatus(status);
                    var averagePrice = this.safeFloat(order, 'avgPrice', 0.0);
                    var price = this.safeFloat(order, 'orderPrice');
                    if (typeof price === 'undefined')
                        price = this.safeFloat(order, 'price');
                    var amount = this.safeFloat(order, 'orderQuantity');
                    if (typeof amount === 'undefined')
                        amount = this.safeFloat(order, 'quantity');
                    var remaining = this.safeFloat(order, 'quantityLeaves');
                    if (typeof remaining === 'undefined')
                        remaining = this.safeFloat(order, 'leavesQuantity');
                    var filled = undefined;
                    var cost = undefined;
                    var amountDefined = (typeof amount !== 'undefined');
                    var remainingDefined = (typeof remaining !== 'undefined');
                    if (market) {
                        symbol = market['symbol'];
                        if (amountDefined)
                            amount *= market['lot'];
                        if (remainingDefined)
                            remaining *= market['lot'];
                    }
                    if (amountDefined) {
                        if (remainingDefined) {
                            filled = amount - remaining;
                            cost = averagePrice * filled;
                        }
                    }
                    return {
                        'id': order['clientOrderId'].toString(),
                        'info': order,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': status,
                        'symbol': symbol,
                        'type': order['type'],
                        'side': order['side'],
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'fee': undefined,
                    };
                };
                hitbtc.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.tradingGetOrder(this.extend({
                                            'clientOrderId': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    if (response['orders'][0]) {
                                        return [2, this.parseOrder(response['orders'][0])];
                                    }
                                    throw new OrderNotFound(this.id + ' fetchOrder() error: ' + this.response);
                            }
                        });
                    });
                };
                hitbtc.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var statuses, market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    statuses = ['new', 'partiallyFiiled'];
                                    market = undefined;
                                    request = {
                                        'sort': 'desc',
                                        'statuses': statuses.join(','),
                                    };
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['symbols'] = market['id'];
                                    }
                                    return [4, this.tradingGetOrdersActive(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response['orders'], market, since, limit)];
                            }
                        });
                    });
                };
                hitbtc.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, statuses, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    statuses = ['filled', 'canceled', 'rejected', 'expired'];
                                    request = {
                                        'sort': 'desc',
                                        'statuses': statuses.join(','),
                                        'max_results': 1000,
                                    };
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['symbols'] = market['id'];
                                    }
                                    return [4, this.tradingGetOrdersRecent(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response['orders'], market, since, limit)];
                            }
                        });
                    });
                };
                hitbtc.prototype.fetchOrderTrades = function (id, symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (typeof symbol !== 'undefined')
                                        market = this.market(symbol);
                                    return [4, this.tradingGetTradesByOrder(this.extend({
                                            'clientOrderId': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['trades'], market, since, limit)];
                            }
                        });
                    });
                };
                hitbtc.prototype.withdraw = function (code, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    request = {
                                        'currency_code': currency['id'],
                                        'amount': amount,
                                        'address': address,
                                    };
                                    if (tag)
                                        request['paymentId'] = tag;
                                    return [4, this.paymentPostPayout(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['transaction'],
                                        }];
                            }
                        });
                    });
                };
                hitbtc.prototype.nonce = function () {
                    return this.milliseconds();
                };
                hitbtc.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = '/' + 'api' + '/' + this.version + '/' + api + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var payload = { 'nonce': nonce, 'apikey': this.apiKey };
                        query = this.extend(payload, query);
                        if (method === 'GET')
                            url += '?' + this.urlencode(query);
                        else
                            url += '?' + this.urlencode(payload);
                        var auth = url;
                        if (method === 'POST') {
                            if (Object.keys(query).length) {
                                body = this.urlencode(query);
                                auth += body;
                            }
                        }
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-Signature': this.hmac(this.encode(auth), this.encode(this.secret), 'sha512').toLowerCase(),
                        };
                    }
                    url = this.urls['api'] + url;
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                hitbtc.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('code' in response) {
                                        if ('ExecutionReport' in response) {
                                            if (response['ExecutionReport']['orderRejectReason'] === 'orderExceedsLimit')
                                                throw new InsufficientFunds(this.id + ' ' + this.json(response));
                                        }
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return hitbtc;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 79: [function (require, module, exports) {
            'use strict';
            var hitbtc = require('./hitbtc');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, OrderNotFound = _a.OrderNotFound, InsufficientFunds = _a.InsufficientFunds, InvalidOrder = _a.InvalidOrder;
            module.exports = (function (_super) {
                __extends(hitbtc2, _super);
                function hitbtc2() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                hitbtc2.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'hitbtc2',
                        'name': 'HitBTC v2',
                        'countries': 'UK',
                        'rateLimit': 1500,
                        'version': '2',
                        'has': {
                            'createDepositAddress': true,
                            'fetchDepositAddress': true,
                            'CORS': true,
                            'editOrder': true,
                            'fetchCurrencies': true,
                            'fetchOHLCV': true,
                            'fetchTickers': true,
                            'fetchOrder': true,
                            'fetchOrders': false,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'fetchMyTrades': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1m': 'M1',
                            '3m': 'M3',
                            '5m': 'M5',
                            '15m': 'M15',
                            '30m': 'M30',
                            '1h': 'H1',
                            '4h': 'H4',
                            '1d': 'D1',
                            '1w': 'D7',
                            '1M': '1M',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg',
                            'api': 'https://api.hitbtc.com',
                            'www': 'https://hitbtc.com',
                            'doc': 'https://api.hitbtc.com',
                            'fees': [
                                'https://hitbtc.com/fees-and-limits',
                                'https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'symbol',
                                    'symbol/{symbol}',
                                    'currency',
                                    'currency/{currency}',
                                    'ticker',
                                    'ticker/{symbol}',
                                    'trades/{symbol}',
                                    'orderbook/{symbol}',
                                    'candles/{symbol}',
                                ],
                            },
                            'private': {
                                'get': [
                                    'order',
                                    'order/{clientOrderId}',
                                    'trading/balance',
                                    'trading/fee/{symbol}',
                                    'history/trades',
                                    'history/order',
                                    'history/order/{id}/trades',
                                    'account/balance',
                                    'account/transactions',
                                    'account/transactions/{id}',
                                    'account/crypto/address/{currency}',
                                ],
                                'post': [
                                    'order',
                                    'account/crypto/withdraw',
                                    'account/crypto/address/{currency}',
                                    'account/transfer',
                                ],
                                'put': [
                                    'order/{clientOrderId}',
                                    'account/crypto/withdraw/{id}',
                                ],
                                'delete': [
                                    'order',
                                    'order/{clientOrderId}',
                                    'account/crypto/withdraw/{id}',
                                ],
                                'patch': [
                                    'order/{clientOrderId}',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'maker': -0.01 / 100,
                                'taker': 0.1 / 100,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0.001,
                                    'BCC': 0.0018,
                                    'ETH': 0.00958,
                                    'BCH': 0.0018,
                                    'USDT': 100,
                                    'DASH': 0.03,
                                    'BTG': 0.0005,
                                    'XRP': 0.509,
                                    'LTC': 0.003,
                                    'ZEC': 0.0001,
                                    'XMR': 0.09,
                                    '1ST': 0.84,
                                    'ADX': 5.7,
                                    'AE': 6.7,
                                    'AEON': 0.01006,
                                    'AIR': 565,
                                    'AMM': 14,
                                    'AMP': 342,
                                    'ANT': 6.7,
                                    'ARDR': 1,
                                    'ARN': 18.5,
                                    'ART': 26,
                                    'ATB': 0.0004,
                                    'ATL': 27,
                                    'ATM': 504,
                                    'ATS': 860,
                                    'AVT': 1.9,
                                    'BAS': 113,
                                    'BCN': 0.1,
                                    'BET': 124,
                                    'BKB': 46,
                                    'BMC': 32,
                                    'BMT': 100,
                                    'BNT': 2.57,
                                    'BQX': 4.7,
                                    'BTCA': 351.21,
                                    'BTM': 40,
                                    'BTX': 0.04,
                                    'BUS': 0.004,
                                    'CAPP': 97,
                                    'CCT': 6,
                                    'CDT': 100,
                                    'CDX': 30,
                                    'CFI': 61,
                                    'CL': 13.85,
                                    'CLD': 0.88,
                                    'CND': 574,
                                    'CNX': 0.04,
                                    'COSS': 65,
                                    'CPAY': 5.487,
                                    'CSNO': 16,
                                    'CTR': 15,
                                    'CTX': 146,
                                    'CVC': 8.46,
                                    'DATA': 12.949,
                                    'DBIX': 0.0168,
                                    'DCN': 1280,
                                    'DCT': 0.02,
                                    'DDF': 342,
                                    'DENT': 1000,
                                    'DGB': 0.4,
                                    'DGD': 0.01,
                                    'DICE': 0.32,
                                    'DLT': 0.26,
                                    'DNT': 0.21,
                                    'DOGE': 2,
                                    'DOV': 34,
                                    'DRPU': 24,
                                    'DRT': 240,
                                    'DSH': 0.017,
                                    'EBET': 84,
                                    'EBTC': 20,
                                    'EBTCOLD': 6.6,
                                    'ECAT': 14,
                                    'EDG': 2,
                                    'EDO': 2.9,
                                    'EKO': 1136.36,
                                    'ELE': 0.00172,
                                    'ELM': 0.004,
                                    'EMC': 0.03,
                                    'MGO': 14,
                                    'ENJ': 163,
                                    'EOS': 1.5,
                                    'ERO': 34,
                                    'ETBS': 15,
                                    'ETC': 0.002,
                                    'ETP': 0.004,
                                    'EVX': 5.4,
                                    'EXN': 456,
                                    'FCN': 0.000005,
                                    'FRD': 65,
                                    'FUEL': 123.00105,
                                    'FUN': 202.9598309,
                                    'FYN': 1.849,
                                    'FYP': 66.13,
                                    'GAME': 0.004,
                                    'GNO': 0.0034,
                                    'GUP': 4,
                                    'GVT': 1.2,
                                    'HSR': 0.04,
                                    'HAC': 144,
                                    'HDG': 7,
                                    'HGT': 1082,
                                    'HPC': 0.4,
                                    'HVN': 120,
                                    'ICN': 0.55,
                                    'ICO': 34,
                                    'ICOS': 0.35,
                                    'IND': 76,
                                    'INDI': 790,
                                    'ITS': 15.0012,
                                    'IXT': 11,
                                    'KBR': 143,
                                    'KICK': 112,
                                    'KMD': 4,
                                    'LA': 41,
                                    'LEND': 388,
                                    'LAT': 1.44,
                                    'LIFE': 13000,
                                    'LRC': 27,
                                    'LSK': 0.3,
                                    'LOC': 11.076,
                                    'LUN': 0.34,
                                    'MAID': 5,
                                    'MANA': 143,
                                    'MCAP': 5.44,
                                    'MIPS': 43,
                                    'MNE': 1.33,
                                    'MSP': 121,
                                    'MCO': 0.357,
                                    'MTH': 92,
                                    'MYB': 3.9,
                                    'NDC': 165,
                                    'NEBL': 0.04,
                                    'NET': 3.96,
                                    'NTO': 998,
                                    'NGC': 2.368,
                                    'NXC': 13.39,
                                    'NXT': 3,
                                    'OAX': 15,
                                    'ODN': 0.004,
                                    'OMG': 2,
                                    'OPT': 335,
                                    'ORME': 2.8,
                                    'OTN': 0.57,
                                    'PAY': 3.1,
                                    'PIX': 96,
                                    'PLBT': 0.33,
                                    'PLR': 114,
                                    'PLU': 0.87,
                                    'POE': 784,
                                    'POLL': 3.5,
                                    'PPT': 2,
                                    'PRE': 32,
                                    'PRG': 39,
                                    'PRO': 41,
                                    'PRS': 60,
                                    'PTOY': 0.5,
                                    'QAU': 63,
                                    'QCN': 0.03,
                                    'QTUM': 0.04,
                                    'QVT': 64,
                                    'REP': 0.02,
                                    'RKC': 15,
                                    'RLC': 1.21,
                                    'RVT': 14,
                                    'SC': 30,
                                    'SAN': 2.24,
                                    'SBD': 0.03,
                                    'SCL': 2.6,
                                    'SISA': 1640,
                                    'SKIN': 407,
                                    'SWFTC': 352.94,
                                    'SMART': 0.4,
                                    'SMS': 0.0375,
                                    'SNC': 36,
                                    'SNGLS': 4,
                                    'SNM': 48,
                                    'SNT': 233,
                                    'STAR': 0.144,
                                    'STORM': 153.19,
                                    'STEEM': 0.01,
                                    'STRAT': 0.01,
                                    'SPF': 14.4,
                                    'STU': 14,
                                    'STX': 11,
                                    'SUB': 17,
                                    'SUR': 3,
                                    'SWT': 0.51,
                                    'TAAS': 0.91,
                                    'TBT': 2.37,
                                    'TFL': 15,
                                    'TIME': 0.03,
                                    'TIX': 7.1,
                                    'TKN': 1,
                                    'TGT': 173,
                                    'TKR': 84,
                                    'TNT': 90,
                                    'TRST': 1.6,
                                    'TRX': 270,
                                    'UET': 480,
                                    'UGT': 15,
                                    'UTT': 3,
                                    'VEN': 14,
                                    'VERI': 0.037,
                                    'VIB': 50,
                                    'VIBE': 145,
                                    'VOISE': 618,
                                    'WEALTH': 0.0168,
                                    'WINGS': 2.4,
                                    'WTC': 0.75,
                                    'WRC': 48,
                                    'XAUR': 3.23,
                                    'XDN': 0.01,
                                    'XEM': 15,
                                    'XUC': 0.9,
                                    'YOYOW': 140,
                                    'ZAP': 24,
                                    'ZRX': 23,
                                    'ZSC': 191,
                                },
                                'deposit': {
                                    'BTC': 0.0006,
                                    'ETH': 0.003,
                                    'BCH': 0,
                                    'USDT': 0,
                                    'BTG': 0,
                                    'LTC': 0,
                                    'ZEC': 0,
                                    'XMR': 0,
                                    '1ST': 0,
                                    'ADX': 0,
                                    'AE': 0,
                                    'AEON': 0,
                                    'AIR': 0,
                                    'AMP': 0,
                                    'ANT': 0,
                                    'ARDR': 0,
                                    'ARN': 0,
                                    'ART': 0,
                                    'ATB': 0,
                                    'ATL': 0,
                                    'ATM': 0,
                                    'ATS': 0,
                                    'AVT': 0,
                                    'BAS': 0,
                                    'BCN': 0,
                                    'BET': 0,
                                    'BKB': 0,
                                    'BMC': 0,
                                    'BMT': 0,
                                    'BNT': 0,
                                    'BQX': 0,
                                    'BTM': 0,
                                    'BTX': 0,
                                    'BUS': 0,
                                    'CCT': 0,
                                    'CDT': 0,
                                    'CDX': 0,
                                    'CFI': 0,
                                    'CLD': 0,
                                    'CND': 0,
                                    'CNX': 0,
                                    'COSS': 0,
                                    'CSNO': 0,
                                    'CTR': 0,
                                    'CTX': 0,
                                    'CVC': 0,
                                    'DBIX': 0,
                                    'DCN': 0,
                                    'DCT': 0,
                                    'DDF': 0,
                                    'DENT': 0,
                                    'DGB': 0,
                                    'DGD': 0,
                                    'DICE': 0,
                                    'DLT': 0,
                                    'DNT': 0,
                                    'DOGE': 0,
                                    'DOV': 0,
                                    'DRPU': 0,
                                    'DRT': 0,
                                    'DSH': 0,
                                    'EBET': 0,
                                    'EBTC': 0,
                                    'EBTCOLD': 0,
                                    'ECAT': 0,
                                    'EDG': 0,
                                    'EDO': 0,
                                    'ELE': 0,
                                    'ELM': 0,
                                    'EMC': 0,
                                    'EMGO': 0,
                                    'ENJ': 0,
                                    'EOS': 0,
                                    'ERO': 0,
                                    'ETBS': 0,
                                    'ETC': 0,
                                    'ETP': 0,
                                    'EVX': 0,
                                    'EXN': 0,
                                    'FRD': 0,
                                    'FUEL': 0,
                                    'FUN': 0,
                                    'FYN': 0,
                                    'FYP': 0,
                                    'GNO': 0,
                                    'GUP': 0,
                                    'GVT': 0,
                                    'HAC': 0,
                                    'HDG': 0,
                                    'HGT': 0,
                                    'HPC': 0,
                                    'HVN': 0,
                                    'ICN': 0,
                                    'ICO': 0,
                                    'ICOS': 0,
                                    'IND': 0,
                                    'INDI': 0,
                                    'ITS': 0,
                                    'IXT': 0,
                                    'KBR': 0,
                                    'KICK': 0,
                                    'LA': 0,
                                    'LAT': 0,
                                    'LIFE': 0,
                                    'LRC': 0,
                                    'LSK': 0,
                                    'LUN': 0,
                                    'MAID': 0,
                                    'MANA': 0,
                                    'MCAP': 0,
                                    'MIPS': 0,
                                    'MNE': 0,
                                    'MSP': 0,
                                    'MTH': 0,
                                    'MYB': 0,
                                    'NDC': 0,
                                    'NEBL': 0,
                                    'NET': 0,
                                    'NTO': 0,
                                    'NXC': 0,
                                    'NXT': 0,
                                    'OAX': 0,
                                    'ODN': 0,
                                    'OMG': 0,
                                    'OPT': 0,
                                    'ORME': 0,
                                    'OTN': 0,
                                    'PAY': 0,
                                    'PIX': 0,
                                    'PLBT': 0,
                                    'PLR': 0,
                                    'PLU': 0,
                                    'POE': 0,
                                    'POLL': 0,
                                    'PPT': 0,
                                    'PRE': 0,
                                    'PRG': 0,
                                    'PRO': 0,
                                    'PRS': 0,
                                    'PTOY': 0,
                                    'QAU': 0,
                                    'QCN': 0,
                                    'QTUM': 0,
                                    'QVT': 0,
                                    'REP': 0,
                                    'RKC': 0,
                                    'RVT': 0,
                                    'SAN': 0,
                                    'SBD': 0,
                                    'SCL': 0,
                                    'SISA': 0,
                                    'SKIN': 0,
                                    'SMART': 0,
                                    'SMS': 0,
                                    'SNC': 0,
                                    'SNGLS': 0,
                                    'SNM': 0,
                                    'SNT': 0,
                                    'STEEM': 0,
                                    'STRAT': 0,
                                    'STU': 0,
                                    'STX': 0,
                                    'SUB': 0,
                                    'SUR': 0,
                                    'SWT': 0,
                                    'TAAS': 0,
                                    'TBT': 0,
                                    'TFL': 0,
                                    'TIME': 0,
                                    'TIX': 0,
                                    'TKN': 0,
                                    'TKR': 0,
                                    'TNT': 0,
                                    'TRST': 0,
                                    'TRX': 0,
                                    'UET': 0,
                                    'UGT': 0,
                                    'VEN': 0,
                                    'VERI': 0,
                                    'VIB': 0,
                                    'VIBE': 0,
                                    'VOISE': 0,
                                    'WEALTH': 0,
                                    'WINGS': 0,
                                    'WTC': 0,
                                    'XAUR': 0,
                                    'XDN': 0,
                                    'XEM': 0,
                                    'XUC': 0,
                                    'YOYOW': 0,
                                    'ZAP': 0,
                                    'ZRX': 0,
                                    'ZSC': 0,
                                },
                            },
                        },
                    });
                };
                hitbtc2.prototype.commonCurrencyCode = function (currency) {
                    var currencies = {
                        'XBT': 'BTC',
                        'DRK': 'DASH',
                        'CAT': 'BitClave',
                        'USD': 'USDT',
                        'EMGO': 'MGO',
                    };
                    if (currency in currencies)
                        return currencies[currency];
                    return currency;
                };
                hitbtc2.prototype.feeToPrecision = function (symbol, fee) {
                    return this.truncate(fee, 8);
                };
                hitbtc2.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, i, market, id, baseId, quoteId, base, quote, symbol, lot, step, precision, taker, maker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetSymbol()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        id = market['id'];
                                        baseId = market['baseCurrency'];
                                        quoteId = market['quoteCurrency'];
                                        base = this.commonCurrencyCode(baseId);
                                        quote = this.commonCurrencyCode(quoteId);
                                        symbol = base + '/' + quote;
                                        lot = parseFloat(market['quantityIncrement']);
                                        step = parseFloat(market['tickSize']);
                                        precision = {
                                            'price': this.precisionFromString(market['tickSize']),
                                            'amount': this.precisionFromString(market['quantityIncrement']),
                                        };
                                        taker = parseFloat(market['takeLiquidityRate']);
                                        maker = parseFloat(market['provideLiquidityRate']);
                                        result.push(this.extend(this.fees['trading'], {
                                            'info': market,
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'active': true,
                                            'lot': lot,
                                            'step': step,
                                            'taker': taker,
                                            'maker': maker,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': lot,
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': step,
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': lot * step,
                                                    'max': undefined,
                                                },
                                            },
                                        }));
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencies, result, i, currency, id, precision, code, payin, payout, transfer, active, status_5, type;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetCurrency(params)];
                                case 1:
                                    currencies = _a.sent();
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['id'];
                                        precision = 8;
                                        code = this.commonCurrencyCode(id);
                                        payin = this.safeValue(currency, 'payinEnabled');
                                        payout = this.safeValue(currency, 'payoutEnabled');
                                        transfer = this.safeValue(currency, 'transferEnabled');
                                        active = payin && payout && transfer;
                                        status_5 = 'ok';
                                        if ('disabled' in currency)
                                            if (currency['disabled'])
                                                status_5 = 'disabled';
                                        type = 'fiat';
                                        if (('crypto' in currency) && currency['crypto'])
                                            type = 'crypto';
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'type': type,
                                            'payin': payin,
                                            'payout': payout,
                                            'transfer': transfer,
                                            'info': currency,
                                            'name': currency['fullName'],
                                            'active': active,
                                            'status': status_5,
                                            'fee': undefined,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': undefined,
                                                    'max': Math.pow(10, precision),
                                                },
                                            },
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var type, method, balances, result, b, balance, code, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    type = this.safeString(params, 'type', 'trading');
                                    method = 'privateGet' + this.capitalize(type) + 'Balance';
                                    return [4, this[method]()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        code = balance['currency'];
                                        currency = this.commonCurrencyCode(code);
                                        account = {
                                            'free': parseFloat(balance['available']),
                                            'used': parseFloat(balance['reserved']),
                                            'total': 0.0,
                                        };
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                hitbtc2.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1d'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var timestamp = this.parse8601(ohlcv['timestamp']);
                    return [
                        timestamp,
                        parseFloat(ohlcv['open']),
                        parseFloat(ohlcv['max']),
                        parseFloat(ohlcv['min']),
                        parseFloat(ohlcv['close']),
                        parseFloat(ohlcv['volume']),
                    ];
                };
                hitbtc2.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'period': this.timeframes[timeframe],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetCandlesSymbol(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'symbol': this.marketId(symbol),
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetOrderbookSymbol(this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'bid', 'ask', 'price', 'size')];
                            }
                        });
                    });
                };
                hitbtc2.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(ticker['timestamp']);
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var baseVolume = this.safeFloat(ticker, 'volume');
                    var quoteVolume = this.safeFloat(ticker, 'volumeQuote');
                    var open = this.safeFloat(ticker, 'open');
                    var last = this.safeFloat(ticker, 'last');
                    var change = undefined;
                    var percentage = undefined;
                    var average = undefined;
                    if (typeof last !== 'undefined' && typeof open !== 'undefined') {
                        change = last - open;
                        average = this.sum(last, open) / 2;
                        if (open > 0)
                            percentage = change / open * 100;
                    }
                    var vwap = undefined;
                    if (typeof quoteVolume !== 'undefined')
                        if (typeof baseVolume !== 'undefined')
                            if (baseVolume > 0)
                                vwap = quoteVolume / baseVolume;
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high'),
                        'low': this.safeFloat(ticker, 'low'),
                        'bid': this.safeFloat(ticker, 'bid'),
                        'ask': this.safeFloat(ticker, 'ask'),
                        'vwap': vwap,
                        'open': open,
                        'close': last,
                        'last': last,
                        'previousClose': undefined,
                        'change': change,
                        'percentage': percentage,
                        'average': average,
                        'baseVolume': baseVolume,
                        'quoteVolume': quoteVolume,
                        'info': ticker,
                    };
                };
                hitbtc2.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result, i, ticker, id, market, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    result = {};
                                    for (i = 0; i < tickers.length; i++) {
                                        ticker = tickers[i];
                                        id = ticker['symbol'];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTickerSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    if ('message' in ticker)
                                        throw new ExchangeError(this.id + ' ' + ticker['message']);
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                hitbtc2.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(trade['timestamp']);
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    else {
                        var id = trade['symbol'];
                        if (id in this.markets_by_id) {
                            market = this.markets_by_id[id];
                            symbol = market['symbol'];
                        }
                        else {
                            symbol = id;
                        }
                    }
                    var fee = undefined;
                    if ('fee' in trade) {
                        var currency = market ? market['quote'] : undefined;
                        fee = {
                            'cost': parseFloat(trade['fee']),
                            'currency': currency,
                        };
                    }
                    var orderId = undefined;
                    if ('clientOrderId' in trade)
                        orderId = trade['clientOrderId'];
                    var price = parseFloat(trade['price']);
                    var amount = parseFloat(trade['quantity']);
                    var cost = price * amount;
                    return {
                        'info': trade,
                        'id': trade['id'].toString(),
                        'order': orderId,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': undefined,
                        'side': trade['side'],
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'fee': fee,
                    };
                };
                hitbtc2.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradesSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                hitbtc2.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, uuid, parts, clientOrderId, request, response, order, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    uuid = this.uuid();
                                    parts = uuid.split('-');
                                    clientOrderId = parts.join('');
                                    clientOrderId = clientOrderId.slice(0, 32);
                                    amount = parseFloat(amount);
                                    request = {
                                        'clientOrderId': clientOrderId,
                                        'symbol': market['id'],
                                        'side': side,
                                        'quantity': this.amountToPrecision(symbol, amount),
                                        'type': type,
                                    };
                                    if (type === 'limit') {
                                        request['price'] = this.priceToPrecision(symbol, price);
                                    }
                                    else {
                                        request['timeInForce'] = 'FOK';
                                    }
                                    return [4, this.privatePostOrder(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    order = this.parseOrder(response);
                                    id = order['id'];
                                    this.orders[id] = order;
                                    return [2, order];
                            }
                        });
                    });
                };
                hitbtc2.prototype.editOrder = function (id, symbol, type, side, amount, price, params) {
                    if (amount === void 0) { amount = undefined; }
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var uuid, parts, requestClientId, request, response, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    uuid = this.uuid();
                                    parts = uuid.split('-');
                                    requestClientId = parts.join('');
                                    requestClientId = requestClientId.slice(0, 32);
                                    request = {
                                        'clientOrderId': id,
                                        'requestClientId': requestClientId,
                                    };
                                    if (typeof amount !== 'undefined')
                                        request['quantity'] = this.amountToPrecision(symbol, parseFloat(amount));
                                    if (typeof price !== 'undefined')
                                        request['price'] = this.priceToPrecision(symbol, price);
                                    return [4, this.privatePatchOrderClientOrderId(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    order = this.parseOrder(response);
                                    this.orders[order['id']] = order;
                                    return [2, order];
                            }
                        });
                    });
                };
                hitbtc2.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateDeleteOrderClientOrderId(this.extend({
                                            'clientOrderId': id,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                hitbtc2.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var created = undefined;
                    if ('createdAt' in order)
                        created = this.parse8601(order['createdAt']);
                    var updated = undefined;
                    if ('updatedAt' in order)
                        updated = this.parse8601(order['updatedAt']);
                    if (!market)
                        market = this.markets_by_id[order['symbol']];
                    var symbol = market['symbol'];
                    var amount = this.safeFloat(order, 'quantity');
                    var filled = this.safeFloat(order, 'cumQuantity');
                    var status = order['status'];
                    if (status === 'new') {
                        status = 'open';
                    }
                    else if (status === 'suspended') {
                        status = 'open';
                    }
                    else if (status === 'partiallyFilled') {
                        status = 'open';
                    }
                    else if (status === 'filled') {
                        status = 'closed';
                    }
                    var id = order['clientOrderId'].toString();
                    var price = this.safeFloat(order, 'price');
                    if (typeof price === 'undefined') {
                        if (id in this.orders)
                            price = this.orders[id]['price'];
                    }
                    var remaining = undefined;
                    var cost = undefined;
                    if (typeof amount !== 'undefined') {
                        if (typeof filled !== 'undefined') {
                            remaining = amount - filled;
                            if (typeof price !== 'undefined') {
                                cost = filled * price;
                            }
                        }
                    }
                    return {
                        'id': id,
                        'timestamp': created,
                        'datetime': this.iso8601(created),
                        'created': created,
                        'updated': updated,
                        'status': status,
                        'symbol': symbol,
                        'type': order['type'],
                        'side': order['side'],
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'filled': filled,
                        'remaining': remaining,
                        'fee': undefined,
                        'info': order,
                    };
                };
                hitbtc2.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, numOrders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetHistoryOrder(this.extend({
                                            'clientOrderId': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    numOrders = response.length;
                                    if (numOrders > 0)
                                        return [2, this.parseOrder(response[0])];
                                    throw new OrderNotFound(this.id + ' order ' + id + ' not found');
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchOpenOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetOrderClientOrderId(this.extend({
                                            'clientOrderId': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response)];
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['symbol'] = market['id'];
                                    }
                                    return [4, this.privateGetOrder(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['symbol'] = market['id'];
                                    }
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    if (typeof since !== 'undefined')
                                        request['from'] = this.iso8601(since);
                                    return [4, this.privateGetHistoryOrder(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response, market);
                                    orders = this.filterBy(orders, 'status', 'closed');
                                    return [2, this.filterBySinceLimit(orders, since, limit)];
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    market = undefined;
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['symbol'] = market['id'];
                                    }
                                    if (typeof since !== 'undefined')
                                        request['from'] = this.iso8601(since);
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.privateGetHistoryTrades(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchOrderTrades = function (id, symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, numOrders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (typeof symbol !== 'undefined')
                                        market = this.market(symbol);
                                    return [4, this.privateGetHistoryOrderIdTrades(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    numOrders = response.length;
                                    if (numOrders > 0)
                                        return [2, this.parseTrades(response, market, since, limit)];
                                    throw new OrderNotFound(this.id + ' order ' + id + ' not found, ' + this.id + '.fetchOrderTrades() requires an exchange-specific order id, you need to grab it from order["info"]["id"]');
                            }
                        });
                    });
                };
                hitbtc2.prototype.createDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, address, tag;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privatePostAccountCryptoAddressCurrency({
                                            'currency': currency['id'],
                                        })];
                                case 2:
                                    response = _a.sent();
                                    address = response['address'];
                                    this.checkAddress(address);
                                    tag = this.safeString(response, 'paymentId');
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'tag': tag,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                hitbtc2.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, address, tag;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privateGetAccountCryptoAddressCurrency({
                                            'currency': currency['id'],
                                        })];
                                case 2:
                                    response = _a.sent();
                                    address = response['address'];
                                    this.checkAddress(address);
                                    tag = this.safeString(response, 'paymentId');
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'tag': tag,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                hitbtc2.prototype.withdraw = function (code, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    currency = this.currency(code);
                                    request = {
                                        'currency': currency['id'],
                                        'amount': parseFloat(amount),
                                        'address': address,
                                    };
                                    if (tag)
                                        request['paymentId'] = tag;
                                    return [4, this.privatePostAccountCryptoWithdraw(this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                hitbtc2.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = '/api' + '/' + this.version + '/';
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        url += api + '/' + this.implodeParams(path, params);
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        url += this.implodeParams(path, params);
                        if (method === 'GET') {
                            if (Object.keys(query).length)
                                url += '?' + this.urlencode(query);
                        }
                        else {
                            if (Object.keys(query).length)
                                body = this.json(query);
                        }
                        var payload = this.encode(this.apiKey + ':' + this.secret);
                        var auth = this.stringToBase64(payload);
                        headers = {
                            'Authorization': 'Basic ' + this.decode(auth),
                            'Content-Type': 'application/json',
                        };
                    }
                    url = this.urls['api'] + url;
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                hitbtc2.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code === 400) {
                        if (body[0] === '{') {
                            var response = JSON.parse(body);
                            if ('error' in response) {
                                if ('message' in response['error']) {
                                    var message = response['error']['message'];
                                    if (message === 'Order not found') {
                                        throw new OrderNotFound(this.id + ' order not found in active orders');
                                    }
                                    else if (message === 'Quantity not a valid number') {
                                        throw new InvalidOrder(this.id + ' ' + body);
                                    }
                                    else if (message === 'Insufficient funds') {
                                        throw new InsufficientFunds(this.id + ' ' + body);
                                    }
                                    else if (message === 'Duplicate clientOrderId') {
                                        throw new InvalidOrder(this.id + ' ' + body);
                                    }
                                }
                            }
                        }
                        throw new ExchangeError(this.id + ' ' + body);
                    }
                };
                hitbtc2.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('error' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return hitbtc2;
            }(hitbtc));
        }, { "./base/errors": 10, "./hitbtc": 78 }], 80: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(huobi, _super);
                function huobi() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                huobi.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'huobi',
                        'name': 'Huobi',
                        'countries': 'CN',
                        'rateLimit': 2000,
                        'version': 'v3',
                        'has': {
                            'CORS': false,
                            'fetchOHLCV': true,
                        },
                        'timeframes': {
                            '1m': '001',
                            '5m': '005',
                            '15m': '015',
                            '30m': '030',
                            '1h': '060',
                            '1d': '100',
                            '1w': '200',
                            '1M': '300',
                            '1y': '400',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
                            'api': 'http://api.huobi.com',
                            'www': 'https://www.huobi.com',
                            'doc': 'https://github.com/huobiapi/API_Docs_en/wiki',
                        },
                        'api': {
                            'staticmarket': {
                                'get': [
                                    '{id}_kline_{period}',
                                    'ticker_{id}',
                                    'depth_{id}',
                                    'depth_{id}_{length}',
                                    'detail_{id}',
                                ],
                            },
                            'usdmarket': {
                                'get': [
                                    '{id}_kline_{period}',
                                    'ticker_{id}',
                                    'depth_{id}',
                                    'depth_{id}_{length}',
                                    'detail_{id}',
                                ],
                            },
                            'trade': {
                                'post': [
                                    'get_account_info',
                                    'get_orders',
                                    'order_info',
                                    'buy',
                                    'sell',
                                    'buy_market',
                                    'sell_market',
                                    'cancel_order',
                                    'get_new_deal_orders',
                                    'get_order_id_by_trade_id',
                                    'withdraw_coin',
                                    'cancel_withdraw_coin',
                                    'get_withdraw_coin_result',
                                    'transfer',
                                    'loan',
                                    'repayment',
                                    'get_loan_available',
                                    'get_loans',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/CNY': { 'id': 'btc', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'type': 'staticmarket', 'coinType': 1 },
                            'LTC/CNY': { 'id': 'ltc', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'type': 'staticmarket', 'coinType': 2 },
                        },
                    });
                };
                huobi.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, currencies, i, currency, lowercase, account, available, frozen, loan;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.tradePostGetAccountInfo()];
                                case 1:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        account = this.account();
                                        available = 'available_' + lowercase + '_display';
                                        frozen = 'frozen_' + lowercase + '_display';
                                        loan = 'loan_' + lowercase + '_display';
                                        if (available in balances)
                                            account['free'] = parseFloat(balances[available]);
                                        if (frozen in balances)
                                            account['used'] = parseFloat(balances[frozen]);
                                        if (loan in balances)
                                            account['used'] = this.sum(account['used'], parseFloat(balances[loan]));
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                huobi.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    method = market['type'] + 'GetDepthId';
                                    return [4, this[method](this.extend({ 'id': market['id'] }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                huobi.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, response, ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    method = market['type'] + 'GetTickerId';
                                    return [4, this[method](this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    ticker = response['ticker'];
                                    timestamp = parseInt(response['time']) * 1000;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': this.safeFloat(ticker, 'high'),
                                            'low': this.safeFloat(ticker, 'low'),
                                            'bid': this.safeFloat(ticker, 'buy'),
                                            'ask': this.safeFloat(ticker, 'sell'),
                                            'vwap': undefined,
                                            'open': this.safeFloat(ticker, 'open'),
                                            'close': undefined,
                                            'first': undefined,
                                            'last': this.safeFloat(ticker, 'last'),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': undefined,
                                            'quoteVolume': this.safeFloat(ticker, 'vol'),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                huobi.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['ts'];
                    return {
                        'info': trade,
                        'id': trade['id'].toString(),
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['direction'],
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                huobi.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    method = market['type'] + 'GetDetailId';
                                    return [4, this[method](this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['trades'], market, since, limit)];
                            }
                        });
                    });
                };
                huobi.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv[0],
                        ohlcv[1],
                        ohlcv[2],
                        ohlcv[3],
                        ohlcv[4],
                        ohlcv[6],
                    ];
                };
                huobi.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, ohlcvs;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    method = market['type'] + 'GetIdKlinePeriod';
                                    return [4, this[method](this.extend({
                                            'id': market['id'],
                                            'period': this.timeframes[timeframe],
                                        }, params))];
                                case 1:
                                    ohlcvs = _a.sent();
                                    return [2, ohlcvs];
                            }
                        });
                    });
                };
                huobi.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, order, response;
                        return __generator(this, function (_a) {
                            market = this.market(symbol);
                            method = 'tradePost' + this.capitalize(side);
                            order = {
                                'coin_type': market['coinType'],
                                'amount': amount,
                                'market': market['quote'].toLowerCase(),
                            };
                            if (type === 'limit')
                                order['price'] = price;
                            else
                                method += this.capitalize(type);
                            response = this[method](this.extend(order, params));
                            return [2, {
                                    'info': response,
                                    'id': response['id'],
                                }];
                        });
                    });
                };
                huobi.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.tradePostCancelOrder({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                huobi.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'];
                    if (api === 'trade') {
                        this.checkRequiredCredentials();
                        url += '/api' + this.version;
                        var query = this.keysort(this.extend({
                            'method': path,
                            'access_key': this.apiKey,
                            'created': this.nonce(),
                        }, params));
                        var queryString = this.urlencode(this.omit(query, 'market'));
                        queryString += '&secret_key=' + this.secret;
                        query['sign'] = this.hash(this.encode(queryString));
                        body = this.urlencode(query);
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    else {
                        url += '/' + api + '/' + this.implodeParams(path, params) + '_json.js';
                        var query = this.omit(params, this.extractParams(path));
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                huobi.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'trade'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('status' in response)
                                        if (response['status'] === 'error')
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    if ('code' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return huobi;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 81: [function (require, module, exports) {
            'use strict';
            var huobipro = require('./huobipro.js');
            module.exports = (function (_super) {
                __extends(huobicny, _super);
                function huobicny() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                huobicny.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'huobicny',
                        'name': 'Huobi CNY',
                        'hostname': 'be.huobi.com',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
                            'api': 'https://be.huobi.com',
                            'www': 'https://www.huobi.com',
                            'doc': 'https://github.com/huobiapi/API_Docs/wiki/REST_api_reference',
                        },
                    });
                };
                return huobicny;
            }(huobipro));
        }, { "./huobipro.js": 82 }], 82: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(huobipro, _super);
                function huobipro() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                huobipro.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'huobipro',
                        'name': 'Huobi Pro',
                        'countries': 'CN',
                        'rateLimit': 2000,
                        'userAgent': this.userAgents['chrome39'],
                        'version': 'v1',
                        'accounts': undefined,
                        'accountsById': undefined,
                        'hostname': 'api.huobi.pro',
                        'has': {
                            'CORS': false,
                            'fetchOHCLV': true,
                            'fetchOrders': true,
                            'fetchOrder': true,
                            'fetchOpenOrders': true,
                            'fetchDepositAddress': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1m': '1min',
                            '5m': '5min',
                            '15m': '15min',
                            '30m': '30min',
                            '1h': '60min',
                            '1d': '1day',
                            '1w': '1week',
                            '1M': '1mon',
                            '1y': '1year',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
                            'api': 'https://api.huobi.pro',
                            'www': 'https://www.huobi.pro',
                            'doc': 'https://github.com/huobiapi/API_Docs/wiki/REST_api_reference',
                            'fees': 'https://www.huobi.pro/about/fee/',
                        },
                        'api': {
                            'market': {
                                'get': [
                                    'history/kline',
                                    'detail/merged',
                                    'depth',
                                    'trade',
                                    'history/trade',
                                    'detail',
                                ],
                            },
                            'public': {
                                'get': [
                                    'common/symbols',
                                    'common/currencys',
                                    'common/timestamp',
                                ],
                            },
                            'private': {
                                'get': [
                                    'account/accounts',
                                    'account/accounts/{id}/balance',
                                    'order/orders/{id}',
                                    'order/orders/{id}/matchresults',
                                    'order/orders',
                                    'order/matchresults',
                                    'dw/withdraw-virtual/addresses',
                                    'dw/deposit-virtual/addresses',
                                ],
                                'post': [
                                    'order/orders/place',
                                    'order/orders',
                                    'order/orders/{id}/place',
                                    'order/orders/{id}/submitcancel',
                                    'order/orders/batchcancel',
                                    'dw/balance/transfer',
                                    'dw/withdraw/api/create',
                                    'dw/withdraw-virtual/create',
                                    'dw/withdraw-virtual/{id}/place',
                                    'dw/withdraw-virtual/{id}/cancel',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'maker': 0.002,
                                'taker': 0.002,
                            },
                        },
                    });
                };
                huobipro.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, numMarkets, result, i, market, baseId, quoteId, base, quote, id, symbol, precision, lot, maker, taker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetCommonSymbols()];
                                case 1:
                                    response = _a.sent();
                                    markets = response['data'];
                                    numMarkets = markets.length;
                                    if (numMarkets < 1)
                                        throw new ExchangeError(this.id + ' publicGetCommonSymbols returned empty response: ' + this.json(response));
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        baseId = market['base-currency'];
                                        quoteId = market['quote-currency'];
                                        base = baseId.toUpperCase();
                                        quote = quoteId.toUpperCase();
                                        id = baseId + quoteId;
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': market['amount-precision'],
                                            'price': market['price-precision'],
                                        };
                                        lot = Math.pow(10, -precision['amount']);
                                        maker = (base === 'OMG') ? 0 : 0.2 / 100;
                                        taker = (base === 'OMG') ? 0 : 0.2 / 100;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'lot': lot,
                                            'precision': precision,
                                            'taker': taker,
                                            'maker': maker,
                                            'limits': {
                                                'amount': {
                                                    'min': lot,
                                                    'max': Math.pow(10, precision['amount']),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision['price']),
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': 0,
                                                    'max': undefined,
                                                },
                                            },
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                huobipro.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = this.milliseconds();
                    if ('ts' in ticker)
                        timestamp = ticker['ts'];
                    var bid = undefined;
                    var ask = undefined;
                    var bidVolume = undefined;
                    var askVolume = undefined;
                    if ('bid' in ticker) {
                        if (Array.isArray(ticker['bid'])) {
                            bid = this.safeFloat(ticker['bid'], 0);
                            bidVolume = this.safeFloat(ticker['bid'], 1);
                        }
                    }
                    if ('ask' in ticker) {
                        if (Array.isArray(ticker['ask'])) {
                            ask = this.safeFloat(ticker['ask'], 0);
                            askVolume = this.safeFloat(ticker['ask'], 1);
                        }
                    }
                    var open = this.safeFloat(ticker, 'open');
                    var close = this.safeFloat(ticker, 'close');
                    var change = undefined;
                    var percentage = undefined;
                    var average = undefined;
                    if ((typeof open !== 'undefined') && (typeof close !== 'undefined')) {
                        change = close - open;
                        average = this.sum(open, close) / 2;
                        if ((typeof close !== 'undefined') && (close > 0))
                            percentage = (change / open) * 100;
                    }
                    var baseVolume = this.safeFloat(ticker, 'amount');
                    var quoteVolume = this.safeFloat(ticker, 'vol');
                    var vwap = undefined;
                    if (typeof baseVolume !== 'undefined' && typeof quoteVolume !== 'undefined' && baseVolume > 0)
                        vwap = quoteVolume / baseVolume;
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': ticker['high'],
                        'low': ticker['low'],
                        'bid': bid,
                        'bidVolume': bidVolume,
                        'ask': ask,
                        'askVolume': askVolume,
                        'vwap': vwap,
                        'open': open,
                        'close': close,
                        'last': close,
                        'change': change,
                        'percentage': percentage,
                        'average': average,
                        'baseVolume': baseVolume,
                        'quoteVolume': quoteVolume,
                        'info': ticker,
                    };
                };
                huobipro.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.marketGetDepth(this.extend({
                                            'symbol': market['id'],
                                            'type': 'step0',
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    if ('tick' in response) {
                                        if (!response['tick']) {
                                            throw new ExchangeError(this.id + ' fetchOrderBook() returned empty response: ' + this.json(response));
                                        }
                                        return [2, this.parseOrderBook(response['tick'], response['tick']['ts'])];
                                    }
                                    throw new ExchangeError(this.id + ' fetchOrderBook() returned unrecognized response: ' + this.json(response));
                            }
                        });
                    });
                };
                huobipro.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.marketGetDetailMerged(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTicker(response['tick'], market)];
                            }
                        });
                    });
                };
                huobipro.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['ts'];
                    return {
                        'info': trade,
                        'id': trade['id'].toString(),
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['direction'],
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                huobipro.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, data, result, i, trades, j, trade;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.marketGetHistoryTrade(this.extend({
                                            'symbol': market['id'],
                                            'size': 2000,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    data = response['data'];
                                    result = [];
                                    for (i = 0; i < data.length; i++) {
                                        trades = data[i]['data'];
                                        for (j = 0; j < trades.length; j++) {
                                            trade = this.parseTrade(trades[j], market);
                                            result.push(trade);
                                        }
                                    }
                                    result = this.sortBy(result, 'timestamp');
                                    return [2, this.filterBySymbolSinceLimit(result, symbol, since, limit)];
                            }
                        });
                    });
                };
                huobipro.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv['id'] * 1000,
                        ohlcv['open'],
                        ohlcv['high'],
                        ohlcv['low'],
                        ohlcv['close'],
                        ohlcv['amount'],
                    ];
                };
                huobipro.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.marketGetHistoryKline(this.extend({
                                            'symbol': market['id'],
                                            'period': this.timeframes[timeframe],
                                            'size': 2000,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response['data'], market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                huobipro.prototype.loadAccounts = function (reload) {
                    if (reload === void 0) { reload = false; }
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, _c;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    if (!reload) return [3, 2];
                                    _a = this;
                                    return [4, this.fetchAccounts()];
                                case 1:
                                    _a.accounts = _d.sent();
                                    return [3, 5];
                                case 2:
                                    if (!this.accounts) return [3, 3];
                                    return [2, this.accounts];
                                case 3:
                                    _c = this;
                                    return [4, this.fetchAccounts()];
                                case 4:
                                    _c.accounts = _d.sent();
                                    this.accountsById = this.indexBy(this.accounts, 'id');
                                    _d.label = 5;
                                case 5: return [2, this.accounts];
                            }
                        });
                    });
                };
                huobipro.prototype.fetchAccounts = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetAccountAccounts()];
                                case 2:
                                    response = _a.sent();
                                    return [2, response['data']];
                            }
                        });
                    });
                };
                huobipro.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, i, balance, uppercase, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.loadAccounts()];
                                case 2:
                                    _a.sent();
                                    return [4, this.privateGetAccountAccountsIdBalance(this.extend({
                                            'id': this.accounts[0]['id'],
                                        }, params))];
                                case 3:
                                    response = _a.sent();
                                    balances = response['data']['list'];
                                    result = { 'info': response };
                                    for (i = 0; i < balances.length; i++) {
                                        balance = balances[i];
                                        uppercase = balance['currency'].toUpperCase();
                                        currency = this.commonCurrencyCode(uppercase);
                                        account = undefined;
                                        if (currency in result)
                                            account = result[currency];
                                        else
                                            account = this.account();
                                        if (balance['type'] === 'trade')
                                            account['free'] = parseFloat(balance['balance']);
                                        if (balance['type'] === 'frozen')
                                            account['used'] = parseFloat(balance['balance']);
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                huobipro.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, status, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOrders() requires a symbol parameter');
                                    this.loadMarkets();
                                    market = this.market(symbol);
                                    status = undefined;
                                    if ('type' in params) {
                                        status = params['type'];
                                    }
                                    else if ('status' in params) {
                                        status = params['status'];
                                    }
                                    else {
                                        throw new ExchangeError(this.id + ' fetchOrders() requires a type param or status param for spot market ' + symbol + ' (0 or "open" for unfilled or partial filled orders, 1 or "closed" for filled orders)');
                                    }
                                    if ((status === 0) || (status === 'open')) {
                                        status = 'submitted,partial-filled';
                                    }
                                    else if ((status === 1) || (status === 'closed')) {
                                        status = 'filled,partial-canceled';
                                    }
                                    else {
                                        throw new ExchangeError(this.id + ' fetchOrders() wrong type param or status param for spot market ' + symbol + ' (0 or "open" for unfilled or partial filled orders, 1 or "closed" for filled orders)');
                                    }
                                    return [4, this.privateGetOrderOrders(this.extend({
                                            'symbol': market['id'],
                                            'states': status,
                                        }))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response['data'], market, since, limit)];
                            }
                        });
                    });
                };
                huobipro.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var open;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    open = 0;
                                    return [4, this.fetchOrders(symbol, undefined, undefined, this.extend({
                                            'status': open,
                                        }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                huobipro.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetOrderOrdersId(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response['data'])];
                            }
                        });
                    });
                };
                huobipro.prototype.parseOrderStatus = function (status) {
                    if (status === 'partial-filled') {
                        return 'open';
                    }
                    else if (status === 'filled') {
                        return 'closed';
                    }
                    else if (status === 'canceled') {
                        return 'canceled';
                    }
                    else if (status === 'submitted') {
                        return 'open';
                    }
                    return status;
                };
                huobipro.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = undefined;
                    var type = undefined;
                    var status = undefined;
                    if ('type' in order) {
                        var orderType = order['type'].split('-');
                        side = orderType[0];
                        type = orderType[1];
                        status = this.parseOrderStatus(order['state']);
                    }
                    var symbol = undefined;
                    if (!market) {
                        if ('symbol' in order) {
                            if (order['symbol'] in this.markets_by_id) {
                                var marketId = order['symbol'];
                                market = this.markets_by_id[marketId];
                            }
                        }
                    }
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = order['created-at'];
                    var amount = parseFloat(order['amount']);
                    var filled = parseFloat(order['field-amount']);
                    var remaining = amount - filled;
                    var price = parseFloat(order['price']);
                    var cost = parseFloat(order['field-cash-amount']);
                    var average = 0;
                    if (filled)
                        average = parseFloat(cost / filled);
                    var result = {
                        'info': order,
                        'id': order['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'average': average,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': undefined,
                    };
                    return result;
                };
                huobipro.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.loadAccounts()];
                                case 2:
                                    _a.sent();
                                    market = this.market(symbol);
                                    order = {
                                        'account-id': this.accounts[0]['id'],
                                        'amount': this.amountToPrecision(symbol, amount),
                                        'symbol': market['id'],
                                        'type': side + '-' + type,
                                    };
                                    if (type === 'limit')
                                        order['price'] = this.priceToPrecision(symbol, price);
                                    return [4, this.privatePostOrderOrdersPlace(this.extend(order, params))];
                                case 3:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['data'],
                                        }];
                            }
                        });
                    });
                };
                huobipro.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostOrderOrdersIdSubmitcancel({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                huobipro.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privateGetDwDepositVirtualAddresses(this.extend({
                                            'currency': currency['id'].toLowerCase(),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    address = this.safeString(response, 'data');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': code,
                                            'status': 'ok',
                                            'address': address,
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                huobipro.prototype.calculateFee = function (symbol, type, side, amount, price, takerOrMaker, params) {
                    if (takerOrMaker === void 0) { takerOrMaker = 'taker'; }
                    if (params === void 0) { params = {}; }
                    var market = this.markets[symbol];
                    var rate = market[takerOrMaker];
                    var cost = parseFloat(this.costToPrecision(symbol, amount * rate));
                    var key = 'quote';
                    if (side === 'sell') {
                        cost *= price;
                    }
                    else {
                        key = 'base';
                    }
                    return {
                        'type': takerOrMaker,
                        'currency': market[key],
                        'rate': rate,
                        'cost': parseFloat(this.feeToPrecision(symbol, cost)),
                    };
                };
                huobipro.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    request = {
                                        'address': address,
                                        'amount': amount,
                                        'currency': currency.toLowerCase(),
                                    };
                                    if (tag)
                                        request['addr-tag'] = tag;
                                    return [4, this.privatePostDwWithdrawApiCreate(this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    id = undefined;
                                    if ('data' in response) {
                                        id = response['data'];
                                    }
                                    return [2, {
                                            'info': response,
                                            'id': id,
                                        }];
                            }
                        });
                    });
                };
                huobipro.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = '/';
                    if (api === 'market')
                        url += api;
                    else
                        url += this.version;
                    url += '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var timestamp = this.ymdhms(this.milliseconds(), 'T');
                        var request = this.keysort(this.extend({
                            'SignatureMethod': 'HmacSHA256',
                            'SignatureVersion': '2',
                            'AccessKeyId': this.apiKey,
                            'Timestamp': timestamp,
                        }, query));
                        var auth = this.urlencode(request);
                        var payload = [method, this.hostname, url, auth].join("\n");
                        var signature = this.hmac(this.encode(payload), this.encode(this.secret), 'sha256', 'base64');
                        auth += '&' + this.urlencode({ 'Signature': signature });
                        url += '?' + auth;
                        if (method === 'POST') {
                            body = this.json(query);
                            headers = {
                                'Content-Type': 'application/json',
                            };
                        }
                        else {
                            headers = {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            };
                        }
                    }
                    else {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    url = this.urls['api'] + url;
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                huobipro.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('status' in response)
                                        if (response['status'] === 'error')
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return huobipro;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 83: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            module.exports = (function (_super) {
                __extends(independentreserve, _super);
                function independentreserve() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                independentreserve.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'independentreserve',
                        'name': 'Independent Reserve',
                        'countries': ['AU', 'NZ'],
                        'rateLimit': 1000,
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/30521662-cf3f477c-9bcb-11e7-89bc-d1ac85012eda.jpg',
                            'api': {
                                'public': 'https://api.independentreserve.com/Public',
                                'private': 'https://api.independentreserve.com/Private',
                            },
                            'www': 'https://www.independentreserve.com',
                            'doc': 'https://www.independentreserve.com/API',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'GetValidPrimaryCurrencyCodes',
                                    'GetValidSecondaryCurrencyCodes',
                                    'GetValidLimitOrderTypes',
                                    'GetValidMarketOrderTypes',
                                    'GetValidOrderTypes',
                                    'GetValidTransactionTypes',
                                    'GetMarketSummary',
                                    'GetOrderBook',
                                    'GetTradeHistorySummary',
                                    'GetRecentTrades',
                                    'GetFxRates',
                                ],
                            },
                            'private': {
                                'post': [
                                    'PlaceLimitOrder',
                                    'PlaceMarketOrder',
                                    'CancelOrder',
                                    'GetOpenOrders',
                                    'GetClosedOrders',
                                    'GetClosedFilledOrders',
                                    'GetOrderDetails',
                                    'GetAccounts',
                                    'GetTransactions',
                                    'GetDigitalCurrencyDepositAddress',
                                    'GetDigitalCurrencyDepositAddresses',
                                    'SynchDigitalCurrencyDepositAddressWithBlockchain',
                                    'WithdrawDigitalCurrency',
                                    'RequestFiatWithdrawal',
                                    'GetTrades',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'taker': 0.5 / 100,
                                'maker': 0.5 / 100,
                                'percentage': true,
                                'tierBased': false,
                            },
                        },
                    });
                };
                independentreserve.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var baseCurrencies, quoteCurrencies, result, i, baseId, baseIdUppercase, base, j, quoteId, quoteIdUppercase, quote, id, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetGetValidPrimaryCurrencyCodes()];
                                case 1:
                                    baseCurrencies = _a.sent();
                                    return [4, this.publicGetGetValidSecondaryCurrencyCodes()];
                                case 2:
                                    quoteCurrencies = _a.sent();
                                    result = [];
                                    for (i = 0; i < baseCurrencies.length; i++) {
                                        baseId = baseCurrencies[i];
                                        baseIdUppercase = baseId.toUpperCase();
                                        base = this.commonCurrencyCode(baseIdUppercase);
                                        for (j = 0; j < quoteCurrencies.length; j++) {
                                            quoteId = quoteCurrencies[j];
                                            quoteIdUppercase = quoteId.toUpperCase();
                                            quote = this.commonCurrencyCode(quoteIdUppercase);
                                            id = baseId + '/' + quoteId;
                                            symbol = base + '/' + quote;
                                            result.push({
                                                'id': id,
                                                'symbol': symbol,
                                                'base': base,
                                                'quote': quote,
                                                'baseId': baseId,
                                                'quoteId': quoteId,
                                                'info': id,
                                            });
                                        }
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                independentreserve.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, i, balance, currencyCode, uppercase, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetAccounts()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (i = 0; i < balances.length; i++) {
                                        balance = balances[i];
                                        currencyCode = balance['CurrencyCode'];
                                        uppercase = currencyCode.toUpperCase();
                                        currency = this.commonCurrencyCode(uppercase);
                                        account = this.account();
                                        account['free'] = balance['AvailableBalance'];
                                        account['total'] = balance['TotalBalance'];
                                        account['used'] = account['total'] - account['free'];
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                independentreserve.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetGetOrderBook(this.extend({
                                            'primaryCurrencyCode': market['baseId'],
                                            'secondaryCurrencyCode': market['quoteId'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    timestamp = this.parse8601(response['CreatedTimestampUtc']);
                                    return [2, this.parseOrderBook(response, timestamp, 'BuyOrders', 'SellOrders', 'Price', 'Volume')];
                            }
                        });
                    });
                };
                independentreserve.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(ticker['CreatedTimestampUtc']);
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': ticker['DayHighestPrice'],
                        'low': ticker['DayLowestPrice'],
                        'bid': ticker['CurrentHighestBidPrice'],
                        'ask': ticker['CurrentLowestOfferPrice'],
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': ticker['LastPrice'],
                        'change': undefined,
                        'percentage': undefined,
                        'average': ticker['DayAvgPrice'],
                        'baseVolume': ticker['DayVolumeXbtInSecondaryCurrrency'],
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                independentreserve.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetGetMarketSummary(this.extend({
                                            'primaryCurrencyCode': market['baseId'],
                                            'secondaryCurrencyCode': market['quoteId'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTicker(response, market)];
                            }
                        });
                    });
                };
                independentreserve.prototype.parseTrade = function (trade, market) {
                    var timestamp = this.parse8601(trade['TradeTimestampUtc']);
                    return {
                        'id': undefined,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'order': undefined,
                        'type': undefined,
                        'side': undefined,
                        'price': trade['SecondaryCurrencyTradePrice'],
                        'amount': trade['PrimaryCurrencyAmount'],
                    };
                };
                independentreserve.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetGetRecentTrades(this.extend({
                                            'primaryCurrencyCode': market['baseId'],
                                            'secondaryCurrencyCode': market['quoteId'],
                                            'numberOfRecentTradesToRetrieve': 50,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['Trades'], market, since, limit)];
                            }
                        });
                    });
                };
                independentreserve.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, capitalizedOrderType, method, orderType, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    capitalizedOrderType = this.capitalize(type);
                                    method = 'privatePostPlace' + capitalizedOrderType + 'Order';
                                    orderType = capitalizedOrderType;
                                    orderType += (side === 'sell') ? 'Offer' : 'Bid';
                                    order = this.ordered({
                                        'primaryCurrencyCode': market['baseId'],
                                        'secondaryCurrencyCode': market['quoteId'],
                                        'orderType': orderType,
                                    });
                                    if (type === 'limit')
                                        order['price'] = price;
                                    order['volume'] = amount;
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['OrderGuid'],
                                        }];
                            }
                        });
                    });
                };
                independentreserve.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCancelOrder({ 'orderGuid': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                independentreserve.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api] + '/' + path;
                    if (api === 'public') {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var auth = [
                            url,
                            'apiKey=' + this.apiKey,
                            'nonce=' + nonce.toString(),
                        ];
                        var keysorted = this.keysort(params);
                        var keys = Object.keys(keysorted);
                        for (var i = 0; i < keys.length; i++) {
                            var key = keys[i];
                            auth.push(key + '=' + params[key]);
                        }
                        var message = auth.join(',');
                        var signature = this.hmac(this.encode(message), this.encode(this.secret));
                        var query = this.keysort(this.extend({
                            'apiKey': this.apiKey,
                            'nonce': nonce,
                            'signature': signature,
                        }, params));
                        body = this.json(query);
                        headers = { 'Content-Type': 'application/json' };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                independentreserve.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                return independentreserve;
            }(Exchange));
        }, { "./base/Exchange": 8 }], 84: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(itbit, _super);
                function itbit() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                itbit.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'itbit',
                        'name': 'itBit',
                        'countries': 'US',
                        'rateLimit': 2000,
                        'version': 'v1',
                        'has': {
                            'CORS': true,
                            'createMarketOrder': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg',
                            'api': 'https://api.itbit.com',
                            'www': 'https://www.itbit.com',
                            'doc': [
                                'https://api.itbit.com/docs',
                                'https://www.itbit.com/api',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'markets/{symbol}/ticker',
                                    'markets/{symbol}/order_book',
                                    'markets/{symbol}/trades',
                                ],
                            },
                            'private': {
                                'get': [
                                    'wallets',
                                    'wallets/{walletId}',
                                    'wallets/{walletId}/balances/{currencyCode}',
                                    'wallets/{walletId}/funding_history',
                                    'wallets/{walletId}/trades',
                                    'wallets/{walletId}/orders/{id}',
                                ],
                                'post': [
                                    'wallet_transfers',
                                    'wallets',
                                    'wallets/{walletId}/cryptocurrency_deposits',
                                    'wallets/{walletId}/cryptocurrency_withdrawals',
                                    'wallets/{walletId}/orders',
                                    'wire_withdrawal',
                                ],
                                'delete': [
                                    'wallets/{walletId}/orders/{id}',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/USD': { 'id': 'XBTUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                            'BTC/SGD': { 'id': 'XBTSGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
                            'BTC/EUR': { 'id': 'XBTEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0,
                                'taker': 0.2 / 100,
                            },
                        },
                    });
                };
                itbit.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarketsSymbolOrderBook(this.extend({
                                        'symbol': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                itbit.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, serverTimeUTC, timestamp, vwap, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarketsSymbolTicker(this.extend({
                                        'symbol': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    serverTimeUTC = ('serverTimeUTC' in ticker);
                                    if (!serverTimeUTC)
                                        throw new ExchangeError(this.id + ' fetchTicker returned a bad response: ' + this.json(ticker));
                                    timestamp = this.parse8601(ticker['serverTimeUTC']);
                                    vwap = parseFloat(ticker['vwap24h']);
                                    baseVolume = parseFloat(ticker['volume24h']);
                                    quoteVolume = baseVolume * vwap;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high24h']),
                                            'low': parseFloat(ticker['low24h']),
                                            'bid': this.safeFloat(ticker, 'bid'),
                                            'ask': this.safeFloat(ticker, 'ask'),
                                            'vwap': vwap,
                                            'open': parseFloat(ticker['openToday']),
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['lastPrice']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                itbit.prototype.parseTrade = function (trade, market) {
                    var timestamp = this.parse8601(trade['timestamp']);
                    var id = trade['matchNumber'].toString();
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'id': id,
                        'order': id,
                        'type': undefined,
                        'side': undefined,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                itbit.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketsSymbolTrades(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['recentTrades'], market, since, limit)];
                            }
                        });
                    });
                };
                itbit.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetBalances()];
                                case 1:
                                    response = _a.sent();
                                    balances = response['balances'];
                                    result = { 'info': response };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        account = {
                                            'free': parseFloat(balance['availableBalance']),
                                            'used': 0.0,
                                            'total': parseFloat(balance['totalBalance']),
                                        };
                                        account['used'] = account['total'] - account['free'];
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                itbit.prototype.fetchWallets = function () {
                    return this.privateGetWallets();
                };
                itbit.prototype.nonce = function () {
                    return this.milliseconds();
                };
                itbit.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var walletIdInParams, market, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    walletIdInParams = ('walletId' in params);
                                    if (!walletIdInParams)
                                        throw new ExchangeError(this.id + ' createOrder requires a walletId parameter');
                                    amount = amount.toString();
                                    price = price.toString();
                                    market = this.market(symbol);
                                    order = {
                                        'side': side,
                                        'type': type,
                                        'currency': market['base'],
                                        'amount': amount,
                                        'display': amount,
                                        'price': price,
                                        'instrument': market['id'],
                                    };
                                    return [4, this.privatePostTradeAdd(this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                itbit.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var walletIdInParams;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    walletIdInParams = ('walletId' in params);
                                    if (!walletIdInParams)
                                        throw new ExchangeError(this.id + ' cancelOrder requires a walletId parameter');
                                    return [4, this.privateDeleteWalletsWalletIdOrdersId(this.extend({
                                            'id': id,
                                        }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                itbit.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        if (Object.keys(query).length)
                            body = this.json(query);
                        else
                            body = '';
                        var nonce = this.nonce().toString();
                        var timestamp = nonce;
                        var auth = [method, url, body, nonce, timestamp];
                        var message = nonce + this.json(auth);
                        var hash = this.hash(this.encode(message), 'sha256', 'binary');
                        var binhash = this.binaryConcat(url, hash);
                        var signature = this.hmac(binhash, this.encode(this.secret), 'sha512', 'base64');
                        headers = {
                            'Authorization': this.apiKey + ':' + signature,
                            'Content-Type': 'application/json',
                            'X-Auth-Timestamp': timestamp,
                            'X-Auth-Nonce': nonce,
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                itbit.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('code' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return itbit;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 85: [function (require, module, exports) {
            'use strict';
            var btcbox = require('./btcbox.js');
            module.exports = (function (_super) {
                __extends(jubi, _super);
                function jubi() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                jubi.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'jubi',
                        'name': 'jubi.com',
                        'countries': 'CN',
                        'rateLimit': 1500,
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766581-9d397d9a-5edd-11e7-8fb9-5d8236c0e692.jpg',
                            'api': 'https://www.jubi.com/api',
                            'www': 'https://www.jubi.com',
                            'doc': 'https://www.jubi.com/help/api.html',
                        },
                    });
                };
                jubi.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, keys, result, p, id, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetAllticker()];
                                case 1:
                                    markets = _a.sent();
                                    keys = Object.keys(markets);
                                    result = [];
                                    for (p = 0; p < keys.length; p++) {
                                        id = keys[p];
                                        base = id.toUpperCase();
                                        quote = 'CNY';
                                        symbol = base + '/' + quote;
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': id,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                return jubi;
            }(btcbox));
        }, { "./btcbox.js": 42 }], 86: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeNotAvailable = _a.ExchangeNotAvailable, ExchangeError = _a.ExchangeError, OrderNotFound = _a.OrderNotFound, DDoSProtection = _a.DDoSProtection, InvalidNonce = _a.InvalidNonce, InsufficientFunds = _a.InsufficientFunds, CancelPending = _a.CancelPending, InvalidOrder = _a.InvalidOrder, InvalidAddress = _a.InvalidAddress;
            module.exports = (function (_super) {
                __extends(kraken, _super);
                function kraken() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                kraken.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'kraken',
                        'name': 'Kraken',
                        'countries': 'US',
                        'version': '0',
                        'rateLimit': 3000,
                        'has': {
                            'createDepositAddress': true,
                            'fetchDepositAddress': true,
                            'CORS': false,
                            'fetchCurrencies': true,
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                            'fetchOrder': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'fetchMyTrades': true,
                            'withdraw': true,
                        },
                        'marketsByAltname': {},
                        'timeframes': {
                            '1m': '1',
                            '5m': '5',
                            '15m': '15',
                            '30m': '30',
                            '1h': '60',
                            '4h': '240',
                            '1d': '1440',
                            '1w': '10080',
                            '2w': '21600',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766599-22709304-5ede-11e7-9de1-9f33732e1509.jpg',
                            'api': {
                                'public': 'https://api.kraken.com',
                                'private': 'https://api.kraken.com',
                                'zendesk': 'https://kraken.zendesk.com/hc/en-us/articles',
                            },
                            'www': 'https://www.kraken.com',
                            'doc': [
                                'https://www.kraken.com/en-us/help/api',
                                'https://github.com/nothingisdead/npm-kraken-api',
                            ],
                            'fees': 'https://www.kraken.com/en-us/help/fees',
                        },
                        'fees': {
                            'trading': {
                                'tierBased': true,
                                'percentage': true,
                                'taker': 0.26 / 100,
                                'maker': 0.16 / 100,
                                'tiers': {
                                    'taker': [
                                        [0, 0.0026],
                                        [50000, 0.0024],
                                        [100000, 0.0022],
                                        [250000, 0.0020],
                                        [500000, 0.0018],
                                        [1000000, 0.0016],
                                        [2500000, 0.0014],
                                        [5000000, 0.0012],
                                        [10000000, 0.0001],
                                    ],
                                    'maker': [
                                        [0, 0.0016],
                                        [50000, 0.0014],
                                        [100000, 0.0012],
                                        [250000, 0.0010],
                                        [500000, 0.0008],
                                        [1000000, 0.0006],
                                        [2500000, 0.0004],
                                        [5000000, 0.0002],
                                        [10000000, 0.0],
                                    ],
                                },
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0.001,
                                    'ETH': 0.005,
                                    'XRP': 0.02,
                                    'XLM': 0.00002,
                                    'LTC': 0.02,
                                    'DOGE': 2,
                                    'ZEC': 0.00010,
                                    'ICN': 0.02,
                                    'REP': 0.01,
                                    'ETC': 0.005,
                                    'MLN': 0.003,
                                    'XMR': 0.05,
                                    'DASH': 0.005,
                                    'GNO': 0.01,
                                    'EOS': 0.5,
                                    'BCH': 0.001,
                                    'USD': 5,
                                    'EUR': 5,
                                    'CAD': 10,
                                    'JPY': 300,
                                },
                                'deposit': {
                                    'BTC': 0,
                                    'ETH': 0,
                                    'XRP': 0,
                                    'XLM': 0,
                                    'LTC': 0,
                                    'DOGE': 0,
                                    'ZEC': 0,
                                    'ICN': 0,
                                    'REP': 0,
                                    'ETC': 0,
                                    'MLN': 0,
                                    'XMR': 0,
                                    'DASH': 0,
                                    'GNO': 0,
                                    'EOS': 0,
                                    'BCH': 0,
                                    'USD': 5,
                                    'EUR': 0,
                                    'CAD': 5,
                                    'JPY': 0,
                                },
                            },
                        },
                        'api': {
                            'zendesk': {
                                'get': [
                                    '205893708-What-is-the-minimum-order-size-',
                                    '201396777-What-are-the-deposit-fees-',
                                    '201893608-What-are-the-withdrawal-fees-',
                                ],
                            },
                            'public': {
                                'get': [
                                    'Assets',
                                    'AssetPairs',
                                    'Depth',
                                    'OHLC',
                                    'Spread',
                                    'Ticker',
                                    'Time',
                                    'Trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    'AddOrder',
                                    'Balance',
                                    'CancelOrder',
                                    'ClosedOrders',
                                    'DepositAddresses',
                                    'DepositMethods',
                                    'DepositStatus',
                                    'Ledgers',
                                    'OpenOrders',
                                    'OpenPositions',
                                    'QueryLedgers',
                                    'QueryOrders',
                                    'QueryTrades',
                                    'TradeBalance',
                                    'TradesHistory',
                                    'TradeVolume',
                                    'Withdraw',
                                    'WithdrawCancel',
                                    'WithdrawInfo',
                                    'WithdrawStatus',
                                ],
                            },
                        },
                    });
                };
                kraken.prototype.costToPrecision = function (symbol, cost) {
                    return this.truncate(parseFloat(cost), this.markets[symbol]['precision']['price']);
                };
                kraken.prototype.feeToPrecision = function (symbol, fee) {
                    return this.truncate(parseFloat(fee), this.markets[symbol]['precision']['amount']);
                };
                kraken.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (body.indexOf('Invalid order') >= 0)
                        throw new InvalidOrder(this.id + ' ' + body);
                    if (body.indexOf('Invalid nonce') >= 0)
                        throw new InvalidNonce(this.id + ' ' + body);
                    if (body.indexOf('Insufficient funds') >= 0)
                        throw new InsufficientFunds(this.id + ' ' + body);
                    if (body.indexOf('Cancel pending') >= 0)
                        throw new CancelPending(this.id + ' ' + body);
                    if (body.indexOf('Invalid arguments:volume') >= 0)
                        throw new InvalidOrder(this.id + ' ' + body);
                };
                kraken.prototype.fetchMinOrderSizes = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var html, e_19, parts, ul, listItems, result, separator, l, listItem, chunks, numChunks, limit, name_2, currency;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    html = undefined;
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, 3, , 4]);
                                    this.parseJsonResponse = false;
                                    return [4, this.zendeskGet205893708WhatIsTheMinimumOrderSize()];
                                case 2:
                                    html = _a.sent();
                                    this.parseJsonResponse = true;
                                    return [3, 4];
                                case 3:
                                    e_19 = _a.sent();
                                    this.parseJsonResponse = true;
                                    throw e_19;
                                case 4:
                                    parts = html.split('ul>');
                                    ul = parts[1];
                                    listItems = ul.split('</li');
                                    result = {};
                                    separator = '):' + ' ';
                                    for (l = 0; l < listItems.length; l++) {
                                        listItem = listItems[l];
                                        chunks = listItem.split(separator);
                                        numChunks = chunks.length;
                                        if (numChunks > 1) {
                                            limit = parseFloat(chunks[1]);
                                            name_2 = chunks[0];
                                            chunks = name_2.split('(');
                                            currency = chunks[1];
                                            result[currency] = limit;
                                        }
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                kraken.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, limits, keys, result, i, id, market, base, quote, darkpool, symbol, maker, precision, lot, minAmount;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetAssetPairs()];
                                case 1:
                                    markets = _a.sent();
                                    return [4, this.fetchMinOrderSizes()];
                                case 2:
                                    limits = _a.sent();
                                    keys = Object.keys(markets['result']);
                                    result = [];
                                    for (i = 0; i < keys.length; i++) {
                                        id = keys[i];
                                        market = markets['result'][id];
                                        base = market['base'];
                                        quote = market['quote'];
                                        if ((base[0] === 'X') || (base[0] === 'Z'))
                                            base = base.slice(1);
                                        if ((quote[0] === 'X') || (quote[0] === 'Z'))
                                            quote = quote.slice(1);
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        darkpool = id.indexOf('.d') >= 0;
                                        symbol = darkpool ? market['altname'] : (base + '/' + quote);
                                        maker = undefined;
                                        if ('fees_maker' in market) {
                                            maker = parseFloat(market['fees_maker'][0][1]) / 100;
                                        }
                                        precision = {
                                            'amount': market['lot_decimals'],
                                            'price': market['pair_decimals'],
                                        };
                                        lot = Math.pow(10, -precision['amount']);
                                        minAmount = lot;
                                        if (base in limits)
                                            minAmount = limits[base];
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'darkpool': darkpool,
                                            'info': market,
                                            'altname': market['altname'],
                                            'maker': maker,
                                            'taker': parseFloat(market['fees'][0][1]) / 100,
                                            'lot': lot,
                                            'active': true,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': minAmount,
                                                    'max': Math.pow(10, precision['amount']),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision['price']),
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': 0,
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                    }
                                    result = this.appendInactiveMarkets(result);
                                    this.marketsByAltname = this.indexBy(result, 'altname');
                                    return [2, result];
                            }
                        });
                    });
                };
                kraken.prototype.appendInactiveMarkets = function (result) {
                    if (result === void 0) { result = []; }
                    var precision = { 'amount': 8, 'price': 8 };
                    var costLimits = { 'min': 0, 'max': undefined };
                    var priceLimits = { 'min': Math.pow(10, -precision['price']), 'max': undefined };
                    var amountLimits = { 'min': Math.pow(10, -precision['amount']), 'max': Math.pow(10, precision['amount']) };
                    var limits = { 'amount': amountLimits, 'price': priceLimits, 'cost': costLimits };
                    var defaults = {
                        'darkpool': false,
                        'info': undefined,
                        'maker': undefined,
                        'taker': undefined,
                        'lot': amountLimits['min'],
                        'active': false,
                        'precision': precision,
                        'limits': limits,
                    };
                    var markets = [];
                    for (var i = 0; i < markets.length; i++) {
                        result.push(this.extend(defaults, markets[i]));
                    }
                    return result;
                };
                kraken.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, currencies, ids, result, i, id, currency, code, precision;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetAssets(params)];
                                case 1:
                                    response = _a.sent();
                                    currencies = response['result'];
                                    ids = Object.keys(currencies);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        currency = currencies[id];
                                        code = this.commonCurrencyCode(currency['altname']);
                                        precision = currency['decimals'];
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'info': currency,
                                            'name': code,
                                            'active': true,
                                            'status': 'ok',
                                            'fee': undefined,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': undefined,
                                                    'max': Math.pow(10, precision),
                                                },
                                            },
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                kraken.prototype.fetchTradingFees = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tradedVolume, tiers, taker, maker, i, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    this.checkRequiredCredentials();
                                    return [4, this.privatePostTradeVolume(params)];
                                case 2:
                                    response = _a.sent();
                                    tradedVolume = this.safeFloat(response['result'], 'volume');
                                    tiers = this.fees['trading']['tiers'];
                                    taker = tiers['taker'][1];
                                    maker = tiers['maker'][1];
                                    for (i = 0; i < tiers['taker'].length; i++) {
                                        if (tradedVolume >= tiers['taker'][i][0])
                                            taker = tiers['taker'][i][1];
                                    }
                                    for (i = 0; i < tiers['maker'].length; i++) {
                                        if (tradedVolume >= tiers['maker'][i][0])
                                            maker = tiers['maker'][i][1];
                                    }
                                    return [2, {
                                            'info': response,
                                            'maker': maker,
                                            'taker': taker,
                                        }];
                            }
                        });
                    });
                };
                kraken.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    if (market['darkpool'])
                                        throw new ExchangeError(this.id + ' does not provide an order book for darkpool symbol ' + symbol);
                                    request = {
                                        'pair': market['id'],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['count'] = limit;
                                    return [4, this.publicGetDepth(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['result'][market['id']];
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                kraken.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var baseVolume = parseFloat(ticker['v'][1]);
                    var vwap = parseFloat(ticker['p'][1]);
                    var quoteVolume = baseVolume * vwap;
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['h'][1]),
                        'low': parseFloat(ticker['l'][1]),
                        'bid': parseFloat(ticker['b'][0]),
                        'ask': parseFloat(ticker['a'][0]),
                        'vwap': vwap,
                        'open': parseFloat(ticker['o']),
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['c'][0]),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': baseVolume,
                        'quoteVolume': quoteVolume,
                        'info': ticker,
                    };
                };
                kraken.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var pairs, s, symbol, market, filter, response, tickers, ids, result, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    pairs = [];
                                    for (s = 0; s < this.symbols.length; s++) {
                                        symbol = this.symbols[s];
                                        market = this.markets[symbol];
                                        if (market['active'])
                                            if (!market['darkpool'])
                                                pairs.push(market['id']);
                                    }
                                    filter = pairs.join(',');
                                    return [4, this.publicGetTicker(this.extend({
                                            'pair': filter,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    tickers = response['result'];
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                kraken.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var darkpool, market, response, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    darkpool = symbol.indexOf('.d') >= 0;
                                    if (darkpool)
                                        throw new ExchangeError(this.id + ' does not provide a ticker for darkpool symbol ' + symbol);
                                    market = this.market(symbol);
                                    return [4, this.publicGetTicker(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['result'][market['id']];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                kraken.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv[0] * 1000,
                        parseFloat(ohlcv[1]),
                        parseFloat(ohlcv[2]),
                        parseFloat(ohlcv[3]),
                        parseFloat(ohlcv[4]),
                        parseFloat(ohlcv[6]),
                    ];
                };
                kraken.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, ohlcvs;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'pair': market['id'],
                                        'interval': this.timeframes[timeframe],
                                    };
                                    if (typeof since !== 'undefined')
                                        request['since'] = parseInt(since / 1000);
                                    return [4, this.publicGetOHLC(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    ohlcvs = response['result'][market['id']];
                                    return [2, this.parseOHLCVs(ohlcvs, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                kraken.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = undefined;
                    var side = undefined;
                    var type = undefined;
                    var price = undefined;
                    var amount = undefined;
                    var id = undefined;
                    var order = undefined;
                    var fee = undefined;
                    if (!market)
                        market = this.findMarketByAltnameOrId(trade['pair']);
                    if ('ordertxid' in trade) {
                        order = trade['ordertxid'];
                        id = trade['id'];
                        timestamp = parseInt(trade['time'] * 1000);
                        side = trade['type'];
                        type = trade['ordertype'];
                        price = parseFloat(trade['price']);
                        amount = parseFloat(trade['vol']);
                        if ('fee' in trade) {
                            var currency = undefined;
                            if (market)
                                currency = market['quote'];
                            fee = {
                                'cost': parseFloat(trade['fee']),
                                'currency': currency,
                            };
                        }
                    }
                    else {
                        timestamp = parseInt(trade[2] * 1000);
                        side = (trade[3] === 's') ? 'sell' : 'buy';
                        type = (trade[4] === 'l') ? 'limit' : 'market';
                        price = parseFloat(trade[0]);
                        amount = parseFloat(trade[1]);
                        var tradeLength = trade.length;
                        if (tradeLength > 6)
                            id = trade[6];
                    }
                    var symbol = (market) ? market['symbol'] : undefined;
                    return {
                        'id': id,
                        'order': order,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'fee': fee,
                    };
                };
                kraken.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, id, response, result, trades, length, lastTrade, lastTradeId;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    id = market['id'];
                                    return [4, this.publicGetTrades(this.extend({
                                            'pair': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    result = response['result'];
                                    trades = result[id];
                                    length = trades.length;
                                    if (length <= 0)
                                        return [2, []];
                                    lastTrade = trades[length - 1];
                                    lastTradeId = this.safeString(result, 'last');
                                    lastTrade.push(lastTradeId);
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                kraken.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, currencies, c, currency, code, balance, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostBalance()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['result'];
                                    result = { 'info': balances };
                                    currencies = Object.keys(balances);
                                    for (c = 0; c < currencies.length; c++) {
                                        currency = currencies[c];
                                        code = currency;
                                        if (code[0] === 'X') {
                                            code = code.slice(1);
                                        }
                                        else if (code[0] === 'Z') {
                                            code = code.slice(1);
                                        }
                                        code = this.commonCurrencyCode(code);
                                        balance = parseFloat(balances[currency]);
                                        account = {
                                            'free': balance,
                                            'used': 0.0,
                                            'total': balance,
                                        };
                                        result[code] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                kraken.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, order, response, id, length_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    order = {
                                        'pair': market['id'],
                                        'type': side,
                                        'ordertype': type,
                                        'volume': this.amountToPrecision(symbol, amount),
                                    };
                                    if (type === 'limit')
                                        order['price'] = this.priceToPrecision(symbol, price);
                                    return [4, this.privatePostAddOrder(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    id = this.safeValue(response['result'], 'txid');
                                    if (typeof id !== 'undefined') {
                                        if (Array.isArray(id)) {
                                            length_1 = id.length;
                                            id = (length_1 > 1) ? id : id[0];
                                        }
                                    }
                                    return [2, {
                                            'info': response,
                                            'id': id,
                                        }];
                            }
                        });
                    });
                };
                kraken.prototype.findMarketByAltnameOrId = function (id) {
                    if (id in this.marketsByAltname) {
                        return this.marketsByAltname[id];
                    }
                    else if (id in this.markets_by_id) {
                        return this.markets_by_id[id];
                    }
                    return undefined;
                };
                kraken.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var description = order['descr'];
                    var side = description['type'];
                    var type = description['ordertype'];
                    var symbol = undefined;
                    if (!market)
                        market = this.findMarketByAltnameOrId(description['pair']);
                    var timestamp = parseInt(order['opentm'] * 1000);
                    var amount = parseFloat(order['vol']);
                    var filled = parseFloat(order['vol_exec']);
                    var remaining = amount - filled;
                    var fee = undefined;
                    var cost = this.safeFloat(order, 'cost');
                    var price = this.safeFloat(description, 'price');
                    if (!price)
                        price = this.safeFloat(order, 'price');
                    if (market) {
                        symbol = market['symbol'];
                        if ('fee' in order) {
                            var flags = order['oflags'];
                            var feeCost = this.safeFloat(order, 'fee');
                            fee = {
                                'cost': feeCost,
                                'rate': undefined,
                            };
                            if (flags.indexOf('fciq') >= 0) {
                                fee['currency'] = market['quote'];
                            }
                            else if (flags.indexOf('fcib') >= 0) {
                                fee['currency'] = market['base'];
                            }
                        }
                    }
                    return {
                        'id': order['id'],
                        'info': order,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': order['status'],
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'fee': fee,
                    };
                };
                kraken.prototype.parseOrders = function (orders, market, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var result = [];
                    var ids = Object.keys(orders);
                    for (var i = 0; i < ids.length; i++) {
                        var id = ids[i];
                        var order = this.extend({ 'id': id }, orders[id]);
                        result.push(this.parseOrder(order, market));
                    }
                    return this.filterBySinceLimit(result, since, limit);
                };
                kraken.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orders, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostQueryOrders(this.extend({
                                            'trades': true,
                                            'txid': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = response['result'];
                                    order = this.parseOrder(this.extend({ 'id': id }, orders[id]));
                                    return [2, this.extend({ 'info': response }, order)];
                            }
                        });
                    });
                };
                kraken.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, trades, ids, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    if (typeof since !== 'undefined')
                                        request['start'] = parseInt(since / 1000);
                                    return [4, this.privatePostTradesHistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    trades = response['result']['trades'];
                                    ids = Object.keys(trades);
                                    for (i = 0; i < ids.length; i++) {
                                        trades[ids[i]]['id'] = ids[i];
                                    }
                                    return [2, this.parseTrades(trades, undefined, since, limit)];
                            }
                        });
                    });
                };
                kraken.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, e_20;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    response = undefined;
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 4, , 5]);
                                    return [4, this.privatePostCancelOrder(this.extend({
                                            'txid': id,
                                        }, params))];
                                case 3:
                                    response = _a.sent();
                                    return [3, 5];
                                case 4:
                                    e_20 = _a.sent();
                                    if (this.last_http_response)
                                        if (this.last_http_response.indexOf('EOrder:Unknown order') >= 0)
                                            throw new OrderNotFound(this.id + ' cancelOrder() error ' + this.last_http_response);
                                    throw e_20;
                                case 5: return [2, response];
                            }
                        });
                    });
                };
                kraken.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    if (typeof since !== 'undefined')
                                        request['start'] = parseInt(since / 1000);
                                    return [4, this.privatePostOpenOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response['result']['open'], undefined, since, limit);
                                    return [2, this.filterBySymbol(orders, symbol)];
                            }
                        });
                    });
                };
                kraken.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    if (typeof since !== 'undefined')
                                        request['start'] = parseInt(since / 1000);
                                    return [4, this.privatePostClosedOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.parseOrders(response['result']['closed'], undefined, since, limit);
                                    return [2, this.filterBySymbol(orders, symbol)];
                            }
                        });
                    });
                };
                kraken.prototype.fetchDepositMethods = function (code, params) {
                    if (code === void 0) { code = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, currency, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    if (code) {
                                        currency = this.currency(code);
                                        request['asset'] = currency['id'];
                                    }
                                    return [4, this.privatePostDepositMethods(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, response['result']];
                            }
                        });
                    });
                };
                kraken.prototype.createDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    request = {
                                        'new': 'true',
                                    };
                                    return [4, this.fetchDepositAddress(currency, this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    address = this.safeString(response, 'address');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                kraken.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, currency, request, response, result, numResults, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    method = this.safeValue(params, 'method');
                                    if (!method)
                                        throw new ExchangeError(this.id + ' fetchDepositAddress() requires an extra `method` parameter');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    request = {
                                        'asset': currency['id'],
                                        'method': method,
                                    };
                                    return [4, this.privatePostDepositAddresses(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    result = response['result'];
                                    numResults = result.length;
                                    if (numResults < 1)
                                        throw new InvalidAddress(this.id + ' privatePostDepositAddresses() returned no addresses');
                                    address = this.safeString(result[0], 'address');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': code,
                                            'address': address,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                kraken.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    if (!('key' in params)) return [3, 3];
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostWithdraw(this.extend({
                                            'asset': currency,
                                            'amount': amount,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['result'],
                                        }];
                                case 3: throw new ExchangeError(this.id + " withdraw requires a 'key' parameter (withdrawal key name, as set up on your account)");
                            }
                        });
                    });
                };
                kraken.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = '/' + this.version + '/' + api + '/' + path;
                    if (api === 'public') {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        body = this.urlencode(this.extend({ 'nonce': nonce }, params));
                        var auth = this.encode(nonce + body);
                        var hash = this.hash(auth, 'sha256', 'binary');
                        var binary = this.stringToBinary(this.encode(url));
                        var binhash = this.binaryConcat(binary, hash);
                        var secret = this.base64ToBinary(this.secret);
                        var signature = this.hmac(binhash, secret, 'sha512', 'base64');
                        headers = {
                            'API-Key': this.apiKey,
                            'API-Sign': this.decode(signature),
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    else {
                        url = '/' + path;
                    }
                    url = this.urls['api'][api] + url;
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                kraken.prototype.nonce = function () {
                    return this.milliseconds();
                };
                kraken.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, numErrors, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (typeof response !== 'string')
                                        if ('error' in response) {
                                            numErrors = response['error'].length;
                                            if (numErrors) {
                                                for (i = 0; i < response['error'].length; i++) {
                                                    if (response['error'][i] === 'EService:Unavailable')
                                                        throw new ExchangeNotAvailable(this.id + ' ' + this.json(response));
                                                    if (response['error'][i] === 'EDatabase:Internal error')
                                                        throw new ExchangeNotAvailable(this.id + ' ' + this.json(response));
                                                    if (response['error'][i] === 'EService:Busy')
                                                        throw new DDoSProtection(this.id + ' ' + this.json(response));
                                                }
                                                throw new ExchangeError(this.id + ' ' + this.json(response));
                                            }
                                        }
                                    return [2, response];
                            }
                        });
                    });
                };
                return kraken;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 87: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InvalidNonce = _a.InvalidNonce, InvalidOrder = _a.InvalidOrder, AuthenticationError = _a.AuthenticationError, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound;
            module.exports = (function (_super) {
                __extends(kucoin, _super);
                function kucoin() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                kucoin.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'kucoin',
                        'name': 'Kucoin',
                        'countries': 'HK',
                        'version': 'v1',
                        'rateLimit': 2000,
                        'userAgent': this.userAgents['chrome'],
                        'has': {
                            'CORS': false,
                            'cancelOrders': true,
                            'createMarketOrder': false,
                            'fetchDepositAddress': true,
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                            'fetchOrder': true,
                            'fetchOrders': false,
                            'fetchClosedOrders': true,
                            'fetchOpenOrders': true,
                            'fetchMyTrades': true,
                            'fetchCurrencies': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1m': 1,
                            '5m': 5,
                            '15m': 15,
                            '30m': 30,
                            '1h': 60,
                            '8h': 480,
                            '1d': 'D',
                            '1w': 'W',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/33795655-b3c46e48-dcf6-11e7-8abe-dc4588ba7901.jpg',
                            'api': {
                                'public': 'https://api.kucoin.com',
                                'private': 'https://api.kucoin.com',
                                'kitchen': 'https://kitchen.kucoin.com',
                                'kitchen-2': 'https://kitchen-2.kucoin.com',
                            },
                            'www': 'https://kucoin.com',
                            'doc': 'https://kucoinapidocs.docs.apiary.io',
                            'fees': 'https://news.kucoin.com/en/fee',
                        },
                        'api': {
                            'kitchen': {
                                'get': [
                                    'open/chart/history',
                                ],
                            },
                            'public': {
                                'get': [
                                    'open/chart/config',
                                    'open/chart/history',
                                    'open/chart/symbol',
                                    'open/currencies',
                                    'open/deal-orders',
                                    'open/kline',
                                    'open/lang-list',
                                    'open/orders',
                                    'open/orders-buy',
                                    'open/orders-sell',
                                    'open/tick',
                                    'market/open/coin-info',
                                    'market/open/coins',
                                    'market/open/coins-trending',
                                    'market/open/symbols',
                                ],
                            },
                            'private': {
                                'get': [
                                    'account/balance',
                                    'account/{coin}/wallet/address',
                                    'account/{coin}/wallet/records',
                                    'account/{coin}/balance',
                                    'account/promotion/info',
                                    'account/promotion/sum',
                                    'deal-orders',
                                    'order/active',
                                    'order/active-map',
                                    'order/dealt',
                                    'order/detail',
                                    'referrer/descendant/count',
                                    'user/info',
                                ],
                                'post': [
                                    'account/{coin}/withdraw/apply',
                                    'account/{coin}/withdraw/cancel',
                                    'account/promotion/draw',
                                    'cancel-order',
                                    'order',
                                    'order/cancel-all',
                                    'user/change-lang',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.001,
                                'taker': 0.001,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'KCS': 2.0,
                                    'BTC': 0.0005,
                                    'USDT': 10.0,
                                    'ETH': 0.01,
                                    'LTC': 0.001,
                                    'NEO': 0.0,
                                    'GAS': 0.0,
                                    'KNC': 0.5,
                                    'BTM': 5.0,
                                    'QTUM': 0.1,
                                    'EOS': 0.5,
                                    'CVC': 3.0,
                                    'OMG': 0.1,
                                    'PAY': 0.5,
                                    'SNT': 20.0,
                                    'BHC': 1.0,
                                    'HSR': 0.01,
                                    'WTC': 0.1,
                                    'VEN': 2.0,
                                    'MTH': 10.0,
                                    'RPX': 1.0,
                                    'REQ': 20.0,
                                    'EVX': 0.5,
                                    'MOD': 0.5,
                                    'NEBL': 0.1,
                                    'DGB': 0.5,
                                    'CAG': 2.0,
                                    'CFD': 0.5,
                                    'RDN': 0.5,
                                    'UKG': 5.0,
                                    'BCPT': 5.0,
                                    'PPT': 0.1,
                                    'BCH': 0.0005,
                                    'STX': 2.0,
                                    'NULS': 1.0,
                                    'GVT': 0.1,
                                    'HST': 2.0,
                                    'PURA': 0.5,
                                    'SUB': 2.0,
                                    'QSP': 5.0,
                                    'POWR': 1.0,
                                    'FLIXX': 10.0,
                                    'LEND': 20.0,
                                    'AMB': 3.0,
                                    'RHOC': 2.0,
                                    'R': 2.0,
                                    'DENT': 50.0,
                                    'DRGN': 1.0,
                                    'ACT': 0.1,
                                },
                                'deposit': {},
                            },
                        },
                        'options': {
                            'timeDifference': 0,
                            'adjustForTimeDifference': false,
                        },
                    });
                };
                kucoin.prototype.nonce = function () {
                    return this.milliseconds() - this.options['timeDifference'];
                };
                kucoin.prototype.loadTimeDifference = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, after;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetOpenTick()];
                                case 1:
                                    response = _a.sent();
                                    after = this.milliseconds();
                                    this.options['timeDifference'] = parseInt(after - response['timestamp']);
                                    return [2, this.options['timeDifference']];
                            }
                        });
                    });
                };
                kucoin.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, i, market, id, base, quote, symbol, precision, active;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarketOpenSymbols()];
                                case 1:
                                    response = _a.sent();
                                    if (!this.options['adjustForTimeDifference']) return [3, 3];
                                    return [4, this.loadTimeDifference()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    markets = response['data'];
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        id = market['symbol'];
                                        base = market['coinType'];
                                        quote = market['coinTypePair'];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': 8,
                                            'price': 8,
                                        };
                                        active = market['trading'];
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'active': active,
                                            'taker': this.safeFloat(market, 'feeRate'),
                                            'maker': this.safeFloat(market, 'feeRate'),
                                            'info': market,
                                            'lot': Math.pow(10, -precision['amount']),
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision['amount']),
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                kucoin.prototype.fetchDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, data, address, tag;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privateGetAccountCoinWalletAddress(this.extend({
                                            'coin': currency['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    data = response['data'];
                                    address = this.safeString(data, 'address');
                                    this.checkAddress(address);
                                    tag = this.safeString(data, 'userOid');
                                    return [2, {
                                            'currency': code,
                                            'address': address,
                                            'tag': tag,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                kucoin.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, currencies, result, i, currency, id, code, precision, deposit, withdraw, active;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarketOpenCoins(params)];
                                case 1:
                                    response = _a.sent();
                                    currencies = response['data'];
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['coin'];
                                        code = this.commonCurrencyCode(id);
                                        precision = currency['tradePrecision'];
                                        deposit = currency['enableDeposit'];
                                        withdraw = currency['enableWithdraw'];
                                        active = (deposit && withdraw);
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'info': currency,
                                            'name': currency['name'],
                                            'active': active,
                                            'status': 'ok',
                                            'fee': currency['withdrawMinFee'],
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': currency['withdrawMinAmount'],
                                                    'max': Math.pow(10, precision),
                                                },
                                            },
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                kucoin.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, indexed, keys, i, id, currency, account, balance, used, free, total;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetAccountBalance(this.extend({
                                            'limit': 20,
                                            'page': 1,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    balances = response['data'];
                                    result = { 'info': balances };
                                    indexed = this.indexBy(balances, 'coinType');
                                    keys = Object.keys(indexed);
                                    for (i = 0; i < keys.length; i++) {
                                        id = keys[i];
                                        currency = this.commonCurrencyCode(id);
                                        account = this.account();
                                        balance = indexed[id];
                                        used = parseFloat(balance['freezeBalance']);
                                        free = parseFloat(balance['balance']);
                                        total = this.sum(free, used);
                                        account['free'] = free;
                                        account['used'] = used;
                                        account['total'] = total;
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                kucoin.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetOpenOrders(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['data'];
                                    return [2, this.parseOrderBook(orderbook, undefined, 'BUY', 'SELL')];
                            }
                        });
                    });
                };
                kucoin.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    else {
                        symbol = order['coinType'] + '/' + order['coinTypePair'];
                    }
                    var timestamp = this.safeValue(order, 'createdAt');
                    var price = this.safeFloat(order, 'price');
                    if (typeof price === 'undefined')
                        price = this.safeFloat(order, 'dealPrice');
                    if (typeof price === 'undefined')
                        price = this.safeFloat(order, 'dealPriceAverage');
                    if (typeof price === 'undefined')
                        price = this.safeFloat(order, 'orderPrice');
                    var remaining = this.safeFloat(order, 'pendingAmount');
                    var status = this.safeValue(order, 'status');
                    var filled = this.safeFloat(order, 'dealAmount');
                    if (typeof status === 'undefined') {
                        if (typeof remaining !== 'undefined')
                            if (remaining > 0)
                                status = 'open';
                            else
                                status = 'closed';
                    }
                    if (typeof filled === 'undefined') {
                        if (typeof status !== 'undefined')
                            if (status === 'closed')
                                filled = this.safeFloat(order, 'amount');
                    }
                    var amount = this.safeFloat(order, 'amount');
                    var cost = this.safeFloat(order, 'dealValue');
                    if (typeof cost === 'undefined')
                        cost = this.safeFloat(order, 'dealValueTotal');
                    if (typeof filled !== 'undefined') {
                        if (typeof price !== 'undefined') {
                            if (typeof cost === 'undefined')
                                cost = price * filled;
                        }
                        if (typeof amount === 'undefined') {
                            if (typeof remaining !== 'undefined')
                                amount = this.sum(filled, remaining);
                        }
                        else if (typeof remaining === 'undefined') {
                            remaining = amount - filled;
                        }
                    }
                    if ((status === 'open') && (typeof cost === 'undefined'))
                        cost = price * amount;
                    var side = this.safeValue(order, 'direction');
                    if (typeof side === 'undefined')
                        side = order['type'];
                    if (typeof side !== 'undefined')
                        side = side.toLowerCase();
                    var feeCurrency = undefined;
                    if (market) {
                        feeCurrency = (side === 'sell') ? market['quote'] : market['base'];
                    }
                    else {
                        var feeCurrencyField = (side === 'sell') ? 'coinTypePair' : 'coinType';
                        var feeCurrency_1 = this.safeString(order, feeCurrencyField);
                        if (typeof feeCurrency_1 !== 'undefined') {
                            if (feeCurrency_1 in this.currencies_by_id)
                                feeCurrency_1 = this.currencies_by_id[feeCurrency_1]['code'];
                        }
                    }
                    var feeCost = this.safeFloat(order, 'fee');
                    var fee = {
                        'cost': this.safeFloat(order, 'feeTotal', feeCost),
                        'rate': this.safeFloat(order, 'feeRate'),
                        'currency': feeCurrency,
                    };
                    var orderId = this.safeString(order, 'orderOid');
                    if (typeof orderId === 'undefined')
                        orderId = this.safeString(order, 'oid');
                    var result = {
                        'info': order,
                        'id': orderId,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': 'limit',
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': fee,
                    };
                    return result;
                };
                kucoin.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderType, market, request, response, order, orderId;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof symbol === 'undefined')
                                        throw new ExchangeError(this.id + ' fetchOrder requires a symbol argument');
                                    orderType = this.safeValue(params, 'type');
                                    if (typeof orderType === 'undefined')
                                        throw new ExchangeError(this.id + ' fetchOrder requires a type parameter ("BUY" or "SELL")');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'type': orderType,
                                        'orderOid': id,
                                    };
                                    return [4, this.privateGetOrderDetail(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    if (!response['data'])
                                        throw new OrderNotFound(this.id + ' ' + this.json(response));
                                    order = this.parseOrder(response['data'], market);
                                    orderId = order['id'];
                                    if (orderId in this.orders)
                                        order['status'] = this.orders[orderId]['status'];
                                    this.orders[orderId] = order;
                                    return [2, order];
                            }
                        });
                    });
                };
                kucoin.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, orders, i, order, orderId, openOrders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOpenOrders requires a symbol');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    return [4, this.privateGetOrderActiveMap(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = this.arrayConcat(response['data']['SELL'], response['data']['BUY']);
                                    for (i = 0; i < orders.length; i++) {
                                        order = this.parseOrder(this.extend(orders[i], {
                                            'status': 'open',
                                        }), market);
                                        orderId = order['id'];
                                        if (orderId in this.orders)
                                            if (this.orders[orderId]['status'] !== 'open')
                                                order['status'] = this.orders[orderId]['status'];
                                        this.orders[order['id']] = order;
                                    }
                                    openOrders = this.filterBy(this.orders, 'status', 'open');
                                    return [2, this.filterBySymbolSinceLimit(openOrders, symbol, since, limit)];
                            }
                        });
                    });
                };
                kucoin.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response, orders, i, order, orderId, closedOrders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    request = {};
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (typeof symbol !== 'undefined') {
                                        market = this.market(symbol);
                                        request['symbol'] = market['id'];
                                    }
                                    if (typeof since !== 'undefined')
                                        request['since'] = since;
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.privateGetOrderDealt(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orders = response['data']['datas'];
                                    for (i = 0; i < orders.length; i++) {
                                        order = this.parseOrder(this.extend(orders[i], {
                                            'status': 'closed',
                                        }), market);
                                        orderId = order['id'];
                                        if (orderId in this.orders)
                                            if (this.orders[orderId]['status'] === 'canceled')
                                                order['status'] = this.orders[orderId]['status'];
                                        this.orders[order['id']] = order;
                                    }
                                    closedOrders = this.filterBy(this.orders, 'status', 'closed');
                                    return [2, this.filterBySymbolSinceLimit(closedOrders, symbol, since, limit)];
                            }
                        });
                    });
                };
                kucoin.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, base, request, cost, response, orderId, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type !== 'limit')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    base = market['base'];
                                    request = {
                                        'symbol': market['id'],
                                        'type': side.toUpperCase(),
                                        'price': this.priceToPrecision(symbol, price),
                                        'amount': this.truncate(amount, this.currencies[base]['precision']),
                                    };
                                    price = parseFloat(price);
                                    amount = parseFloat(amount);
                                    cost = price * amount;
                                    return [4, this.privatePostOrder(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orderId = this.safeString(response['data'], 'orderOid');
                                    order = {
                                        'info': response,
                                        'id': orderId,
                                        'timestamp': undefined,
                                        'datetime': undefined,
                                        'type': type,
                                        'side': side,
                                        'amount': amount,
                                        'filled': undefined,
                                        'remaining': undefined,
                                        'price': price,
                                        'cost': cost,
                                        'status': 'open',
                                        'fee': undefined,
                                        'trades': undefined,
                                    };
                                    this.orders[orderId] = order;
                                    return [2, order];
                            }
                        });
                    });
                };
                kucoin.prototype.cancelOrders = function (symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, response, openOrders, i, order, orderId;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    request = {};
                                    if (!symbol) return [3, 2];
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request['symbol'] = market['id'];
                                    _a.label = 2;
                                case 2:
                                    if ('type' in params) {
                                        request['type'] = params['type'].toUpperCase();
                                        params = this.omit(params, 'type');
                                    }
                                    return [4, this.privatePostOrderCancelAll(this.extend(request, params))];
                                case 3:
                                    response = _a.sent();
                                    openOrders = this.filterBy(this.orders, 'status', 'open');
                                    for (i = 0; i < openOrders.length; i++) {
                                        order = openOrders[i];
                                        orderId = order['id'];
                                        this.orders[orderId]['status'] = 'canceled';
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                kucoin.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, timestamp, side;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof symbol === 'undefined')
                                        throw new ExchangeError(this.id + ' cancelOrder requires a symbol');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'orderOid': id,
                                    };
                                    if ('type' in params) {
                                        request['type'] = params['type'].toUpperCase();
                                        params = this.omit(params, 'type');
                                    }
                                    else {
                                        throw new ExchangeError(this.id + ' cancelOrder requires parameter type=["BUY"|"SELL"]');
                                    }
                                    return [4, this.privatePostCancelOrder(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    if (id in this.orders) {
                                        this.orders[id]['status'] = 'canceled';
                                    }
                                    else {
                                        timestamp = this.milliseconds();
                                        side = request['type'].toLowerCase();
                                        this.orders[id] = {
                                            'id': id,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'type': undefined,
                                            'side': side,
                                            'symbol': symbol,
                                            'status': 'canceled',
                                        };
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                kucoin.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['datetime'];
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    else {
                        symbol = ticker['coinType'] + '/' + ticker['coinTypePair'];
                    }
                    var change = this.safeFloat(ticker, 'changeRate');
                    if (typeof change !== 'undefined')
                        change *= 100;
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high'),
                        'low': this.safeFloat(ticker, 'low'),
                        'bid': this.safeFloat(ticker, 'buy'),
                        'ask': this.safeFloat(ticker, 'sell'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'lastDealPrice'),
                        'change': change,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'vol'),
                        'quoteVolume': this.safeFloat(ticker, 'volValue'),
                        'info': ticker,
                    };
                };
                kucoin.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, result, t, ticker, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarketOpenSymbols(params)];
                                case 1:
                                    response = _a.sent();
                                    tickers = response['data'];
                                    result = {};
                                    for (t = 0; t < tickers.length; t++) {
                                        ticker = this.parseTicker(tickers[t]);
                                        symbol = ticker['symbol'];
                                        result[symbol] = ticker;
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                kucoin.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetOpenTick(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['data'];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                kucoin.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var id = undefined;
                    var order = undefined;
                    var info = trade;
                    var timestamp = undefined;
                    var type = undefined;
                    var side = undefined;
                    var price = undefined;
                    var cost = undefined;
                    var amount = undefined;
                    var fee = undefined;
                    if (Array.isArray(trade)) {
                        timestamp = trade[0];
                        type = 'limit';
                        if (trade[1] === 'BUY') {
                            side = 'buy';
                        }
                        else if (trade[1] === 'SELL') {
                            side = 'sell';
                        }
                        price = trade[2];
                        amount = trade[3];
                    }
                    else {
                        timestamp = this.safeValue(trade, 'createdAt');
                        order = this.safeString(trade, 'orderOid');
                        if (typeof order === 'undefined')
                            order = this.safeString(trade, 'oid');
                        side = trade['dealDirection'].toLowerCase();
                        price = this.safeFloat(trade, 'dealPrice');
                        amount = this.safeFloat(trade, 'amount');
                        cost = this.safeFloat(trade, 'dealValue');
                        var feeCurrency = undefined;
                        if ('coinType' in trade) {
                            feeCurrency = this.safeString(trade, 'coinType');
                            if (typeof feeCurrency !== 'undefined')
                                if (feeCurrency in this.currencies_by_id)
                                    feeCurrency = this.currencies_by_id[feeCurrency]['code'];
                        }
                        fee = {
                            'cost': this.safeFloat(trade, 'fee'),
                            'currency': feeCurrency,
                        };
                    }
                    var symbol = undefined;
                    if (typeof market !== 'undefined')
                        symbol = market['symbol'];
                    return {
                        'id': id,
                        'order': order,
                        'info': info,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'fee': fee,
                    };
                };
                kucoin.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetOpenDealOrders(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['data'], market, since, limit)];
                            }
                        });
                    });
                };
                kucoin.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchMyTrades requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (limit)
                                        request['limit'] = limit;
                                    return [4, this.privateGetDealOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['data']['datas'], market, since, limit)];
                            }
                        });
                    });
                };
                kucoin.prototype.parseTradingViewOHLCVs = function (ohlcvs, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var result = [];
                    for (var i = 0; i < ohlcvs['t'].length; i++) {
                        result.push([
                            ohlcvs['t'][i] * 1000,
                            ohlcvs['o'][i],
                            ohlcvs['h'][i],
                            ohlcvs['l'][i],
                            ohlcvs['c'][i],
                            ohlcvs['v'][i],
                        ]);
                    }
                    return this.parseOHLCVs(result, market, timeframe, since, limit);
                };
                kucoin.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, end, resolution, minutes, start, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    end = this.seconds();
                                    resolution = this.timeframes[timeframe];
                                    minutes = resolution;
                                    if (minutes === 'D') {
                                        if (typeof limit === 'undefined')
                                            limit = 30;
                                        minutes = 1440;
                                    }
                                    else if (minutes === 'W') {
                                        if (typeof limit === 'undefined')
                                            limit = 52;
                                        minutes = 10080;
                                    }
                                    else if (typeof limit === 'undefined') {
                                        limit = 1440;
                                    }
                                    start = end - limit * minutes * 60;
                                    if (typeof since !== 'undefined') {
                                        start = parseInt(since / 1000);
                                        end = Math.min(end, this.sum(start, limit * minutes * 60));
                                    }
                                    request = {
                                        'symbol': market['id'],
                                        'resolution': resolution,
                                        'from': start,
                                        'to': end,
                                    };
                                    return [4, this.publicGetOpenChartHistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTradingViewOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                kucoin.prototype.withdraw = function (code, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    this.checkAddress(address);
                                    return [4, this.privatePostAccountCoinWithdrawApply(this.extend({
                                            'coin': currency['id'],
                                            'amount': amount,
                                            'address': address,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                kucoin.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var endpoint = '/' + this.version + '/' + this.implodeParams(path, params);
                    var url = this.urls['api'][api] + endpoint;
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var queryString = '';
                        nonce = nonce.toString();
                        if (Object.keys(query).length) {
                            queryString = this.rawencode(this.keysort(query));
                            url += '?' + queryString;
                            if (method !== 'GET') {
                                body = queryString;
                            }
                        }
                        var auth = endpoint + '/' + nonce + '/' + queryString;
                        var payload = this.stringToBase64(this.encode(auth));
                        var signature = this.hmac(payload, this.encode(this.secret), 'sha256');
                        headers = {
                            'KC-API-KEY': this.apiKey,
                            'KC-API-NONCE': nonce,
                            'KC-API-SIGNATURE': signature,
                        };
                    }
                    else {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                kucoin.prototype.throwExceptionOnError = function (response) {
                    if (!('success' in response))
                        return;
                    if (response['success'] === true)
                        return;
                    if (!('code' in response) || !('msg' in response))
                        throw new ExchangeError(this.id + ': malformed response: ' + this.json(response));
                    var code = this.safeString(response, 'code');
                    var message = this.safeString(response, 'msg');
                    var feedback = this.id + ' ' + this.json(response);
                    if (code === 'UNAUTH') {
                        if (message === 'Invalid nonce')
                            throw new InvalidNonce(feedback);
                        throw new AuthenticationError(feedback);
                    }
                    else if (code === 'ERROR') {
                        if (message.indexOf('The precision of amount') >= 0)
                            throw new InvalidOrder(feedback);
                        if (message.indexOf('Min amount each order') >= 0)
                            throw new InvalidOrder(feedback);
                        if (message.indexOf('Min price:') >= 0)
                            throw new InvalidOrder(feedback);
                        if (message.indexOf('The precision of price') >= 0)
                            throw new InvalidOrder(feedback);
                    }
                    else if (code === 'NO_BALANCE') {
                        if (message.indexOf('Insufficient balance') >= 0)
                            throw new InsufficientFunds(feedback);
                    }
                    throw new ExchangeError(this.id + ': unknown response: ' + this.json(response));
                };
                kucoin.prototype.handleErrors = function (code, reason, url, method, headers, body, response) {
                    if (response === void 0) { response = undefined; }
                    if (typeof response !== 'undefined') {
                        this.throwExceptionOnError(response);
                    }
                    else if (body && (body[0] === '{')) {
                        this.throwExceptionOnError(JSON.parse(body));
                    }
                };
                return kucoin;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 88: [function (require, module, exports) {
            'use strict';
            var acx = require('./acx.js');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(kuna, _super);
                function kuna() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                kuna.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'kuna',
                        'name': 'Kuna',
                        'countries': 'UA',
                        'rateLimit': 1000,
                        'version': 'v2',
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                            'fetchOpenOrders': true,
                            'fetchMyTrades': true,
                            'withdraw': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/31697638-912824fa-b3c1-11e7-8c36-cf9606eb94ac.jpg',
                            'api': 'https://kuna.io',
                            'www': 'https://kuna.io',
                            'doc': 'https://kuna.io/documents/api',
                            'fees': 'https://kuna.io/documents/api',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'tickers',
                                    'tickers/{market}',
                                    'order_book',
                                    'order_book/{market}',
                                    'trades',
                                    'trades/{market}',
                                    'timestamp',
                                ],
                            },
                            'private': {
                                'get': [
                                    'members/me',
                                    'orders',
                                    'trades/my',
                                ],
                                'post': [
                                    'orders',
                                    'order/delete',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'taker': 0.25 / 100,
                                'maker': 0.25 / 100,
                            },
                            'funding': {
                                'withdraw': {
                                    'UAH': '1%',
                                    'BTC': 0.001,
                                    'BCH': 0.001,
                                    'ETH': 0.01,
                                    'WAVES': 0.01,
                                    'GOL': 0.0,
                                    'GBG': 0.0,
                                },
                                'deposit': {},
                            },
                        },
                    });
                };
                kuna.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var predefinedMarkets, markets, tickers, i, market, marketsById, ids, i, id, baseId, baseIdLength, quoteId, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    predefinedMarkets = [
                                        { 'id': 'btcuah', 'symbol': 'BTC/UAH', 'base': 'BTC', 'quote': 'UAH', 'baseId': 'btc', 'quoteId': 'uah', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }, 'cost': { 'min': 0.000001, 'max': undefined } } },
                                        { 'id': 'ethuah', 'symbol': 'ETH/UAH', 'base': 'ETH', 'quote': 'UAH', 'baseId': 'eth', 'quoteId': 'uah', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }, 'cost': { 'min': 0.000001, 'max': undefined } } },
                                        { 'id': 'gbguah', 'symbol': 'GBG/UAH', 'base': 'GBG', 'quote': 'UAH', 'baseId': 'gbg', 'quoteId': 'uah', 'precision': { 'amount': 3, 'price': 2 }, 'lot': 0.001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 0.01, 'max': undefined }, 'cost': { 'min': 0.000001, 'max': undefined } } },
                                        { 'id': 'kunbtc', 'symbol': 'KUN/BTC', 'base': 'KUN', 'quote': 'BTC', 'baseId': 'kun', 'quoteId': 'btc', 'precision': { 'amount': 6, 'price': 6 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 0.000001, 'max': undefined }, 'cost': { 'min': 0.000001, 'max': undefined } } },
                                        { 'id': 'bchbtc', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'baseId': 'bch', 'quoteId': 'btc', 'precision': { 'amount': 6, 'price': 6 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 0.000001, 'max': undefined }, 'cost': { 'min': 0.000001, 'max': undefined } } },
                                        { 'id': 'bchuah', 'symbol': 'BCH/UAH', 'base': 'BCH', 'quote': 'UAH', 'baseId': 'bch', 'quoteId': 'uah', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }, 'cost': { 'min': 0.000001, 'max': undefined } } },
                                        { 'id': 'wavesuah', 'symbol': 'WAVES/UAH', 'base': 'WAVES', 'quote': 'UAH', 'baseId': 'waves', 'quoteId': 'uah', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }, 'cost': { 'min': 0.000001, 'max': undefined } } },
                                        { 'id': 'arnbtc', 'symbol': 'ARN/BTC', 'base': 'ARN', 'quote': 'BTC', 'baseId': 'arn', 'quoteId': 'btc' },
                                        { 'id': 'b2bbtc', 'symbol': 'B2B/BTC', 'base': 'B2B', 'quote': 'BTC', 'baseId': 'b2b', 'quoteId': 'btc' },
                                        { 'id': 'evrbtc', 'symbol': 'EVR/BTC', 'base': 'EVR', 'quote': 'BTC', 'baseId': 'evr', 'quoteId': 'btc' },
                                        { 'id': 'golgbg', 'symbol': 'GOL/GBG', 'base': 'GOL', 'quote': 'GBG', 'baseId': 'gol', 'quoteId': 'gbg' },
                                        { 'id': 'rbtc', 'symbol': 'R/BTC', 'base': 'R', 'quote': 'BTC', 'baseId': 'r', 'quoteId': 'btc' },
                                        { 'id': 'rmcbtc', 'symbol': 'RMC/BTC', 'base': 'RMC', 'quote': 'BTC', 'baseId': 'rmc', 'quoteId': 'btc' },
                                    ];
                                    markets = [];
                                    return [4, this.publicGetTickers()];
                                case 1:
                                    tickers = _a.sent();
                                    for (i = 0; i < predefinedMarkets.length; i++) {
                                        market = predefinedMarkets[i];
                                        if (market['id'] in tickers)
                                            markets.push(market);
                                    }
                                    marketsById = this.indexBy(markets, 'id');
                                    ids = Object.keys(tickers);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        if (!(id in marketsById)) {
                                            baseId = id.replace('btc', '');
                                            baseId = baseId.replace('uah', '');
                                            baseId = baseId.replace('gbg', '');
                                            if (baseId.length > 0) {
                                                baseIdLength = baseId.length - 0;
                                                quoteId = id.slice(baseIdLength);
                                                base = baseId.toUpperCase();
                                                quote = quoteId.toUpperCase();
                                                base = this.commonCurrencyCode(base);
                                                quote = this.commonCurrencyCode(quote);
                                                symbol = base + '/' + quote;
                                                markets.push({
                                                    'id': id,
                                                    'symbol': symbol,
                                                    'base': base,
                                                    'quote': quote,
                                                    'baseId': baseId,
                                                    'quoteId': quoteId,
                                                });
                                            }
                                        }
                                    }
                                    return [2, markets];
                            }
                        });
                    });
                };
                kuna.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderBook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetOrderBook(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 1:
                                    orderBook = _a.sent();
                                    return [2, this.parseOrderBook(orderBook, undefined, 'bids', 'asks', 'price', 'remaining_volume')];
                            }
                        });
                    });
                };
                kuna.prototype.fetchL3OrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2, this.fetchOrderBook(symbol, limit, params)];
                        });
                    });
                };
                kuna.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOpenOrders requires a symbol argument');
                                    market = this.market(symbol);
                                    return [4, this.privateGetOrders(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.parseOrders(orders, market, since, limit)];
                            }
                        });
                    });
                };
                kuna.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(trade['created_at']);
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'id': trade['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': undefined,
                        'side': undefined,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['volume']),
                        'info': trade,
                    };
                };
                kuna.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrades(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                kuna.prototype.parseMyTrade = function (trade, market) {
                    var timestamp = this.parse8601(trade['created_at']);
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'id': trade['id'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'price': trade['price'],
                        'amount': trade['volume'],
                        'cost': trade['funds'],
                        'symbol': symbol,
                        'side': trade['side'],
                        'order': trade['order_id'],
                    };
                };
                kuna.prototype.parseMyTrades = function (trades, market) {
                    if (market === void 0) { market = undefined; }
                    var parsedTrades = [];
                    for (var i = 0; i < trades.length; i++) {
                        var trade = trades[i];
                        var parsedTrade = this.parseMyTrade(trade, market);
                        parsedTrades.push(parsedTrade);
                    }
                    return parsedTrades;
                };
                kuna.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOpenOrders requires a symbol argument');
                                    market = this.market(symbol);
                                    return [4, this.privateGetTradesMy({ 'market': market['id'] })];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseMyTrades(response, market)];
                            }
                        });
                    });
                };
                return kuna;
            }(acx));
        }, { "./acx.js": 5, "./base/errors": 10 }], 89: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(lakebtc, _super);
                function lakebtc() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                lakebtc.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'lakebtc',
                        'name': 'LakeBTC',
                        'countries': 'US',
                        'version': 'api_v2',
                        'has': {
                            'CORS': true,
                            'createMarketOrder': false,
                            'fetchTickers': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28074120-72b7c38a-6660-11e7-92d9-d9027502281d.jpg',
                            'api': 'https://api.lakebtc.com',
                            'www': 'https://www.lakebtc.com',
                            'doc': [
                                'https://www.lakebtc.com/s/api_v2',
                                'https://www.lakebtc.com/s/api',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'bcorderbook',
                                    'bctrades',
                                    'ticker',
                                ],
                            },
                            'private': {
                                'post': [
                                    'buyOrder',
                                    'cancelOrders',
                                    'getAccountInfo',
                                    'getExternalAccounts',
                                    'getOrders',
                                    'getTrades',
                                    'openOrders',
                                    'sellOrder',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.15 / 100,
                                'taker': 0.2 / 100,
                            },
                        },
                    });
                };
                lakebtc.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, keys, k, id, market, baseId, quoteId, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTicker()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    keys = Object.keys(markets);
                                    for (k = 0; k < keys.length; k++) {
                                        id = keys[k];
                                        market = markets[id];
                                        baseId = id.slice(0, 3);
                                        quoteId = id.slice(3, 6);
                                        base = baseId.toUpperCase();
                                        quote = quoteId.toUpperCase();
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                lakebtc.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, ids, i, id, code, currency, balance, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetAccountInfo()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['balance'];
                                    result = { 'info': response };
                                    ids = Object.keys(balances);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        code = id;
                                        if (id in this.currencies) {
                                            currency = this.currencies[id];
                                            code = currency['code'];
                                        }
                                        balance = parseFloat(balances[id]);
                                        account = {
                                            'free': balance,
                                            'used': 0.0,
                                            'total': balance,
                                        };
                                        result[code] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                lakebtc.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetBcorderbook(this.extend({
                                            'symbol': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                lakebtc.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (typeof market !== 'undefined')
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high'),
                        'low': this.safeFloat(ticker, 'low'),
                        'bid': this.safeFloat(ticker, 'bid'),
                        'ask': this.safeFloat(ticker, 'ask'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last'),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'volume'),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                lakebtc.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, ids, result, i, symbol, ticker, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        symbol = ids[i];
                                        ticker = tickers[symbol];
                                        market = undefined;
                                        if (symbol in this.markets_by_id) {
                                            market = this.markets_by_id[symbol];
                                            symbol = market['symbol'];
                                        }
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                lakebtc.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, tickers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTicker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    return [2, this.parseTicker(tickers[market['id']], market)];
                            }
                        });
                    });
                };
                lakebtc.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['date'] * 1000;
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'id': trade['tid'].toString(),
                        'order': undefined,
                        'type': undefined,
                        'side': undefined,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                lakebtc.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetBctrades(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                lakebtc.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, market, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    method = 'privatePost' + this.capitalize(side) + 'Order';
                                    market = this.market(symbol);
                                    order = {
                                        'params': [price, amount, market['id']],
                                    };
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                lakebtc.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCancelOrder({ 'params': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                lakebtc.prototype.nonce = function () {
                    return this.microseconds();
                };
                lakebtc.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version;
                    if (api === 'public') {
                        url += '/' + path;
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        if (Object.keys(params).length)
                            params = params.join(',');
                        else
                            params = '';
                        var query = this.urlencode({
                            'tonce': nonce,
                            'accesskey': this.apiKey,
                            'requestmethod': method.toLowerCase(),
                            'id': nonce,
                            'method': path,
                            'params': params,
                        });
                        body = this.json({
                            'method': path,
                            'params': params,
                            'id': nonce,
                        });
                        var signature = this.hmac(this.encode(query), this.encode(this.secret), 'sha1');
                        var auth = this.encode(this.apiKey + ':' + signature);
                        headers = {
                            'Json-Rpc-Tonce': nonce.toString(),
                            'Authorization': 'Basic ' + this.decode(this.stringToBase64(auth)),
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                lakebtc.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('error' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return lakebtc;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 90: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound, DDoSProtection = _a.DDoSProtection, InvalidOrder = _a.InvalidOrder, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(liqui, _super);
                function liqui() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                liqui.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'liqui',
                        'name': 'Liqui',
                        'countries': 'UA',
                        'rateLimit': 3000,
                        'version': '3',
                        'userAgent': this.userAgents['chrome'],
                        'has': {
                            'CORS': false,
                            'createMarketOrder': false,
                            'fetchOrderBooks': true,
                            'fetchOrder': true,
                            'fetchOrders': 'emulated',
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': 'emulated',
                            'fetchTickers': true,
                            'fetchMyTrades': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27982022-75aea828-63a0-11e7-9511-ca584a8edd74.jpg',
                            'api': {
                                'public': 'https://api.liqui.io/api',
                                'private': 'https://api.liqui.io/tapi',
                            },
                            'www': 'https://liqui.io',
                            'doc': 'https://liqui.io/api',
                            'fees': 'https://liqui.io/fee',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'info',
                                    'ticker/{pair}',
                                    'depth/{pair}',
                                    'trades/{pair}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'getInfo',
                                    'Trade',
                                    'ActiveOrders',
                                    'OrderInfo',
                                    'CancelOrder',
                                    'TradeHistory',
                                    'CoinDepositAddress',
                                    'WithdrawCoin',
                                    'CreateCoupon',
                                    'RedeemCoupon',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.001,
                                'taker': 0.0025,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {},
                                'deposit': {},
                            },
                        },
                        'exceptions': {
                            '803': InvalidOrder,
                            '804': InvalidOrder,
                            '805': InvalidOrder,
                            '806': InvalidOrder,
                            '807': InvalidOrder,
                            '831': InsufficientFunds,
                            '832': InsufficientFunds,
                            '833': OrderNotFound,
                        },
                    });
                };
                liqui.prototype.calculateFee = function (symbol, type, side, amount, price, takerOrMaker, params) {
                    if (takerOrMaker === void 0) { takerOrMaker = 'taker'; }
                    if (params === void 0) { params = {}; }
                    var market = this.markets[symbol];
                    var key = 'quote';
                    var rate = market[takerOrMaker];
                    var cost = parseFloat(this.costToPrecision(symbol, amount * rate));
                    if (side === 'sell') {
                        cost *= price;
                    }
                    else {
                        key = 'base';
                    }
                    return {
                        'type': takerOrMaker,
                        'currency': market[key],
                        'rate': rate,
                        'cost': cost,
                    };
                };
                liqui.prototype.commonCurrencyCode = function (currency) {
                    if (!this.substituteCommonCurrencyCodes)
                        return currency;
                    if (currency === 'XBT')
                        return 'BTC';
                    if (currency === 'BCC')
                        return 'BCH';
                    if (currency === 'DRK')
                        return 'DASH';
                    if (currency === 'DSH')
                        return 'DASH';
                    return currency;
                };
                liqui.prototype.getBaseQuoteFromMarketId = function (id) {
                    var uppercase = id.toUpperCase();
                    var _a = __read(uppercase.split('_'), 2), base = _a[0], quote = _a[1];
                    base = this.commonCurrencyCode(base);
                    quote = this.commonCurrencyCode(quote);
                    return [base, quote];
                };
                liqui.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, keys, result, p, id, market, _a, base, quote, symbol, precision, amountLimits, priceLimits, costLimits, limits, hidden, active;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetInfo()];
                                case 1:
                                    response = _c.sent();
                                    markets = response['pairs'];
                                    keys = Object.keys(markets);
                                    result = [];
                                    for (p = 0; p < keys.length; p++) {
                                        id = keys[p];
                                        market = markets[id];
                                        _a = __read(this.getBaseQuoteFromMarketId(id), 2), base = _a[0], quote = _a[1];
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': this.safeInteger(market, 'decimal_places'),
                                            'price': this.safeInteger(market, 'decimal_places'),
                                        };
                                        amountLimits = {
                                            'min': this.safeFloat(market, 'min_amount'),
                                            'max': this.safeFloat(market, 'max_amount'),
                                        };
                                        priceLimits = {
                                            'min': this.safeFloat(market, 'min_price'),
                                            'max': this.safeFloat(market, 'max_price'),
                                        };
                                        costLimits = {
                                            'min': this.safeFloat(market, 'min_total'),
                                        };
                                        limits = {
                                            'amount': amountLimits,
                                            'price': priceLimits,
                                            'cost': costLimits,
                                        };
                                        hidden = this.safeInteger(market, 'hidden');
                                        active = (hidden === 0);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'active': active,
                                            'taker': market['fee'] / 100,
                                            'lot': amountLimits['min'],
                                            'precision': precision,
                                            'limits': limits,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                liqui.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, funds, currencies, c, currency, uppercase, total, used, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetInfo()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['return'];
                                    result = { 'info': balances };
                                    funds = balances['funds'];
                                    currencies = Object.keys(funds);
                                    for (c = 0; c < currencies.length; c++) {
                                        currency = currencies[c];
                                        uppercase = currency.toUpperCase();
                                        uppercase = this.commonCurrencyCode(uppercase);
                                        total = undefined;
                                        used = undefined;
                                        if (balances['open_orders'] === 0) {
                                            total = funds[currency];
                                            used = 0.0;
                                        }
                                        account = {
                                            'free': funds[currency],
                                            'used': used,
                                            'total': total,
                                        };
                                        result[uppercase] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                liqui.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, market_id_in_reponse, orderbook, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'pair': market['id'],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetDepthPair(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    market_id_in_reponse = (market['id'] in response);
                                    if (!market_id_in_reponse)
                                        throw new ExchangeError(this.id + ' ' + market['symbol'] + ' order book is empty or not available');
                                    orderbook = response[market['id']];
                                    result = this.parseOrderBook(orderbook);
                                    result['bids'] = this.sortBy(result['bids'], 0, true);
                                    result['asks'] = this.sortBy(result['asks'], 0);
                                    return [2, result];
                            }
                        });
                    });
                };
                liqui.prototype.fetchOrderBooks = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ids, numIds, response, result, i, id, symbol, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    ids = undefined;
                                    if (!symbols) {
                                        ids = this.ids.join('-');
                                        if (ids.length > 2048) {
                                            numIds = this.ids.length;
                                            throw new ExchangeError(this.id + ' has ' + numIds.toString() + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks');
                                        }
                                    }
                                    else {
                                        ids = this.marketIds(symbols);
                                        ids = ids.join('-');
                                    }
                                    return [4, this.publicGetDepthPair(this.extend({
                                            'pair': ids,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    result = {};
                                    ids = Object.keys(response);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        symbol = id;
                                        if (id in this.markets_by_id) {
                                            market = this.markets_by_id[id];
                                            symbol = market['symbol'];
                                        }
                                        result[symbol] = this.parseOrderBook(response[id]);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                liqui.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['updated'] * 1000;
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high'),
                        'low': this.safeFloat(ticker, 'low'),
                        'bid': this.safeFloat(ticker, 'buy'),
                        'ask': this.safeFloat(ticker, 'sell'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last'),
                        'change': undefined,
                        'percentage': undefined,
                        'average': this.safeFloat(ticker, 'avg'),
                        'baseVolume': this.safeFloat(ticker, 'vol_cur'),
                        'quoteVolume': this.safeFloat(ticker, 'vol'),
                        'info': ticker,
                    };
                };
                liqui.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ids, numIds, tickers, result, keys, k, id, ticker, symbol, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    ids = undefined;
                                    if (!symbols) {
                                        ids = this.ids.join('-');
                                        if (ids.length > 2048) {
                                            numIds = this.ids.length;
                                            throw new ExchangeError(this.id + ' has ' + numIds.toString() + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers');
                                        }
                                    }
                                    else {
                                        ids = this.marketIds(symbols);
                                        ids = ids.join('-');
                                    }
                                    return [4, this.publicGetTickerPair(this.extend({
                                            'pair': ids,
                                        }, params))];
                                case 2:
                                    tickers = _a.sent();
                                    result = {};
                                    keys = Object.keys(tickers);
                                    for (k = 0; k < keys.length; k++) {
                                        id = keys[k];
                                        ticker = tickers[id];
                                        symbol = id;
                                        market = undefined;
                                        if (id in this.markets_by_id) {
                                            market = this.markets_by_id[id];
                                            symbol = market['symbol'];
                                        }
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                liqui.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchTickers([symbol], params)];
                                case 1:
                                    tickers = _a.sent();
                                    return [2, tickers[symbol]];
                            }
                        });
                    });
                };
                liqui.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = parseInt(trade['timestamp']) * 1000;
                    var side = trade['type'];
                    if (side === 'ask')
                        side = 'sell';
                    if (side === 'bid')
                        side = 'buy';
                    var price = this.safeFloat(trade, 'price');
                    if ('rate' in trade)
                        price = this.safeFloat(trade, 'rate');
                    var id = this.safeString(trade, 'tid');
                    if ('trade_id' in trade)
                        id = this.safeString(trade, 'trade_id');
                    var order = this.safeString(trade, this.getOrderIdKey());
                    if ('pair' in trade) {
                        var marketId = trade['pair'];
                        market = this.markets_by_id[marketId];
                    }
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var amount = trade['amount'];
                    var type = 'limit';
                    var isYourOrder = this.safeValue(trade, 'is_your_order');
                    var takerOrMaker = 'taker';
                    if (typeof isYourOrder !== 'undefined')
                        if (isYourOrder)
                            takerOrMaker = 'maker';
                    var fee = this.calculateFee(symbol, type, side, amount, price, takerOrMaker);
                    return {
                        'id': id,
                        'order': order,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'fee': fee,
                        'info': trade,
                    };
                };
                liqui.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'pair': market['id'],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetTradesPair(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response[market['id']], market, since, limit)];
                            }
                        });
                    });
                };
                liqui.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, id, timestamp, status, filled, remaining, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'pair': market['id'],
                                        'type': side,
                                        'amount': this.amountToPrecision(symbol, amount),
                                        'rate': this.priceToPrecision(symbol, price),
                                    };
                                    return [4, this.privatePostTrade(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    id = this.safeString(response['return'], this.getOrderIdKey());
                                    timestamp = this.milliseconds();
                                    price = parseFloat(price);
                                    amount = parseFloat(amount);
                                    status = 'open';
                                    if (id === '0') {
                                        id = this.safeString(response['return'], 'init_order_id');
                                        status = 'closed';
                                    }
                                    filled = this.safeFloat(response['return'], 'received', 0.0);
                                    remaining = this.safeFloat(response['return'], 'remains', amount);
                                    order = {
                                        'id': id,
                                        'timestamp': timestamp,
                                        'datetime': this.iso8601(timestamp),
                                        'status': status,
                                        'symbol': symbol,
                                        'type': type,
                                        'side': side,
                                        'price': price,
                                        'cost': price * filled,
                                        'amount': amount,
                                        'remaining': remaining,
                                        'filled': filled,
                                        'fee': undefined,
                                    };
                                    this.orders[id] = order;
                                    return [2, this.extend({ 'info': response }, order)];
                            }
                        });
                    });
                };
                liqui.prototype.getOrderIdKey = function () {
                    return 'order_id';
                };
                liqui.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, request, idKey;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    response = undefined;
                                    request = {};
                                    idKey = this.getOrderIdKey();
                                    request[idKey] = id;
                                    return [4, this.privatePostCancelOrder(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    if (id in this.orders)
                                        this.orders[id]['status'] = 'canceled';
                                    return [2, response];
                            }
                        });
                    });
                };
                liqui.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        '0': 'open',
                        '1': 'closed',
                        '2': 'canceled',
                        '3': 'canceled',
                    };
                    if (status in statuses)
                        return statuses[status];
                    return status;
                };
                liqui.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var id = order['id'].toString();
                    var status = this.safeString(order, 'status');
                    if (status !== 'undefined')
                        status = this.parseOrderStatus(status);
                    var timestamp = parseInt(order['timestamp_created']) * 1000;
                    var symbol = undefined;
                    if (!market)
                        market = this.markets_by_id[order['pair']];
                    if (market)
                        symbol = market['symbol'];
                    var remaining = undefined;
                    var amount = undefined;
                    var price = this.safeFloat(order, 'rate');
                    var filled = undefined;
                    var cost = undefined;
                    if ('start_amount' in order) {
                        amount = this.safeFloat(order, 'start_amount');
                        remaining = this.safeFloat(order, 'amount');
                    }
                    else {
                        remaining = this.safeFloat(order, 'amount');
                        if (id in this.orders)
                            amount = this.orders[id]['amount'];
                    }
                    if (typeof amount !== 'undefined') {
                        if (typeof remaining !== 'undefined') {
                            filled = amount - remaining;
                            cost = price * filled;
                        }
                    }
                    var fee = undefined;
                    var result = {
                        'info': order,
                        'id': id,
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'type': 'limit',
                        'side': order['type'],
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'remaining': remaining,
                        'filled': filled,
                        'status': status,
                        'fee': fee,
                    };
                    return result;
                };
                liqui.prototype.parseOrders = function (orders, market, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var ids = Object.keys(orders);
                    var result = [];
                    for (var i = 0; i < ids.length; i++) {
                        var id = ids[i];
                        var order = orders[id];
                        var extended = this.extend(order, { 'id': id });
                        result.push(this.parseOrder(extended, market));
                    }
                    return this.filterBySinceLimit(result, since, limit);
                };
                liqui.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, newOrder, oldOrder;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostOrderInfo(this.extend({
                                            'order_id': parseInt(id),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    id = id.toString();
                                    newOrder = this.parseOrder(this.extend({ 'id': id }, response['return'][id]));
                                    oldOrder = (id in this.orders) ? this.orders[id] : {};
                                    this.orders[id] = this.extend(oldOrder, newOrder);
                                    return [2, this.orders[id]];
                            }
                        });
                    });
                };
                liqui.prototype.updateCachedOrders = function (openOrders, symbol) {
                    for (var j = 0; j < openOrders.length; j++) {
                        var id = openOrders[j]['id'];
                        this.orders[id] = openOrders[j];
                    }
                    var openOrdersIndexedById = this.indexBy(openOrders, 'id');
                    var cachedOrderIds = Object.keys(this.orders);
                    var result = [];
                    for (var k = 0; k < cachedOrderIds.length; k++) {
                        var id = cachedOrderIds[k];
                        var order = this.orders[id];
                        result.push(order);
                        if (!(id in openOrdersIndexedById)) {
                            if (typeof symbol !== 'undefined' && symbol !== order['symbol'])
                                continue;
                            if (order['status'] === 'open') {
                                order = this.extend(order, {
                                    'status': 'closed',
                                    'cost': undefined,
                                    'filled': order['amount'],
                                    'remaining': 0.0,
                                });
                                if (typeof order['cost'] === 'undefined') {
                                    if (typeof order['filled'] !== 'undefined')
                                        order['cost'] = order['filled'] * order['price'];
                                }
                                this.orders[id] = order;
                            }
                        }
                    }
                    return result;
                };
                liqui.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, market, market_1, response, openOrders, allOrders, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if ('fetchOrdersRequiresSymbol' in this.options)
                                        if (this.options['fetchOrdersRequiresSymbol'])
                                            if (typeof symbol === 'undefined')
                                                throw new ExchangeError(this.id + ' fetchOrders requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    market = undefined;
                                    if (typeof symbol !== 'undefined') {
                                        market_1 = this.market(symbol);
                                        request['pair'] = market_1['id'];
                                    }
                                    return [4, this.privatePostActiveOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    openOrders = [];
                                    if ('return' in response)
                                        openOrders = this.parseOrders(response['return'], market);
                                    allOrders = this.updateCachedOrders(openOrders, symbol);
                                    result = this.filterBySymbol(allOrders, symbol);
                                    return [2, this.filterBySinceLimit(result, since, limit)];
                            }
                        });
                    });
                };
                liqui.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.filterBy(orders, 'status', 'open')];
                            }
                        });
                    });
                };
                liqui.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.filterBy(orders, 'status', 'closed')];
                            }
                        });
                    });
                };
                liqui.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (typeof symbol !== 'undefined') {
                                        market = this.market(symbol);
                                        request['pair'] = market['id'];
                                    }
                                    if (typeof limit !== 'undefined')
                                        request['count'] = parseInt(limit);
                                    if (typeof since !== 'undefined')
                                        request['since'] = parseInt(since / 1000);
                                    return [4, this.privatePostTradeHistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    trades = [];
                                    if ('return' in response)
                                        trades = response['return'];
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                liqui.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostWithdrawCoin(this.extend({
                                            'coinName': currency,
                                            'amount': parseFloat(amount),
                                            'address': address,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['return']['tId'],
                                        }];
                            }
                        });
                    });
                };
                liqui.prototype.signBodyWithSecret = function (body) {
                    return this.hmac(this.encode(body), this.encode(this.secret), 'sha512');
                };
                liqui.prototype.getVersionString = function () {
                    return '/' + this.version;
                };
                liqui.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({
                            'nonce': nonce,
                            'method': path,
                        }, query));
                        var signature = this.signBodyWithSecret(body);
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Key': this.apiKey,
                            'Sign': signature,
                        };
                    }
                    else {
                        url += this.getVersionString() + '/' + this.implodeParams(path, params);
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                liqui.prototype.handleErrors = function (httpCode, reason, url, method, headers, body) {
                    if (typeof body !== 'string')
                        return;
                    if (body.length < 2)
                        return;
                    if ((body[0] === '{') || (body[0] === '[')) {
                        var response = JSON.parse(body);
                        if ('success' in response) {
                            var success = this.safeValue(response, 'success', false);
                            if (typeof success === 'string') {
                                if ((success === 'true') || (success === '1'))
                                    success = true;
                                else
                                    success = false;
                            }
                            if (!success) {
                                var code = this.safeString(response, 'code');
                                var message = this.safeString(response, 'error');
                                var feedback = this.id + ' ' + this.json(response);
                                var exceptions = this.exceptions;
                                if (code in exceptions) {
                                    throw new exceptions[code](feedback);
                                }
                                if (message === 'invalid api key') {
                                    throw new AuthenticationError(feedback);
                                }
                                else if (message === 'api key dont have trade permission') {
                                    throw new AuthenticationError(feedback);
                                }
                                else if (message.indexOf('invalid parameter') >= 0) {
                                    throw new InvalidOrder(feedback);
                                }
                                else if (message === 'invalid order') {
                                    throw new InvalidOrder(feedback);
                                }
                                else if (message === 'Requests too often') {
                                    throw new DDoSProtection(feedback);
                                }
                                else if (message === 'not available') {
                                    throw new DDoSProtection(feedback);
                                }
                                else if (message === 'data unavailable') {
                                    throw new DDoSProtection(feedback);
                                }
                                else if (message === 'external service unavailable') {
                                    throw new DDoSProtection(feedback);
                                }
                                else {
                                    throw new ExchangeError(this.id + ' unknown "error" value: ' + this.json(response));
                                }
                            }
                        }
                    }
                };
                return liqui;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 91: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError, NotSupported = _a.NotSupported, InvalidOrder = _a.InvalidOrder, OrderNotFound = _a.OrderNotFound, ExchangeNotAvailable = _a.ExchangeNotAvailable, DDoSProtection = _a.DDoSProtection;
            module.exports = (function (_super) {
                __extends(livecoin, _super);
                function livecoin() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                livecoin.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'livecoin',
                        'name': 'LiveCoin',
                        'countries': ['US', 'UK', 'RU'],
                        'rateLimit': 1000,
                        'has': {
                            'fetchDepositAddress': true,
                            'CORS': false,
                            'fetchTickers': true,
                            'fetchCurrencies': true,
                            'fetchFees': true,
                            'fetchOrders': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27980768-f22fc424-638a-11e7-89c9-6010a54ff9be.jpg',
                            'api': 'https://api.livecoin.net',
                            'www': 'https://www.livecoin.net',
                            'doc': 'https://www.livecoin.net/api?lang=en',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'exchange/all/order_book',
                                    'exchange/last_trades',
                                    'exchange/maxbid_minask',
                                    'exchange/order_book',
                                    'exchange/restrictions',
                                    'exchange/ticker',
                                    'info/coinInfo',
                                ],
                            },
                            'private': {
                                'get': [
                                    'exchange/client_orders',
                                    'exchange/order',
                                    'exchange/trades',
                                    'exchange/commission',
                                    'exchange/commissionCommonInfo',
                                    'payment/balances',
                                    'payment/balance',
                                    'payment/get/address',
                                    'payment/history/size',
                                    'payment/history/transactions',
                                ],
                                'post': [
                                    'exchange/buylimit',
                                    'exchange/buymarket',
                                    'exchange/cancellimit',
                                    'exchange/selllimit',
                                    'exchange/sellmarket',
                                    'payment/out/capitalist',
                                    'payment/out/card',
                                    'payment/out/coin',
                                    'payment/out/okpay',
                                    'payment/out/payeer',
                                    'payment/out/perfectmoney',
                                    'payment/voucher/amount',
                                    'payment/voucher/make',
                                    'payment/voucher/redeem',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'maker': 0.18 / 100,
                                'taker': 0.18 / 100,
                            },
                        },
                    });
                };
                livecoin.prototype.commonCurrencyCode = function (currency) {
                    return currency;
                };
                livecoin.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, restrictions, restrictionsById, result, p, market, id, symbol, _a, base, quote, coinRestrictions, precision, limits;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetExchangeTicker()];
                                case 1:
                                    markets = _c.sent();
                                    return [4, this.publicGetExchangeRestrictions()];
                                case 2:
                                    restrictions = _c.sent();
                                    restrictionsById = this.indexBy(restrictions['restrictions'], 'currencyPair');
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['symbol'];
                                        symbol = id;
                                        _a = __read(symbol.split('/'), 2), base = _a[0], quote = _a[1];
                                        coinRestrictions = this.safeValue(restrictionsById, symbol);
                                        precision = {
                                            'price': 5,
                                            'amount': 8,
                                            'cost': 8,
                                        };
                                        limits = {
                                            'amount': {
                                                'min': Math.pow(10, -precision['amount']),
                                                'max': Math.pow(10, precision['amount']),
                                            },
                                        };
                                        if (coinRestrictions) {
                                            precision['price'] = this.safeInteger(coinRestrictions, 'priceScale', 5);
                                            limits['amount']['min'] = this.safeFloat(coinRestrictions, 'minLimitQuantity', limits['amount']['min']);
                                        }
                                        limits['price'] = {
                                            'min': Math.pow(10, -precision['price']),
                                            'max': Math.pow(10, precision['price']),
                                        };
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'precision': precision,
                                            'limits': limits,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                livecoin.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, currencies, result, i, currency, id, code, precision, active;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetInfoCoinInfo(params)];
                                case 1:
                                    response = _a.sent();
                                    currencies = response['info'];
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['symbol'];
                                        code = this.commonCurrencyCode(id);
                                        precision = 8;
                                        active = (currency['walletStatus'] === 'normal');
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'info': currency,
                                            'name': currency['name'],
                                            'active': active,
                                            'status': 'ok',
                                            'fee': currency['withdrawFee'],
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': currency['minOrderAmount'],
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': currency['minOrderAmount'],
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': currency['minWithdrawAmount'],
                                                    'max': Math.pow(10, precision),
                                                },
                                                'deposit': {
                                                    'min': currency['minDepositAmount'],
                                                    'max': undefined,
                                                },
                                            },
                                        };
                                    }
                                    result = this.appendFiatCurrencies(result);
                                    return [2, result];
                            }
                        });
                    });
                };
                livecoin.prototype.appendFiatCurrencies = function (result) {
                    if (result === void 0) { result = []; }
                    var precision = 8;
                    var defaults = {
                        'info': undefined,
                        'active': true,
                        'status': 'ok',
                        'fee': undefined,
                        'precision': precision,
                        'limits': {
                            'withdraw': { 'min': undefined, 'max': undefined },
                            'deposit': { 'min': undefined, 'max': undefined },
                            'amount': { 'min': undefined, 'max': undefined },
                            'cost': { 'min': undefined, 'max': undefined },
                            'price': {
                                'min': Math.pow(10, -precision),
                                'max': Math.pow(10, precision),
                            },
                        },
                    };
                    var currencies = [
                        { 'id': 'USD', 'code': 'USD', 'name': 'US Dollar' },
                        { 'id': 'EUR', 'code': 'EUR', 'name': 'Euro' },
                        { 'id': 'RUR', 'code': 'RUR', 'name': 'Russian ruble' },
                    ];
                    for (var i = 0; i < currencies.length; i++) {
                        var currency = currencies[i];
                        var code = currency['code'];
                        result[code] = this.extend(defaults, currency);
                    }
                    return result;
                };
                livecoin.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, b, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetPaymentBalances()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        account = undefined;
                                        if (currency in result)
                                            account = result[currency];
                                        else
                                            account = this.account();
                                        if (balance['type'] === 'total')
                                            account['total'] = parseFloat(balance['value']);
                                        if (balance['type'] === 'available')
                                            account['free'] = parseFloat(balance['value']);
                                        if (balance['type'] === 'trade')
                                            account['used'] = parseFloat(balance['value']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                livecoin.prototype.fetchFees = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tradingFees;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchTradingFees(params)];
                                case 1:
                                    tradingFees = _a.sent();
                                    return [2, this.extend(tradingFees, {
                                            'withdraw': {},
                                        })];
                            }
                        });
                    });
                };
                livecoin.prototype.fetchTradingFees = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, commission;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetExchangeCommissionCommonInfo(params)];
                                case 2:
                                    response = _a.sent();
                                    commission = this.safeFloat(response, 'commission');
                                    return [2, {
                                            'info': response,
                                            'maker': commission,
                                            'taker': commission,
                                        }];
                            }
                        });
                    });
                };
                livecoin.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'currencyPair': this.marketId(symbol),
                                        'groupByPrice': 'false',
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['depth'] = limit;
                                    return [4, this.publicGetExchangeOrderBook(this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = orderbook['timestamp'];
                                    return [2, this.parseOrderBook(orderbook, timestamp)];
                            }
                        });
                    });
                };
                livecoin.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var vwap = parseFloat(ticker['vwap']);
                    var baseVolume = parseFloat(ticker['volume']);
                    var quoteVolume = baseVolume * vwap;
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['best_bid']),
                        'ask': parseFloat(ticker['best_ask']),
                        'vwap': parseFloat(ticker['vwap']),
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': baseVolume,
                        'quoteVolume': quoteVolume,
                        'info': ticker,
                    };
                };
                livecoin.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, ids, result, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetExchangeTicker(params)];
                                case 2:
                                    response = _a.sent();
                                    tickers = this.indexBy(response, 'symbol');
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                livecoin.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetExchangeTicker(this.extend({
                                            'currencyPair': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                livecoin.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['time'] * 1000;
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'id': trade['id'].toString(),
                        'order': undefined,
                        'type': undefined,
                        'side': trade['type'].toLowerCase(),
                        'price': trade['price'],
                        'amount': trade['quantity'],
                    };
                };
                livecoin.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetExchangeLastTrades(this.extend({
                                            'currencyPair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                livecoin.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.safeInteger(order, 'lastModificationTime');
                    if (!timestamp)
                        timestamp = this.parse8601(order['lastModificationTime']);
                    var trades = undefined;
                    if ('trades' in order)
                        trades = undefined;
                    var status = undefined;
                    if (order['orderStatus'] === 'OPEN' || order['orderStatus'] === 'PARTIALLY_FILLED') {
                        status = 'open';
                    }
                    else if (order['orderStatus'] === 'EXECUTED' || order['orderStatus'] === 'PARTIALLY_FILLED_AND_CANCELLED') {
                        status = 'closed';
                    }
                    else {
                        status = 'canceled';
                    }
                    var symbol = order['currencyPair'];
                    var parts = symbol.split('/');
                    var quote = parts[1];
                    var type = undefined;
                    var side = undefined;
                    if (order['type'].indexOf('MARKET') >= 0) {
                        type = 'market';
                    }
                    else {
                        type = 'limit';
                    }
                    if (order['type'].indexOf('SELL') >= 0) {
                        side = 'sell';
                    }
                    else {
                        side = 'buy';
                    }
                    var price = this.safeFloat(order, 'price', 0.0);
                    var cost = this.safeFloat(order, 'commissionByTrade', 0.0);
                    var remaining = this.safeFloat(order, 'remainingQuantity', 0.0);
                    var amount = this.safeFloat(order, 'quantity', remaining);
                    var filled = amount - remaining;
                    return {
                        'info': order,
                        'id': order['id'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': status,
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'trades': trades,
                        'fee': {
                            'cost': cost,
                            'currency': quote,
                        },
                    };
                };
                livecoin.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, pair, request, response, result, rawOrders, i, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (symbol)
                                        market = this.market(symbol);
                                    pair = market ? market['id'] : undefined;
                                    request = {};
                                    if (pair)
                                        request['currencyPair'] = pair;
                                    if (typeof since !== 'undefined')
                                        request['issuedFrom'] = parseInt(since);
                                    if (typeof limit !== 'undefined')
                                        request['endRow'] = limit - 1;
                                    return [4, this.privateGetExchangeClientOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    result = [];
                                    rawOrders = [];
                                    if (response['data'])
                                        rawOrders = response['data'];
                                    for (i = 0; i < rawOrders.length; i++) {
                                        order = rawOrders[i];
                                        result.push(this.parseOrder(order, market));
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                livecoin.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, this.extend({
                                        'openClosed': 'OPEN',
                                    }, params))];
                                case 1:
                                    result = _a.sent();
                                    return [2, result];
                            }
                        });
                    });
                };
                livecoin.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, this.extend({
                                        'openClosed': 'CLOSED',
                                    }, params))];
                                case 1:
                                    result = _a.sent();
                                    return [2, result];
                            }
                        });
                    });
                };
                livecoin.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, market, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = 'privatePostExchange' + this.capitalize(side) + type;
                                    market = this.market(symbol);
                                    order = {
                                        'quantity': this.amountToPrecision(symbol, amount),
                                        'currencyPair': market['id'],
                                    };
                                    if (type === 'limit')
                                        order['price'] = this.priceToPrecision(symbol, price);
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['orderId'].toString(),
                                        }];
                            }
                        });
                    });
                };
                livecoin.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, currencyPair, response, message;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' cancelOrder requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    currencyPair = market['id'];
                                    return [4, this.privatePostExchangeCancellimit(this.extend({
                                            'orderId': id,
                                            'currencyPair': currencyPair,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    message = this.safeString(response, 'message', this.json(response));
                                    if ('success' in response) {
                                        if (!response['success']) {
                                            throw new InvalidOrder(message);
                                        }
                                        else if ('cancelled' in response) {
                                            if (response['cancelled']) {
                                                return [2, response];
                                            }
                                            else {
                                                throw new OrderNotFound(message);
                                            }
                                        }
                                    }
                                    throw new ExchangeError(this.id + ' cancelOrder() failed: ' + this.json(response));
                            }
                        });
                    });
                };
                livecoin.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var withdrawal, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    withdrawal = {
                                        'amount': amount,
                                        'currency': this.commonCurrencyCode(currency),
                                        'wallet': this.checkAddress(address),
                                    };
                                    return [4, this.privatePostPaymentOutCoin(this.extend(withdrawal, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': this.safeInteger(response, 'id'),
                                        }];
                            }
                        });
                    });
                };
                livecoin.prototype.fetchDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, address, tag, parts;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    request = {
                                        'currency': currency,
                                    };
                                    return [4, this.privateGetPaymentGetAddress(this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    address = this.safeString(response, 'wallet');
                                    tag = undefined;
                                    if (address.indexOf(':') >= 0) {
                                        parts = address.split(':');
                                        address = parts[0];
                                        tag = parts[2];
                                    }
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'tag': tag,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                livecoin.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + path;
                    var query = this.urlencode(this.keysort(params));
                    if (method === 'GET') {
                        if (Object.keys(params).length) {
                            url += '?' + query;
                        }
                    }
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        if (method === 'POST')
                            body = query;
                        var signature = this.hmac(this.encode(query), this.encode(this.secret), 'sha256');
                        headers = {
                            'Api-Key': this.apiKey,
                            'Sign': signature.toUpperCase(),
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                livecoin.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code >= 300) {
                        if (body[0] === '{') {
                            var response = JSON.parse(body);
                            if ('errorCode' in response) {
                                var error = response['errorCode'];
                                if (error === 1) {
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                                }
                                else if (error === 2) {
                                    if ('errorMessage' in response) {
                                        if (response['errorMessage'] === 'User not found')
                                            throw new AuthenticationError(this.id + ' ' + response['errorMessage']);
                                    }
                                    else {
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    }
                                }
                                else if ((error === 10) || (error === 11) || (error === 12) || (error === 20) || (error === 30) || (error === 101) || (error === 102)) {
                                    throw new AuthenticationError(this.id + ' ' + this.json(response));
                                }
                                else if (error === 31) {
                                    throw new NotSupported(this.id + ' ' + this.json(response));
                                }
                                else if (error === 32) {
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                                }
                                else if (error === 100) {
                                    throw new ExchangeError(this.id + ': Invalid parameters ' + this.json(response));
                                }
                                else if (error === 103) {
                                    throw new InvalidOrder(this.id + ': Invalid currency ' + this.json(response));
                                }
                                else if (error === 104) {
                                    throw new InvalidOrder(this.id + ': Invalid amount ' + this.json(response));
                                }
                                else if (error === 105) {
                                    throw new InvalidOrder(this.id + ': Unable to block funds ' + this.json(response));
                                }
                                else if (error === 503) {
                                    throw new ExchangeNotAvailable(this.id + ': Exchange is not available ' + this.json(response));
                                }
                                else if (error === 429) {
                                    throw new DDoSProtection(this.id + ': Too many requests' + this.json(response));
                                }
                                else {
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                                }
                            }
                        }
                        throw new ExchangeError(this.id + ' ' + body);
                    }
                };
                livecoin.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('success' in response) {
                                        if (!response['success']) {
                                            throw new ExchangeError(this.id + ' error: ' + this.json(response));
                                        }
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return livecoin;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 92: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(luno, _super);
                function luno() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                luno.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'luno',
                        'name': 'luno',
                        'countries': ['GB', 'SG', 'ZA'],
                        'rateLimit': 10000,
                        'version': '1',
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                            'fetchOrder': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg',
                            'api': 'https://api.mybitx.com/api',
                            'www': 'https://www.luno.com',
                            'doc': [
                                'https://www.luno.com/en/api',
                                'https://npmjs.org/package/bitx',
                                'https://github.com/bausmeier/node-bitx',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'orderbook',
                                    'ticker',
                                    'tickers',
                                    'trades',
                                ],
                            },
                            'private': {
                                'get': [
                                    'accounts/{id}/pending',
                                    'accounts/{id}/transactions',
                                    'balance',
                                    'fee_info',
                                    'funding_address',
                                    'listorders',
                                    'listtrades',
                                    'orders/{id}',
                                    'quotes/{id}',
                                    'withdrawals',
                                    'withdrawals/{id}',
                                ],
                                'post': [
                                    'accounts',
                                    'postorder',
                                    'marketorder',
                                    'stoporder',
                                    'funding_address',
                                    'withdrawals',
                                    'send',
                                    'quotes',
                                    'oauth2/grant',
                                ],
                                'put': [
                                    'quotes/{id}',
                                ],
                                'delete': [
                                    'quotes/{id}',
                                    'withdrawals/{id}',
                                ],
                            },
                        },
                    });
                };
                luno.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTickers()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets['tickers'].length; p++) {
                                        market = markets['tickers'][p];
                                        id = market['pair'];
                                        base = id.slice(0, 3);
                                        quote = id.slice(3, 6);
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                luno.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, reserved, unconfirmed, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetBalance()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['balance'];
                                    result = { 'info': response };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = this.commonCurrencyCode(balance['asset']);
                                        reserved = parseFloat(balance['reserved']);
                                        unconfirmed = parseFloat(balance['unconfirmed']);
                                        account = {
                                            'free': 0.0,
                                            'used': this.sum(reserved, unconfirmed),
                                            'total': parseFloat(balance['balance']),
                                        };
                                        account['free'] = account['total'] - account['used'];
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                luno.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderbook(this.extend({
                                            'pair': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = orderbook['timestamp'];
                                    return [2, this.parseOrderBook(orderbook, timestamp, 'bids', 'asks', 'price', 'volume')];
                            }
                        });
                    });
                };
                luno.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = order['creation_timestamp'];
                    var status = (order['state'] === 'PENDING') ? 'open' : 'closed';
                    var side = (order['type'] === 'ASK') ? 'sell' : 'buy';
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var price = this.safeFloat(order, 'limit_price');
                    var amount = this.safeFloat(order, 'limit_volume');
                    var quoteFee = this.safeFloat(order, 'fee_counter');
                    var baseFee = this.safeFloat(order, 'fee_base');
                    var fee = { 'currency': undefined };
                    if (quoteFee) {
                        fee['side'] = 'quote';
                        fee['cost'] = quoteFee;
                    }
                    else {
                        fee['side'] = 'base';
                        fee['cost'] = baseFee;
                    }
                    return {
                        'id': order['order_id'],
                        'datetime': this.iso8601(timestamp),
                        'timestamp': timestamp,
                        'status': status,
                        'symbol': symbol,
                        'type': undefined,
                        'side': side,
                        'price': price,
                        'amount': amount,
                        'filled': undefined,
                        'remaining': undefined,
                        'trades': undefined,
                        'fee': fee,
                        'info': order,
                    };
                };
                luno.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetOrdersId(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response)];
                            }
                        });
                    });
                };
                luno.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['timestamp'];
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': undefined,
                        'low': undefined,
                        'bid': parseFloat(ticker['bid']),
                        'ask': parseFloat(ticker['ask']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last_trade']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['rolling_24_hour_volume']),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                luno.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, ids, result, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickers(params)];
                                case 2:
                                    response = _a.sent();
                                    tickers = this.indexBy(response['tickers'], 'pair');
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                luno.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTicker(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                luno.prototype.parseTrade = function (trade, market) {
                    var side = (trade['is_buy']) ? 'buy' : 'sell';
                    return {
                        'info': trade,
                        'id': undefined,
                        'order': undefined,
                        'timestamp': trade['timestamp'],
                        'datetime': this.iso8601(trade['timestamp']),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': side,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['volume']),
                    };
                };
                luno.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'pair': market['id'],
                                    };
                                    if (typeof since !== 'undefined')
                                        request['since'] = since;
                                    return [4, this.publicGetTrades(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['trades'], market, since, limit)];
                            }
                        });
                    });
                };
                luno.prototype.createOrder = function (market, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = 'privatePost';
                                    order = { 'pair': this.marketId(market) };
                                    if (type === 'market') {
                                        method += 'Marketorder';
                                        order['type'] = side.toUpperCase();
                                        if (side === 'buy')
                                            order['counter_volume'] = amount;
                                        else
                                            order['base_volume'] = amount;
                                    }
                                    else {
                                        method += 'Postorder';
                                        order['volume'] = amount;
                                        order['price'] = price;
                                        if (side === 'buy')
                                            order['type'] = 'BID';
                                        else
                                            order['type'] = 'ASK';
                                    }
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['order_id'],
                                        }];
                            }
                        });
                    });
                };
                luno.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostStoporder({ 'order_id': id })];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                luno.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (Object.keys(query).length)
                        url += '?' + this.urlencode(query);
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var auth = this.encode(this.apiKey + ':' + this.secret);
                        auth = this.stringToBase64(auth);
                        headers = { 'Authorization': 'Basic ' + this.decode(auth) };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                luno.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('error' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return luno;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 93: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            module.exports = (function (_super) {
                __extends(lykke, _super);
                function lykke() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                lykke.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'lykke',
                        'name': 'Lykke',
                        'countries': 'CH',
                        'version': 'v1',
                        'rateLimit': 200,
                        'has': {
                            'CORS': false,
                            'fetchOHLCV': false,
                            'fetchTrades': false,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'fetchOrders': true,
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/34487620-3139a7b0-efe6-11e7-90f5-e520cef74451.jpg',
                            'api': {
                                'mobile': 'https://api.lykkex.com/api',
                                'public': 'https://hft-api.lykke.com/api',
                                'private': 'https://hft-api.lykke.com/api',
                                'test': {
                                    'mobile': 'https://api.lykkex.com/api',
                                    'public': 'https://hft-service-dev.lykkex.net/api',
                                    'private': 'https://hft-service-dev.lykkex.net/api',
                                },
                            },
                            'www': 'https://www.lykke.com',
                            'doc': [
                                'https://hft-api.lykke.com/swagger/ui/',
                                'https://www.lykke.com/lykke_api',
                            ],
                            'fees': 'https://www.lykke.com/trading-conditions',
                        },
                        'api': {
                            'mobile': {
                                'get': [
                                    'AllAssetPairRates/{market}',
                                ],
                            },
                            'public': {
                                'get': [
                                    'AssetPairs',
                                    'AssetPairs/{id}',
                                    'IsAlive',
                                    'OrderBooks',
                                    'OrderBooks/{AssetPairId}',
                                ],
                            },
                            'private': {
                                'get': [
                                    'Orders',
                                    'Orders/{id}',
                                    'Wallets',
                                ],
                                'post': [
                                    'Orders/limit',
                                    'Orders/market',
                                    'Orders/{id}/Cancel',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'maker': 0.0,
                                'taker': 0.0,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0.001,
                                },
                                'deposit': {
                                    'BTC': 0,
                                },
                            },
                        },
                    });
                };
                lykke.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, i, balance, currency, total, used, free;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetWallets()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (i = 0; i < balances.length; i++) {
                                        balance = balances[i];
                                        currency = balance['AssetId'];
                                        total = balance['Balance'];
                                        used = balance['Reserved'];
                                        free = total - used;
                                        result[currency] = {
                                            'free': free,
                                            'used': used,
                                            'total': total,
                                        };
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                lykke.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostOrdersIdCancel({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                lykke.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, query, method, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    query = {
                                        'AssetPairId': market['id'],
                                        'OrderAction': this.capitalize(side),
                                        'Volume': amount,
                                    };
                                    if (type === 'market') {
                                        query['Asset'] = (side === 'buy') ? market['base'] : market['quote'];
                                    }
                                    else if (type === 'limit') {
                                        query['Price'] = price;
                                    }
                                    method = 'privatePostOrders' + this.capitalize(type);
                                    return [4, this[method](this.extend(query, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, {
                                            'id': undefined,
                                            'info': result,
                                        }];
                            }
                        });
                    });
                };
                lykke.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, i, market, id, base, quote, symbol, precision;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetAssetPairs()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        id = market['Id'];
                                        base = market['BaseAssetId'];
                                        quote = market['QuotingAssetId'];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = market['Name'];
                                        precision = {
                                            'amount': market['Accuracy'],
                                            'price': market['InvertedAccuracy'],
                                        };
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'active': true,
                                            'info': market,
                                            'lot': Math.pow(10, -precision['amount']),
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision['amount']),
                                                    'max': Math.pow(10, precision['amount']),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision['price']),
                                                    'max': Math.pow(10, precision['price']),
                                                },
                                            },
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                lykke.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    ticker = ticker['Result'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': undefined,
                        'low': undefined,
                        'bid': parseFloat(ticker['Rate']['Bid']),
                        'ask': parseFloat(ticker['Rate']['Ask']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': undefined,
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': undefined,
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                lykke.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.mobileGetAllAssetPairRatesMarket(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                lykke.prototype.parseOrderStatus = function (status) {
                    if (status === 'Pending') {
                        return 'open';
                    }
                    else if (status === 'InOrderBook') {
                        return 'open';
                    }
                    else if (status === 'Processing') {
                        return 'open';
                    }
                    else if (status === 'Matched') {
                        return 'closed';
                    }
                    else if (status === 'Cancelled') {
                        return 'canceled';
                    }
                    else if (status === 'NotEnoughFunds') {
                        return 'NotEnoughFunds';
                    }
                    else if (status === 'NoLiquidity') {
                        return 'NoLiquidity';
                    }
                    else if (status === 'UnknownAsset') {
                        return 'UnknownAsset';
                    }
                    else if (status === 'LeadToNegativeSpread') {
                        return 'LeadToNegativeSpread';
                    }
                    return status;
                };
                lykke.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var status = this.parseOrderStatus(order['Status']);
                    var symbol = undefined;
                    if (!market) {
                        if ('AssetPairId' in order)
                            if (order['AssetPairId'] in this.markets_by_id)
                                market = this.markets_by_id[order['AssetPairId']];
                    }
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = undefined;
                    if ('LastMatchTime' in order) {
                        timestamp = this.parse8601(order['LastMatchTime']);
                    }
                    else if ('Registered' in order) {
                        timestamp = this.parse8601(order['Registered']);
                    }
                    else if ('CreatedAt' in order) {
                        timestamp = this.parse8601(order['CreatedAt']);
                    }
                    var price = this.safeFloat(order, 'Price');
                    var amount = this.safeFloat(order, 'Volume');
                    var remaining = this.safeFloat(order, 'RemainingVolume');
                    var filled = amount - remaining;
                    var cost = filled * price;
                    var result = {
                        'info': order,
                        'id': order['Id'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': undefined,
                        'side': undefined,
                        'price': price,
                        'cost': cost,
                        'average': undefined,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': undefined,
                    };
                    return result;
                };
                lykke.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetOrdersId(this.extend({
                                        'id': id,
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response)];
                            }
                        });
                    });
                };
                lykke.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetOrders()];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, undefined, since, limit)];
                            }
                        });
                    });
                };
                lykke.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetOrders(this.extend({
                                        'status': 'InOrderBook',
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, undefined, since, limit)];
                            }
                        });
                    });
                };
                lykke.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetOrders(this.extend({
                                        'status': 'Matched',
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, undefined, since, limit)];
                            }
                        });
                    });
                };
                lykke.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderbook, timestamp, i, side, timestamp_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderBooksAssetPairId(this.extend({
                                            'AssetPairId': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = {
                                        'timestamp': undefined,
                                        'bids': [],
                                        'asks': [],
                                    };
                                    timestamp = undefined;
                                    for (i = 0; i < response.length; i++) {
                                        side = response[i];
                                        if (side['IsBuy']) {
                                            orderbook['bids'] = this.arrayConcat(orderbook['bids'], side['Prices']);
                                        }
                                        else {
                                            orderbook['asks'] = this.arrayConcat(orderbook['asks'], side['Prices']);
                                        }
                                        timestamp_1 = this.parse8601(side['Timestamp']);
                                        if (!orderbook['timestamp']) {
                                            orderbook['timestamp'] = timestamp_1;
                                        }
                                        else {
                                            orderbook['timestamp'] = Math.max(orderbook['timestamp'], timestamp_1);
                                        }
                                    }
                                    if (!timestamp)
                                        timestamp = this.milliseconds();
                                    return [2, this.parseOrderBook(orderbook, orderbook['timestamp'], 'bids', 'asks', 'Price', 'Volume')];
                            }
                        });
                    });
                };
                lykke.prototype.parseBidAsk = function (bidask, priceKey, amountKey) {
                    if (priceKey === void 0) { priceKey = 0; }
                    if (amountKey === void 0) { amountKey = 1; }
                    var price = parseFloat(bidask[priceKey]);
                    var amount = parseFloat(bidask[amountKey]);
                    if (amount < 0)
                        amount = -amount;
                    return [price, amount];
                };
                lykke.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else if (api === 'private') {
                        if (method === 'GET')
                            if (Object.keys(query).length)
                                url += '?' + this.urlencode(query);
                        this.checkRequiredCredentials();
                        headers = {
                            'api-key': this.apiKey,
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                        };
                        if (method === 'POST')
                            if (Object.keys(params).length)
                                body = this.json(params);
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return lykke;
            }(Exchange));
        }, { "./base/Exchange": 8 }], 94: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(mercado, _super);
                function mercado() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                mercado.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'mercado',
                        'name': 'Mercado Bitcoin',
                        'countries': 'BR',
                        'rateLimit': 1000,
                        'version': 'v3',
                        'has': {
                            'CORS': true,
                            'createMarketOrder': false,
                            'fetchOrder': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg',
                            'api': {
                                'public': 'https://www.mercadobitcoin.net/api',
                                'private': 'https://www.mercadobitcoin.net/tapi',
                            },
                            'www': 'https://www.mercadobitcoin.com.br',
                            'doc': [
                                'https://www.mercadobitcoin.com.br/api-doc',
                                'https://www.mercadobitcoin.com.br/trade-api',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    '{coin}/orderbook/',
                                    '{coin}/ticker/',
                                    '{coin}/trades/',
                                    '{coin}/trades/{from}/',
                                    '{coin}/trades/{from}/{to}',
                                    '{coin}/day-summary/{year}/{month}/{day}/',
                                ],
                            },
                            'private': {
                                'post': [
                                    'cancel_order',
                                    'get_account_info',
                                    'get_order',
                                    'get_withdrawal',
                                    'list_system_messages',
                                    'list_orders',
                                    'list_orderbook',
                                    'place_buy_order',
                                    'place_sell_order',
                                    'withdraw_coin',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/BRL': { 'id': 'BRLBTC', 'symbol': 'BTC/BRL', 'base': 'BTC', 'quote': 'BRL', 'suffix': 'Bitcoin' },
                            'LTC/BRL': { 'id': 'BRLLTC', 'symbol': 'LTC/BRL', 'base': 'LTC', 'quote': 'BRL', 'suffix': 'Litecoin' },
                            'BCH/BRL': { 'id': 'BRLBCH', 'symbol': 'BCH/BRL', 'base': 'BCH', 'quote': 'BRL', 'suffix': 'BCash' },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.3 / 100,
                                'taker': 0.7 / 100,
                            },
                        },
                    });
                };
                mercado.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetCoinOrderbook(this.extend({
                                            'coin': market['base'],
                                        }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                mercado.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetCoinTicker(this.extend({
                                            'coin': market['base'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    ticker = response['ticker'];
                                    timestamp = parseInt(ticker['date']) * 1000;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['buy']),
                                            'ask': parseFloat(ticker['sell']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['vol']),
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                mercado.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['date'] * 1000;
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'id': trade['tid'].toString(),
                        'order': undefined,
                        'type': undefined,
                        'side': trade['type'],
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                mercado.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, to, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    method = 'publicGetCoinTrades';
                                    request = {
                                        'coin': market['base'],
                                    };
                                    if (typeof since !== 'undefined') {
                                        method += 'From';
                                        request['from'] = parseInt(since / 1000);
                                    }
                                    to = this.safeInteger(params, 'to');
                                    if (typeof to !== 'undefined')
                                        method += 'To';
                                    return [4, this[method](this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                mercado.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, currencies, i, currency, lowercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostGetAccountInfo()];
                                case 1:
                                    response = _a.sent();
                                    balances = response['response_data']['balance'];
                                    result = { 'info': response };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        account = this.account();
                                        if (lowercase in balances) {
                                            account['free'] = parseFloat(balances[lowercase]['available']);
                                            account['total'] = parseFloat(balances[lowercase]['total']);
                                            account['used'] = account['total'] - account['free'];
                                        }
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                mercado.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    method = 'privatePostPlace' + this.capitalize(side) + 'Order';
                                    order = {
                                        'coin_pair': this.marketId(symbol),
                                        'quantity': amount,
                                        'limit_price': price,
                                    };
                                    return [4, this[method](this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['response_data']['order']['order_id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                mercado.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' cancelOrder() requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privatePostCancelOrder(this.extend({
                                            'coin_pair': market['id'],
                                            'order_id': id,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                mercado.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = undefined;
                    if ('order_type' in order)
                        side = (order['order_type'] === 1) ? 'buy' : 'sell';
                    var status = order['status'];
                    var symbol = undefined;
                    if (!market) {
                        if ('coin_pair' in order)
                            if (order['coin_pair'] in this.markets_by_id)
                                market = this.markets_by_id[order['coin_pair']];
                    }
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = undefined;
                    if ('created_timestamp' in order)
                        timestamp = parseInt(order['created_timestamp']) * 1000;
                    if ('updated_timestamp' in order)
                        timestamp = parseInt(order['updated_timestamp']) * 1000;
                    var fee = {
                        'cost': parseFloat(order['fee']),
                        'currency': market['quote'],
                    };
                    var price = this.safeFloat(order, 'limit_price');
                    var average = this.safeFloat(order, 'executed_price_avg');
                    var amount = this.safeFloat(order, 'quantity');
                    var filled = this.safeFloat(order, 'executed_quantity');
                    var remaining = amount - filled;
                    var cost = amount * average;
                    var result = {
                        'info': order,
                        'id': order['order_id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': 'limit',
                        'side': side,
                        'price': price,
                        'cost': cost,
                        'average': average,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': fee,
                    };
                    return result;
                };
                mercado.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' cancelOrder() requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    response = undefined;
                                    return [4, this.privatePostGetOrder(this.extend({
                                            'coin_pair': market['id'],
                                            'order_id': parseInt(id),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response['response_data']['order'])];
                            }
                        });
                    });
                };
                mercado.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, account_ref, tx_fee, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'coin': currency,
                                        'quantity': amount.toFixed(10),
                                        'address': address,
                                    };
                                    if (currency === 'BRL') {
                                        account_ref = ('account_ref' in params);
                                        if (!account_ref)
                                            throw new ExchangeError(this.id + ' requires account_ref parameter to withdraw ' + currency);
                                    }
                                    else if (currency !== 'LTC') {
                                        tx_fee = ('tx_fee' in params);
                                        if (!tx_fee)
                                            throw new ExchangeError(this.id + ' requires tx_fee parameter to withdraw ' + currency);
                                    }
                                    return [4, this.privatePostWithdrawCoin(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['response_data']['withdrawal']['id'],
                                        }];
                            }
                        });
                    });
                };
                mercado.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api] + '/';
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        url += this.implodeParams(path, params);
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        url += this.version + '/';
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({
                            'tapi_method': path,
                            'tapi_nonce': nonce,
                        }, params));
                        var auth = '/tapi/' + this.version + '/' + '?' + body;
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'TAPI-ID': this.apiKey,
                            'TAPI-MAC': this.hmac(this.encode(auth), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                mercado.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('error_message' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return mercado;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 95: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(mixcoins, _super);
                function mixcoins() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                mixcoins.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'mixcoins',
                        'name': 'MixCoins',
                        'countries': ['GB', 'HK'],
                        'rateLimit': 1500,
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/30237212-ed29303c-9535-11e7-8af8-fcd381cfa20c.jpg',
                            'api': 'https://mixcoins.com/api',
                            'www': 'https://mixcoins.com',
                            'doc': 'https://mixcoins.com/help/api/',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'ticker',
                                    'trades',
                                    'depth',
                                ],
                            },
                            'private': {
                                'post': [
                                    'cancel',
                                    'info',
                                    'orders',
                                    'order',
                                    'transactions',
                                    'trade',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'maker': 0.0015, 'taker': 0.0025 },
                            'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.001, 'taker': 0.0015 },
                            'BCH/BTC': { 'id': 'bch_btc', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'maker': 0.001, 'taker': 0.0015 },
                            'LSK/BTC': { 'id': 'lsk_btc', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC', 'maker': 0.0015, 'taker': 0.0025 },
                            'BCH/USD': { 'id': 'bch_usd', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD', 'maker': 0.001, 'taker': 0.0015 },
                            'ETH/USD': { 'id': 'eth_usd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'maker': 0.001, 'taker': 0.0015 },
                        },
                    });
                };
                mixcoins.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balance, result, currencies, i, currency, lowercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostInfo()];
                                case 1:
                                    response = _a.sent();
                                    balance = response['result']['wallet'];
                                    result = { 'info': balance };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        account = this.account();
                                        if (lowercase in balance) {
                                            account['free'] = parseFloat(balance[lowercase]['avail']);
                                            account['used'] = parseFloat(balance[lowercase]['lock']);
                                            account['total'] = this.sum(account['free'], account['used']);
                                        }
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                mixcoins.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetDepth(this.extend({
                                        'market': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseOrderBook(response['result'])];
                            }
                        });
                    });
                };
                mixcoins.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTicker(this.extend({
                                        'market': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    ticker = response['result'];
                                    timestamp = this.milliseconds();
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['buy']),
                                            'ask': parseFloat(ticker['sell']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['vol']),
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                mixcoins.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(trade['date']) * 1000;
                    return {
                        'id': trade['id'].toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': undefined,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                mixcoins.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetTrades(this.extend({
                                            'market': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['result'], market, since, limit)];
                            }
                        });
                    });
                };
                mixcoins.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    order = {
                                        'market': this.marketId(symbol),
                                        'op': side,
                                        'amount': amount,
                                    };
                                    if (type === 'market') {
                                        order['order_type'] = 1;
                                        order['price'] = price;
                                    }
                                    else {
                                        order['order_type'] = 0;
                                    }
                                    return [4, this.privatePostTrade(this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['result']['id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                mixcoins.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancel({ 'id': id })];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                mixcoins.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + path;
                    if (api === 'public') {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({
                            'nonce': nonce,
                        }, params));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Key': this.apiKey,
                            'Sign': this.hmac(this.encode(body), this.secret, 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                mixcoins.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('status' in response)
                                        if (response['status'] === 200)
                                            return [2, response];
                                    throw new ExchangeError(this.id + ' ' + this.json(response));
                            }
                        });
                    });
                };
                return mixcoins;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 96: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(nova, _super);
                function nova() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                nova.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'nova',
                        'name': 'Novaexchange',
                        'countries': 'TZ',
                        'rateLimit': 2000,
                        'version': 'v2',
                        'has': {
                            'CORS': false,
                            'createMarketOrder': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/30518571-78ca0bca-9b8a-11e7-8840-64b83a4a94b2.jpg',
                            'api': 'https://novaexchange.com/remote',
                            'www': 'https://novaexchange.com',
                            'doc': 'https://novaexchange.com/remote/faq',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'markets/',
                                    'markets/{basecurrency}/',
                                    'market/info/{pair}/',
                                    'market/orderhistory/{pair}/',
                                    'market/openorders/{pair}/buy/',
                                    'market/openorders/{pair}/sell/',
                                    'market/openorders/{pair}/both/',
                                    'market/openorders/{pair}/{ordertype}/',
                                ],
                            },
                            'private': {
                                'post': [
                                    'getbalances/',
                                    'getbalance/{currency}/',
                                    'getdeposits/',
                                    'getwithdrawals/',
                                    'getnewdepositaddress/{currency}/',
                                    'getdepositaddress/{currency}/',
                                    'myopenorders/',
                                    'myopenorders_market/{pair}/',
                                    'cancelorder/{orderid}/',
                                    'withdraw/{currency}/',
                                    'trade/{pair}/',
                                    'tradehistory/',
                                    'getdeposithistory/',
                                    'getwithdrawalhistory/',
                                    'walletstatus/',
                                    'walletstatus/{currency}/',
                                ],
                            },
                        },
                    });
                };
                nova.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, i, market, id, _a, quote, base, symbol;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetMarkets()];
                                case 1:
                                    response = _c.sent();
                                    markets = response['markets'];
                                    result = [];
                                    for (i = 0; i < markets.length; i++) {
                                        market = markets[i];
                                        if (!market['disabled']) {
                                            id = market['marketname'];
                                            _a = __read(id.split('_'), 2), quote = _a[0], base = _a[1];
                                            symbol = base + '/' + quote;
                                            result.push({
                                                'id': id,
                                                'symbol': symbol,
                                                'base': base,
                                                'quote': quote,
                                                'info': market,
                                            });
                                        }
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                nova.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetMarketOpenordersPairBoth(this.extend({
                                            'pair': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'buyorders', 'sellorders', 'price', 'amount')];
                            }
                        });
                    });
                };
                nova.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetMarketInfoPair(this.extend({
                                            'pair': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['markets'][0];
                                    timestamp = this.milliseconds();
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high24h']),
                                            'low': parseFloat(ticker['low24h']),
                                            'bid': this.safeFloat(ticker, 'bid'),
                                            'ask': this.safeFloat(ticker, 'ask'),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last_price']),
                                            'change': parseFloat(ticker['change24h']),
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': undefined,
                                            'quoteVolume': parseFloat(ticker['volume24h']),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                nova.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['unix_t_datestamp'] * 1000;
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'id': undefined,
                        'order': undefined,
                        'type': undefined,
                        'side': trade['tradetype'].toLowerCase(),
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                nova.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetMarketOrderhistoryPair(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['items'], market, since, limit)];
                            }
                        });
                    });
                };
                nova.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, lockbox, trades, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetbalances()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['balances'];
                                    result = { 'info': response };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        lockbox = parseFloat(balance['amount_lockbox']);
                                        trades = parseFloat(balance['amount_trades']);
                                        account = {
                                            'free': parseFloat(balance['amount']),
                                            'used': this.sum(lockbox, trades),
                                            'total': parseFloat(balance['amount_total']),
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                nova.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    amount = amount.toString();
                                    price = price.toString();
                                    market = this.market(symbol);
                                    order = {
                                        'tradetype': side.toUpperCase(),
                                        'tradeamount': amount,
                                        'tradeprice': price,
                                        'tradebase': 1,
                                        'pair': market['id'],
                                    };
                                    return [4, this.privatePostTradePair(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                nova.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancelorder(this.extend({
                                        'orderid': id,
                                    }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                nova.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/';
                    if (api === 'private')
                        url += api + '/';
                    url += this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        url += '?' + this.urlencode({ 'nonce': nonce });
                        var signature = this.hmac(this.encode(url), this.encode(this.secret), 'sha512', 'base64');
                        body = this.urlencode(this.extend({
                            'apikey': this.apiKey,
                            'signature': signature,
                        }, query));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                nova.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('status' in response)
                                        if (response['status'] !== 'success')
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return nova;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 97: [function (require, module, exports) {
            'use strict';
            var okcoinusd = require('./okcoinusd.js');
            module.exports = (function (_super) {
                __extends(okcoincny, _super);
                function okcoincny() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                okcoincny.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'okcoincny',
                        'name': 'OKCoin CNY',
                        'countries': 'CN',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766792-8be9157a-5ee5-11e7-926c-6d69b8d3378d.jpg',
                            'api': {
                                'web': 'https://www.okcoin.cn',
                                'public': 'https://www.okcoin.cn/api',
                                'private': 'https://www.okcoin.cn/api',
                            },
                            'www': 'https://www.okcoin.cn',
                            'doc': 'https://www.okcoin.cn/rest_getStarted.html',
                        },
                        'markets': {
                            'BTC/CNY': { 'id': 'btc_cny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                            'LTC/CNY': { 'id': 'ltc_cny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                            'ETH/CNY': { 'id': 'eth_cny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                            'ETC/CNY': { 'id': 'etc_cny', 'symbol': 'ETC/CNY', 'base': 'ETC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                            'BCH/CNY': { 'id': 'bcc_cny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                        },
                    });
                };
                return okcoincny;
            }(okcoinusd));
        }, { "./okcoinusd.js": 98 }], 98: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InsufficientFunds = _a.InsufficientFunds, InvalidOrder = _a.InvalidOrder, OrderNotFound = _a.OrderNotFound, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(okcoinusd, _super);
                function okcoinusd() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                okcoinusd.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'okcoinusd',
                        'name': 'OKCoin USD',
                        'countries': ['CN', 'US'],
                        'version': 'v1',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': false,
                            'fetchOHLCV': true,
                            'fetchOrder': true,
                            'fetchOrders': false,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'withdraw': true,
                            'futures': false,
                        },
                        'extension': '.do',
                        'timeframes': {
                            '1m': '1min',
                            '3m': '3min',
                            '5m': '5min',
                            '15m': '15min',
                            '30m': '30min',
                            '1h': '1hour',
                            '2h': '2hour',
                            '4h': '4hour',
                            '6h': '6hour',
                            '12h': '12hour',
                            '1d': '1day',
                            '3d': '3day',
                            '1w': '1week',
                        },
                        'api': {
                            'web': {
                                'get': [
                                    'markets/currencies',
                                    'markets/products',
                                ],
                            },
                            'public': {
                                'get': [
                                    'depth',
                                    'exchange_rate',
                                    'future_depth',
                                    'future_estimated_price',
                                    'future_hold_amount',
                                    'future_index',
                                    'future_kline',
                                    'future_price_limit',
                                    'future_ticker',
                                    'future_trades',
                                    'kline',
                                    'otcs',
                                    'ticker',
                                    'tickers',
                                    'trades',
                                ],
                            },
                            'private': {
                                'post': [
                                    'account_records',
                                    'batch_trade',
                                    'borrow_money',
                                    'borrow_order_info',
                                    'borrows_info',
                                    'cancel_borrow',
                                    'cancel_order',
                                    'cancel_otc_order',
                                    'cancel_withdraw',
                                    'future_batch_trade',
                                    'future_cancel',
                                    'future_devolve',
                                    'future_explosive',
                                    'future_order_info',
                                    'future_orders_info',
                                    'future_position',
                                    'future_position_4fix',
                                    'future_trade',
                                    'future_trades_history',
                                    'future_userinfo',
                                    'future_userinfo_4fix',
                                    'lend_depth',
                                    'order_fee',
                                    'order_history',
                                    'order_info',
                                    'orders_info',
                                    'otc_order_history',
                                    'otc_order_info',
                                    'repayment',
                                    'submit_otc_order',
                                    'trade',
                                    'trade_history',
                                    'trade_otc_order',
                                    'withdraw',
                                    'withdraw_info',
                                    'unrepayments_info',
                                    'userinfo',
                                ],
                            },
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg',
                            'api': {
                                'web': 'https://www.okcoin.com/v2',
                                'public': 'https://www.okcoin.com/api',
                                'private': 'https://www.okcoin.com/api',
                            },
                            'www': 'https://www.okcoin.com',
                            'doc': [
                                'https://www.okcoin.com/rest_getStarted.html',
                                'https://www.npmjs.com/package/okcoin.com',
                            ],
                        },
                        'fees': {
                            'trading': {
                                'taker': 0.002,
                                'maker': 0.002,
                            },
                        },
                        'exceptions': {
                            '1009': OrderNotFound,
                            '1051': OrderNotFound,
                            '20015': OrderNotFound,
                            '1013': InvalidOrder,
                            '1027': InvalidOrder,
                            '1002': InsufficientFunds,
                            '1050': InvalidOrder,
                            '10000': ExchangeError,
                            '10005': AuthenticationError,
                            '10008': ExchangeError,
                        },
                        'options': {
                            'warnOnFetchOHLCVLimitArgument': true,
                        },
                    });
                };
                okcoinusd.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, markets, result, futureMarkets, i, id, _a, baseId, quoteId, baseIdUppercase, quoteIdUppercase, base, quote, symbol, precision, lot, minAmount, minPrice, market, futureQuote, futureSymbol;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.webGetMarketsProducts()];
                                case 1:
                                    response = _c.sent();
                                    markets = response['data'];
                                    result = [];
                                    futureMarkets = {
                                        'BCH/USD': true,
                                        'BTC/USD': true,
                                        'ETC/USD': true,
                                        'ETH/USD': true,
                                        'LTC/USD': true,
                                    };
                                    for (i = 0; i < markets.length; i++) {
                                        id = markets[i]['symbol'];
                                        _a = __read(id.split('_'), 2), baseId = _a[0], quoteId = _a[1];
                                        baseIdUppercase = baseId.toUpperCase();
                                        quoteIdUppercase = quoteId.toUpperCase();
                                        base = this.commonCurrencyCode(baseIdUppercase);
                                        quote = this.commonCurrencyCode(quoteIdUppercase);
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': markets[i]['maxSizeDigit'],
                                            'price': markets[i]['maxPriceDigit'],
                                        };
                                        lot = Math.pow(10, -precision['amount']);
                                        minAmount = markets[i]['minTradeSize'];
                                        minPrice = Math.pow(10, -precision['price']);
                                        market = this.extend(this.fees['trading'], {
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'info': markets[i],
                                            'type': 'spot',
                                            'spot': true,
                                            'future': false,
                                            'lot': lot,
                                            'active': true,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': minAmount,
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': minPrice,
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': minAmount * minPrice,
                                                    'max': undefined,
                                                },
                                            },
                                        });
                                        result.push(market);
                                        futureQuote = (market['quote'] === 'USDT') ? 'USD' : market['quote'];
                                        futureSymbol = market['base'] + '/' + futureQuote;
                                        if ((this.has['futures']) && (futureSymbol in futureMarkets)) {
                                            result.push(this.extend(market, {
                                                'quote': 'USD',
                                                'symbol': market['base'] + '/USD',
                                                'id': market['id'].replace('usdt', 'usd'),
                                                'quoteId': market['quoteId'].replace('usdt', 'usd'),
                                                'type': 'future',
                                                'spot': false,
                                                'future': true,
                                            }));
                                        }
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                okcoinusd.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'publicGet';
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['size'] = limit;
                                    if (market['future']) {
                                        method += 'Future';
                                        request['contract_type'] = 'this_week';
                                    }
                                    method += 'Depth';
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = this.milliseconds();
                                    return [2, {
                                            'bids': orderbook['bids'],
                                            'asks': this.sortBy(orderbook['asks'], 0),
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                        }];
                            }
                        });
                    });
                };
                okcoinusd.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['timestamp'];
                    var symbol = undefined;
                    if (!market) {
                        if ('symbol' in ticker) {
                            var marketId = ticker['symbol'];
                            if (marketId in this.markets_by_id)
                                market = this.markets_by_id[marketId];
                        }
                    }
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['buy']),
                        'ask': parseFloat(ticker['sell']),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': parseFloat(ticker['last']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['vol']),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                okcoinusd.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, response, timestamp, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'publicGet';
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (market['future']) {
                                        method += 'Future';
                                        request['contract_type'] = 'this_week';
                                    }
                                    method += 'Ticker';
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    timestamp = parseInt(response['date']) * 1000;
                                    ticker = this.extend(response['ticker'], { 'timestamp': timestamp });
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                okcoinusd.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'info': trade,
                        'timestamp': trade['date_ms'],
                        'datetime': this.iso8601(trade['date_ms']),
                        'symbol': symbol,
                        'id': trade['tid'].toString(),
                        'order': undefined,
                        'type': undefined,
                        'side': trade['type'],
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                okcoinusd.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'publicGet';
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    if (market['future']) {
                                        method += 'Future';
                                        request['contract_type'] = 'this_week';
                                    }
                                    method += 'Trades';
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                okcoinusd.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'publicGet';
                                    request = {
                                        'symbol': market['id'],
                                        'type': this.timeframes[timeframe],
                                    };
                                    if (market['future']) {
                                        method += 'Future';
                                        request['contract_type'] = 'this_week';
                                    }
                                    method += 'Kline';
                                    if (typeof limit !== 'undefined') {
                                        if (this.options['warnOnFetchOHLCVLimitArgument'])
                                            throw new ExchangeError(this.id + ' fetchOHLCV counts "limit" candles from current time backwards, therefore the "limit" argument for ' + this.id + ' is disabled. Set ' + this.id + '.options["warnOnFetchOHLCVLimitArgument"] = false to suppress this warning message.');
                                        request['size'] = parseInt(limit);
                                    }
                                    if (typeof since !== 'undefined')
                                        request['since'] = since;
                                    else
                                        request['since'] = this.milliseconds() - 86400000;
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                okcoinusd.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, ids, i, id, code, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostUserinfo()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['info']['funds'];
                                    result = { 'info': response };
                                    ids = Object.keys(this.currencies_by_id);
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        code = this.currencies_by_id[id]['code'];
                                        account = this.account();
                                        account['free'] = this.safeFloat(balances['free'], id, 0.0);
                                        account['used'] = this.safeFloat(balances['freezed'], id, 0.0);
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[code] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                okcoinusd.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'privatePost';
                                    order = {
                                        'symbol': market['id'],
                                        'type': side,
                                    };
                                    if (market['future']) {
                                        method += 'Future';
                                        order = this.extend(order, {
                                            'contract_type': 'this_week',
                                            'match_price': 0,
                                            'lever_rate': 10,
                                            'price': price,
                                            'amount': amount,
                                        });
                                    }
                                    else {
                                        if (type === 'limit') {
                                            order['price'] = price;
                                            order['amount'] = amount;
                                        }
                                        else {
                                            order['type'] += '_market';
                                            if (side === 'buy') {
                                                order['price'] = this.safeFloat(params, 'cost');
                                                if (!order['price'])
                                                    throw new ExchangeError(this.id + ' market buy orders require an additional cost parameter, cost = price * amount');
                                            }
                                            else {
                                                order['amount'] = amount;
                                            }
                                        }
                                    }
                                    params = this.omit(params, 'cost');
                                    method += 'Trade';
                                    return [4, this[method](this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['order_id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                okcoinusd.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, method, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' cancelOrder() requires a symbol argument');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'symbol': market['id'],
                                        'order_id': id,
                                    };
                                    method = 'privatePost';
                                    if (market['future']) {
                                        method += 'FutureCancel';
                                        request['contract_type'] = 'this_week';
                                    }
                                    else {
                                        method += 'CancelOrder';
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, response];
                            }
                        });
                    });
                };
                okcoinusd.prototype.parseOrderStatus = function (status) {
                    if (status === -1)
                        return 'canceled';
                    if (status === 0)
                        return 'open';
                    if (status === 1)
                        return 'open';
                    if (status === 2)
                        return 'closed';
                    if (status === 4)
                        return 'canceled';
                    return status;
                };
                okcoinusd.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = undefined;
                    var type = undefined;
                    if ('type' in order) {
                        if ((order['type'] === 'buy') || (order['type'] === 'sell')) {
                            side = order['type'];
                            type = 'limit';
                        }
                        else {
                            side = (order['type'] === 'buy_market') ? 'buy' : 'sell';
                            type = 'market';
                        }
                    }
                    var status = this.parseOrderStatus(order['status']);
                    var symbol = undefined;
                    if (!market) {
                        if ('symbol' in order)
                            if (order['symbol'] in this.markets_by_id)
                                market = this.markets_by_id[order['symbol']];
                    }
                    if (market)
                        symbol = market['symbol'];
                    var timestamp = undefined;
                    var createDateField = this.getCreateDateField();
                    if (createDateField in order)
                        timestamp = order[createDateField];
                    var amount = order['amount'];
                    var filled = order['deal_amount'];
                    var remaining = amount - filled;
                    var average = order['avg_price'];
                    var cost = average * filled;
                    var result = {
                        'info': order,
                        'id': order['order_id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': order['price'],
                        'average': average,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': undefined,
                    };
                    return result;
                };
                okcoinusd.prototype.getCreateDateField = function () {
                    return 'create_date';
                };
                okcoinusd.prototype.getOrdersField = function () {
                    return 'orders';
                };
                okcoinusd.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, response, ordersField, numOrders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOrder requires a symbol parameter');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'privatePost';
                                    request = {
                                        'order_id': id,
                                        'symbol': market['id'],
                                    };
                                    if (market['future']) {
                                        method += 'Future';
                                        request['contract_type'] = 'this_week';
                                    }
                                    method += 'OrderInfo';
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    ordersField = this.getOrdersField();
                                    numOrders = response[ordersField].length;
                                    if (numOrders > 0)
                                        return [2, this.parseOrder(response[ordersField][0])];
                                    throw new OrderNotFound(this.id + ' order ' + id + ' not found');
                            }
                        });
                    });
                };
                okcoinusd.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, request, order_id_in_params, status_6, name_3, response, ordersField;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + ' fetchOrders requires a symbol parameter');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'privatePost';
                                    request = {
                                        'symbol': market['id'],
                                    };
                                    order_id_in_params = ('order_id' in params);
                                    if (market['future']) {
                                        method += 'FutureOrdersInfo';
                                        request['contract_type'] = 'this_week';
                                        if (!order_id_in_params)
                                            throw new ExchangeError(this.id + ' fetchOrders() requires order_id param for futures market ' + symbol + ' (a string of one or more order ids, comma-separated)');
                                    }
                                    else {
                                        status_6 = undefined;
                                        if ('type' in params) {
                                            status_6 = params['type'];
                                        }
                                        else if ('status' in params) {
                                            status_6 = params['status'];
                                        }
                                        else {
                                            name_3 = order_id_in_params ? 'type' : 'status';
                                            throw new ExchangeError(this.id + ' fetchOrders() requires ' + name_3 + ' param for spot market ' + symbol + ' (0 - for unfilled orders, 1 - for filled/canceled orders)');
                                        }
                                        if (order_id_in_params) {
                                            method += 'OrdersInfo';
                                            request = this.extend(request, {
                                                'type': status_6,
                                            });
                                        }
                                        else {
                                            method += 'OrderHistory';
                                            request = this.extend(request, {
                                                'status': status_6,
                                                'current_page': 1,
                                                'page_length': 200,
                                            });
                                        }
                                        params = this.omit(params, ['type', 'status']);
                                    }
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    ordersField = this.getOrdersField();
                                    return [2, this.parseOrders(response[ordersField], market, since, limit)];
                            }
                        });
                    });
                };
                okcoinusd.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var open;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    open = 0;
                                    return [4, this.fetchOrders(symbol, undefined, undefined, this.extend({
                                            'status': open,
                                        }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                okcoinusd.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var closed, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    closed = 1;
                                    return [4, this.fetchOrders(symbol, undefined, undefined, this.extend({
                                            'status': closed,
                                        }, params))];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.filterBy(orders, 'status', 'closed')];
                            }
                        });
                    });
                };
                okcoinusd.prototype.withdraw = function (code, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, currencyId, request, query, passwordInRequest, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    currencyId = currency['id'] + '_usd';
                                    request = {
                                        'symbol': currencyId,
                                        'withdraw_address': address,
                                        'withdraw_amount': amount,
                                        'target': 'address',
                                    };
                                    query = params;
                                    if ('chargefee' in query) {
                                        request['chargefee'] = query['chargefee'];
                                        query = this.omit(query, 'chargefee');
                                    }
                                    else {
                                        throw new ExchangeError(this.id + ' withdraw() requires a `chargefee` parameter');
                                    }
                                    if (this.password) {
                                        request['trade_pwd'] = this.password;
                                    }
                                    else if ('password' in query) {
                                        request['trade_pwd'] = query['password'];
                                        query = this.omit(query, 'password');
                                    }
                                    else if ('trade_pwd' in query) {
                                        request['trade_pwd'] = query['trade_pwd'];
                                        query = this.omit(query, 'trade_pwd');
                                    }
                                    passwordInRequest = ('trade_pwd' in request);
                                    if (!passwordInRequest)
                                        throw new ExchangeError(this.id + ' withdraw() requires this.password set on the exchange instance or a password / trade_pwd parameter');
                                    return [4, this.privatePostWithdraw(this.extend(request, query))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': this.safeString(response, 'withdraw_id'),
                                        }];
                            }
                        });
                    });
                };
                okcoinusd.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = '/';
                    if (api !== 'web')
                        url += this.version + '/';
                    url += path + this.extension;
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var query = this.keysort(this.extend({
                            'api_key': this.apiKey,
                        }, params));
                        var queryString = this.rawencode(query) + '&secret_key=' + this.secret;
                        query['sign'] = this.hash(this.encode(queryString)).toUpperCase();
                        body = this.urlencode(query);
                        headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
                    }
                    else {
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    url = this.urls['api'][api] + url;
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                okcoinusd.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (body.length < 2)
                        return;
                    if (body[0] === '{') {
                        var response = JSON.parse(body);
                        if ('error_code' in response) {
                            var error = this.safeString(response, 'error_code');
                            var message = this.id + ' ' + this.json(response);
                            if (error in this.exceptions) {
                                var ExceptionClass = this.exceptions[error];
                                throw new ExceptionClass(message);
                            }
                            else {
                                throw new ExchangeError(message);
                            }
                        }
                        if ('result' in response)
                            if (!response['result'])
                                throw new ExchangeError(this.id + ' ' + this.json(response));
                    }
                };
                return okcoinusd;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 99: [function (require, module, exports) {
            'use strict';
            var okcoinusd = require('./okcoinusd.js');
            module.exports = (function (_super) {
                __extends(okex, _super);
                function okex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                okex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'okex',
                        'name': 'OKEX',
                        'countries': ['CN', 'US'],
                        'has': {
                            'CORS': false,
                            'futures': true,
                            'fetchTickers': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg',
                            'api': {
                                'web': 'https://www.okex.com/v2',
                                'public': 'https://www.okex.com/api',
                                'private': 'https://www.okex.com/api',
                            },
                            'www': 'https://www.okex.com',
                            'doc': 'https://www.okex.com/rest_getStarted.html',
                            'fees': 'https://www.okex.com/fees.html',
                        },
                    });
                };
                okex.prototype.commonCurrencyCode = function (currency) {
                    var currencies = {
                        'FAIR': 'FairGame',
                        'HMC': 'Hi Mutual Society',
                        'MAG': 'Maggie',
                        'NANO': 'XRB',
                        'YOYO': 'YOYOW',
                    };
                    if (currency in currencies)
                        return currencies[currency];
                    return currency;
                };
                okex.prototype.calculateFee = function (symbol, type, side, amount, price, takerOrMaker, params) {
                    if (takerOrMaker === void 0) { takerOrMaker = 'taker'; }
                    if (params === void 0) { params = {}; }
                    var market = this.markets[symbol];
                    var key = 'quote';
                    var rate = market[takerOrMaker];
                    var cost = parseFloat(this.costToPrecision(symbol, amount * rate));
                    if (side === 'sell') {
                        cost *= price;
                    }
                    else {
                        key = 'base';
                    }
                    return {
                        'type': takerOrMaker,
                        'currency': market[key],
                        'rate': rate,
                        'cost': parseFloat(this.feeToPrecision(symbol, cost)),
                    };
                };
                okex.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, _super.prototype.fetchMarkets.call(this)];
                                case 1:
                                    markets = _a.sent();
                                    for (i = 0; i < markets.length; i++) {
                                        if (markets[i]['spot']) {
                                            markets[i]['maker'] = 0.0015;
                                            markets[i]['taker'] = 0.0020;
                                        }
                                        else {
                                            markets[i]['maker'] = 0.0003;
                                            markets[i]['taker'] = 0.0005;
                                        }
                                    }
                                    return [2, markets];
                            }
                        });
                    });
                };
                okex.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, tickers, timestamp, result, i, ticker, market, marketId, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {};
                                    return [4, this.publicGetTickers(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    tickers = response['tickers'];
                                    timestamp = parseInt(response['date']) * 1000;
                                    result = {};
                                    for (i = 0; i < tickers.length; i++) {
                                        ticker = tickers[i];
                                        market = undefined;
                                        if ('symbol' in ticker) {
                                            marketId = ticker['symbol'];
                                            if (marketId in this.markets_by_id)
                                                market = this.markets_by_id[marketId];
                                        }
                                        ticker = this.parseTicker(this.extend(tickers[i], { 'timestamp': timestamp }), market);
                                        symbol = ticker['symbol'];
                                        result[symbol] = ticker;
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                return okex;
            }(okcoinusd));
        }, { "./okcoinusd.js": 98 }], 100: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(paymium, _super);
                function paymium() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                paymium.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'paymium',
                        'name': 'Paymium',
                        'countries': ['FR', 'EU'],
                        'rateLimit': 2000,
                        'version': 'v1',
                        'has': {
                            'CORS': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27790564-a945a9d4-5ff9-11e7-9d2d-b635763f2f24.jpg',
                            'api': 'https://paymium.com/api',
                            'www': 'https://www.paymium.com',
                            'doc': [
                                'https://github.com/Paymium/api-documentation',
                                'https://www.paymium.com/page/developers',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'countries',
                                    'data/{id}/ticker',
                                    'data/{id}/trades',
                                    'data/{id}/depth',
                                    'bitcoin_charts/{id}/trades',
                                    'bitcoin_charts/{id}/depth',
                                ],
                            },
                            'private': {
                                'get': [
                                    'merchant/get_payment/{UUID}',
                                    'user',
                                    'user/addresses',
                                    'user/addresses/{btc_address}',
                                    'user/orders',
                                    'user/orders/{UUID}',
                                    'user/price_alerts',
                                ],
                                'post': [
                                    'user/orders',
                                    'user/addresses',
                                    'user/payment_requests',
                                    'user/price_alerts',
                                    'merchant/create_payment',
                                ],
                                'delete': [
                                    'user/orders/{UUID}/cancel',
                                    'user/price_alerts/{id}',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/EUR': { 'id': 'eur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.0059,
                                'taker': 0.0059,
                            },
                        },
                    });
                };
                paymium.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, currencies, i, currency, lowercase, account, balance, locked;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetUser()];
                                case 1:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        account = this.account();
                                        balance = 'balance_' + lowercase;
                                        locked = 'locked_' + lowercase;
                                        if (balance in balances)
                                            account['free'] = balances[balance];
                                        if (locked in balances)
                                            account['used'] = balances[locked];
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                paymium.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetDataIdDepth(this.extend({
                                        'id': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    result = this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'price', 'amount');
                                    result['bids'] = this.sortBy(result['bids'], 0, true);
                                    return [2, result];
                            }
                        });
                    });
                };
                paymium.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp, vwap, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetDataIdTicker(this.extend({
                                        'id': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = ticker['at'] * 1000;
                                    vwap = parseFloat(ticker['vwap']);
                                    baseVolume = parseFloat(ticker['volume']);
                                    quoteVolume = baseVolume * vwap;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': this.safeFloat(ticker, 'high'),
                                            'low': this.safeFloat(ticker, 'low'),
                                            'bid': this.safeFloat(ticker, 'bid'),
                                            'ask': this.safeFloat(ticker, 'ask'),
                                            'vwap': vwap,
                                            'open': this.safeFloat(ticker, 'open'),
                                            'close': undefined,
                                            'first': undefined,
                                            'last': this.safeFloat(ticker, 'price'),
                                            'change': undefined,
                                            'percentage': this.safeFloat(ticker, 'variation'),
                                            'average': undefined,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                paymium.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(trade['created_at_int']) * 1000;
                    var volume = 'traded_' + market['base'].toLowerCase();
                    return {
                        'info': trade,
                        'id': trade['uuid'],
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['side'],
                        'price': trade['price'],
                        'amount': trade[volume],
                    };
                };
                paymium.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetDataIdTrades(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                paymium.prototype.createOrder = function (market, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    order = {
                                        'type': this.capitalize(type) + 'Order',
                                        'currency': this.marketId(market),
                                        'direction': side,
                                        'amount': amount,
                                    };
                                    if (type === 'market')
                                        order['price'] = price;
                                    return [4, this.privatePostUserOrders(this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['uuid'],
                                        }];
                            }
                        });
                    });
                };
                paymium.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancelOrder(this.extend({
                                        'orderNumber': id,
                                    }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                paymium.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        body = this.json(params);
                        var nonce = this.nonce().toString();
                        var auth = nonce + url + body;
                        headers = {
                            'Api-Key': this.apiKey,
                            'Api-Signature': this.hmac(this.encode(auth), this.encode(this.secret)),
                            'Api-Nonce': nonce,
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                paymium.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('errors' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return paymium;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 101: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError, DDoSProtection = _a.DDoSProtection, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound, OrderNotCached = _a.OrderNotCached, InvalidOrder = _a.InvalidOrder, CancelPending = _a.CancelPending, InvalidNonce = _a.InvalidNonce;
            module.exports = (function (_super) {
                __extends(poloniex, _super);
                function poloniex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                poloniex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'poloniex',
                        'name': 'Poloniex',
                        'countries': 'US',
                        'rateLimit': 1000,
                        'has': {
                            'createDepositAddress': true,
                            'fetchDepositAddress': true,
                            'CORS': false,
                            'editOrder': true,
                            'createMarketOrder': false,
                            'fetchOHLCV': true,
                            'fetchMyTrades': true,
                            'fetchOrder': 'emulated',
                            'fetchOrders': 'emulated',
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': 'emulated',
                            'fetchTickers': true,
                            'fetchCurrencies': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '5m': 300,
                            '15m': 900,
                            '30m': 1800,
                            '2h': 7200,
                            '4h': 14400,
                            '1d': 86400,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg',
                            'api': {
                                'public': 'https://poloniex.com/public',
                                'private': 'https://poloniex.com/tradingApi',
                            },
                            'www': 'https://poloniex.com',
                            'doc': [
                                'https://poloniex.com/support/api/',
                                'http://pastebin.com/dMX7mZE0',
                            ],
                            'fees': 'https://poloniex.com/fees',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'return24hVolume',
                                    'returnChartData',
                                    'returnCurrencies',
                                    'returnLoanOrders',
                                    'returnOrderBook',
                                    'returnTicker',
                                    'returnTradeHistory',
                                ],
                            },
                            'private': {
                                'post': [
                                    'buy',
                                    'cancelLoanOffer',
                                    'cancelOrder',
                                    'closeMarginPosition',
                                    'createLoanOffer',
                                    'generateNewAddress',
                                    'getMarginPosition',
                                    'marginBuy',
                                    'marginSell',
                                    'moveOrder',
                                    'returnActiveLoans',
                                    'returnAvailableAccountBalances',
                                    'returnBalances',
                                    'returnCompleteBalances',
                                    'returnDepositAddresses',
                                    'returnDepositsWithdrawals',
                                    'returnFeeInfo',
                                    'returnLendingHistory',
                                    'returnMarginAccountSummary',
                                    'returnOpenLoanOffers',
                                    'returnOpenOrders',
                                    'returnOrderTrades',
                                    'returnTradableBalances',
                                    'returnTradeHistory',
                                    'sell',
                                    'toggleAutoRenew',
                                    'transferBalance',
                                    'withdraw',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.0015,
                                'taker': 0.0025,
                            },
                            'funding': {},
                        },
                        'limits': {
                            'amount': {
                                'min': 0.00000001,
                                'max': 1000000000,
                            },
                            'price': {
                                'min': 0.00000001,
                                'max': 1000000000,
                            },
                            'cost': {
                                'min': 0.00000000,
                                'max': 1000000000,
                            },
                        },
                        'precision': {
                            'amount': 8,
                            'price': 8,
                        },
                    });
                };
                poloniex.prototype.calculateFee = function (symbol, type, side, amount, price, takerOrMaker, params) {
                    if (takerOrMaker === void 0) { takerOrMaker = 'taker'; }
                    if (params === void 0) { params = {}; }
                    var market = this.markets[symbol];
                    var key = 'quote';
                    var rate = market[takerOrMaker];
                    var cost = parseFloat(this.costToPrecision(symbol, amount * rate));
                    if (side === 'sell') {
                        cost *= price;
                    }
                    else {
                        key = 'base';
                    }
                    return {
                        'type': takerOrMaker,
                        'currency': market[key],
                        'rate': rate,
                        'cost': parseFloat(this.feeToPrecision(symbol, cost)),
                    };
                };
                poloniex.prototype.commonCurrencyCode = function (currency) {
                    if (currency === 'BTM')
                        return 'Bitmark';
                    if (currency === 'STR')
                        return 'XLM';
                    return currency;
                };
                poloniex.prototype.currencyId = function (currency) {
                    if (currency === 'Bitmark')
                        return 'BTM';
                    if (currency === 'XLM')
                        return 'STR';
                    return currency;
                };
                poloniex.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '5m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv['date'] * 1000,
                        ohlcv['open'],
                        ohlcv['high'],
                        ohlcv['low'],
                        ohlcv['close'],
                        ohlcv['quoteVolume'],
                    ];
                };
                poloniex.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '5m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    if (!since)
                                        since = 0;
                                    request = {
                                        'currencyPair': market['id'],
                                        'period': this.timeframes[timeframe],
                                        'start': parseInt(since / 1000),
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['end'] = this.sum(request['start'], limit * this.timeframes[timeframe]);
                                    return [4, this.publicGetReturnChartData(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response, market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, keys, result, p, id, market, _a, quote, base, symbol;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetReturnTicker()];
                                case 1:
                                    markets = _c.sent();
                                    keys = Object.keys(markets);
                                    result = [];
                                    for (p = 0; p < keys.length; p++) {
                                        id = keys[p];
                                        market = markets[id];
                                        _a = __read(id.split('_'), 2), quote = _a[0], base = _a[1];
                                        base = this.commonCurrencyCode(base);
                                        quote = this.commonCurrencyCode(quote);
                                        symbol = base + '/' + quote;
                                        result.push(this.extend(this.fees['trading'], {
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'active': true,
                                            'lot': this.limits['amount']['min'],
                                            'info': market,
                                        }));
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, currencies, c, id, balance, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostReturnCompleteBalances(this.extend({
                                            'account': 'all',
                                        }, params))];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    currencies = Object.keys(balances);
                                    for (c = 0; c < currencies.length; c++) {
                                        id = currencies[c];
                                        balance = balances[id];
                                        currency = this.commonCurrencyCode(id);
                                        account = {
                                            'free': parseFloat(balance['available']),
                                            'used': parseFloat(balance['onOrders']),
                                            'total': 0.0,
                                        };
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchFees = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var fees;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostReturnFeeInfo()];
                                case 2:
                                    fees = _a.sent();
                                    return [2, {
                                            'info': fees,
                                            'maker': parseFloat(fees['makerFee']),
                                            'taker': parseFloat(fees['takerFee']),
                                            'withdraw': {},
                                            'deposit': {},
                                        }];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'currencyPair': this.marketId(symbol),
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['depth'] = limit;
                                    return [4, this.publicGetReturnOrderBook(this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                poloniex.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var open = undefined;
                    var change = undefined;
                    var average = undefined;
                    var last = parseFloat(ticker['last']);
                    var relativeChange = parseFloat(ticker['percentChange']);
                    if (relativeChange !== -1) {
                        open = last / this.sum(1, relativeChange);
                        change = last - open;
                        average = this.sum(last, open) / 2;
                    }
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high24hr']),
                        'low': parseFloat(ticker['low24hr']),
                        'bid': parseFloat(ticker['highestBid']),
                        'ask': parseFloat(ticker['lowestAsk']),
                        'vwap': undefined,
                        'open': open,
                        'close': last,
                        'last': last,
                        'previousClose': undefined,
                        'change': change,
                        'percentage': relativeChange * 100,
                        'average': average,
                        'baseVolume': parseFloat(ticker['quoteVolume']),
                        'quoteVolume': parseFloat(ticker['baseVolume']),
                        'info': ticker,
                    };
                };
                poloniex.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, ids, result, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetReturnTicker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencies, ids, result, i, id, currency, precision, code, active, status_7;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetReturnCurrencies(params)];
                                case 1:
                                    currencies = _a.sent();
                                    ids = Object.keys(currencies);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        currency = currencies[id];
                                        precision = 8;
                                        code = this.commonCurrencyCode(id);
                                        active = (currency['delisted'] === 0);
                                        status_7 = (currency['disabled']) ? 'disabled' : 'ok';
                                        if (status_7 !== 'ok')
                                            active = false;
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'info': currency,
                                            'name': currency['name'],
                                            'active': active,
                                            'status': status_7,
                                            'fee': this.safeFloat(currency, 'txFee'),
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': currency['txFee'],
                                                    'max': Math.pow(10, precision),
                                                },
                                            },
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, tickers, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetReturnTicker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    ticker = tickers[market['id']];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                poloniex.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(trade['date']);
                    var symbol = undefined;
                    var base = undefined;
                    var quote = undefined;
                    if ((!market) && ('currencyPair' in trade)) {
                        var currencyPair = trade['currencyPair'];
                        if (currencyPair in this.markets_by_id) {
                            market = this.markets_by_id[currencyPair];
                        }
                        else {
                            var parts = currencyPair.split('_');
                            quote = parts[0];
                            base = parts[1];
                            symbol = base + '/' + quote;
                        }
                    }
                    if (market) {
                        symbol = market['symbol'];
                        base = market['base'];
                        quote = market['quote'];
                    }
                    var side = trade['type'];
                    var fee = undefined;
                    var cost = this.safeFloat(trade, 'total');
                    var amount = parseFloat(trade['amount']);
                    if ('fee' in trade) {
                        var rate = parseFloat(trade['fee']);
                        var feeCost = undefined;
                        var currency = undefined;
                        if (side === 'buy') {
                            currency = base;
                            feeCost = amount * rate;
                        }
                        else {
                            currency = quote;
                            if (typeof cost !== 'undefined')
                                feeCost = cost * rate;
                        }
                        fee = {
                            'type': undefined,
                            'rate': rate,
                            'cost': feeCost,
                            'currency': currency,
                        };
                    }
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'id': this.safeString(trade, 'tradeID'),
                        'order': this.safeString(trade, 'orderNumber'),
                        'type': 'limit',
                        'side': side,
                        'price': parseFloat(trade['rate']),
                        'amount': amount,
                        'cost': cost,
                        'fee': fee,
                    };
                };
                poloniex.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'currencyPair': market['id'],
                                    };
                                    if (typeof since !== 'undefined') {
                                        request['start'] = parseInt(since / 1000);
                                        request['end'] = this.seconds();
                                    }
                                    return [4, this.publicGetReturnTradeHistory(this.extend(request, params))];
                                case 2:
                                    trades = _a.sent();
                                    return [2, this.parseTrades(trades, market, since, limit)];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchMyTrades = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, pair, request, response, result, ids, i, id, market_2, trades, j;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (symbol)
                                        market = this.market(symbol);
                                    pair = market ? market['id'] : 'all';
                                    request = { 'currencyPair': pair };
                                    if (typeof since !== 'undefined') {
                                        request['start'] = parseInt(since / 1000);
                                        request['end'] = this.seconds();
                                    }
                                    return [4, this.privatePostReturnTradeHistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    result = [];
                                    if (market) {
                                        result = this.parseTrades(response, market);
                                    }
                                    else {
                                        if (response) {
                                            ids = Object.keys(response);
                                            for (i = 0; i < ids.length; i++) {
                                                id = ids[i];
                                                market_2 = undefined;
                                                if (id in this.markets_by_id)
                                                    market_2 = this.markets_by_id[id];
                                                trades = this.parseTrades(response[id], market_2);
                                                for (j = 0; j < trades.length; j++) {
                                                    result.push(trades[j]);
                                                }
                                            }
                                        }
                                    }
                                    return [2, this.filterBySinceLimit(result, since, limit)];
                            }
                        });
                    });
                };
                poloniex.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.safeInteger(order, 'timestamp');
                    if (!timestamp)
                        timestamp = this.parse8601(order['date']);
                    var trades = undefined;
                    if ('resultingTrades' in order)
                        trades = this.parseTrades(order['resultingTrades'], market);
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var price = this.safeFloat(order, 'price');
                    var cost = this.safeFloat(order, 'total', 0.0);
                    var remaining = this.safeFloat(order, 'amount');
                    var amount = this.safeFloat(order, 'startingAmount', remaining);
                    var filled = undefined;
                    if (typeof amount !== 'undefined') {
                        if (typeof remaining !== 'undefined')
                            filled = amount - remaining;
                    }
                    if (typeof filled === 'undefined') {
                        if (typeof trades !== 'undefined') {
                            filled = 0;
                            cost = 0;
                            for (var i = 0; i < trades.length; i++) {
                                var trade = trades[i];
                                var tradeAmount = trade['amount'];
                                var tradePrice = trade['price'];
                                filled = this.sum(filled, tradeAmount);
                                cost += tradePrice * tradeAmount;
                            }
                        }
                    }
                    return {
                        'info': order,
                        'id': order['orderNumber'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': order['status'],
                        'symbol': symbol,
                        'type': order['type'],
                        'side': order['side'],
                        'price': price,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'trades': trades,
                        'fee': undefined,
                    };
                };
                poloniex.prototype.parseOpenOrders = function (orders, market, result) {
                    if (result === void 0) { result = []; }
                    for (var i = 0; i < orders.length; i++) {
                        var order = orders[i];
                        var extended = this.extend(order, {
                            'status': 'open',
                            'type': 'limit',
                            'side': order['type'],
                            'price': order['rate'],
                        });
                        result.push(this.parseOrder(extended, market));
                    }
                    return result;
                };
                poloniex.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, pair, response, openOrders, marketIds, i, marketId, orders, m, j, openOrdersIndexedById, cachedOrderIds, result, k, id, order_2, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (symbol)
                                        market = this.market(symbol);
                                    pair = market ? market['id'] : 'all';
                                    return [4, this.privatePostReturnOpenOrders(this.extend({
                                            'currencyPair': pair,
                                        }))];
                                case 2:
                                    response = _a.sent();
                                    openOrders = [];
                                    if (market) {
                                        openOrders = this.parseOpenOrders(response, market, openOrders);
                                    }
                                    else {
                                        marketIds = Object.keys(response);
                                        for (i = 0; i < marketIds.length; i++) {
                                            marketId = marketIds[i];
                                            orders = response[marketId];
                                            m = this.markets_by_id[marketId];
                                            openOrders = this.parseOpenOrders(orders, m, openOrders);
                                        }
                                    }
                                    for (j = 0; j < openOrders.length; j++) {
                                        this.orders[openOrders[j]['id']] = openOrders[j];
                                    }
                                    openOrdersIndexedById = this.indexBy(openOrders, 'id');
                                    cachedOrderIds = Object.keys(this.orders);
                                    result = [];
                                    for (k = 0; k < cachedOrderIds.length; k++) {
                                        id = cachedOrderIds[k];
                                        if (id in openOrdersIndexedById) {
                                            this.orders[id] = this.extend(this.orders[id], openOrdersIndexedById[id]);
                                        }
                                        else {
                                            order_2 = this.orders[id];
                                            if (order_2['status'] === 'open') {
                                                order_2 = this.extend(order_2, {
                                                    'status': 'closed',
                                                    'cost': undefined,
                                                    'filled': order_2['amount'],
                                                    'remaining': 0.0,
                                                });
                                                if (typeof order_2['cost'] === 'undefined') {
                                                    if (typeof order_2['filled'] !== 'undefined')
                                                        order_2['cost'] = order_2['filled'] * order_2['price'];
                                                }
                                                this.orders[id] = order_2;
                                            }
                                        }
                                        order = this.orders[id];
                                        if (market) {
                                            if (order['symbol'] === symbol)
                                                result.push(order);
                                        }
                                        else {
                                            result.push(order);
                                        }
                                    }
                                    return [2, this.filterBySinceLimit(result, since, limit)];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var since, limit, request, orders, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    since = this.safeValue(params, 'since');
                                    limit = this.safeValue(params, 'limit');
                                    request = this.omit(params, ['since', 'limit']);
                                    return [4, this.fetchOrders(symbol, since, limit, request)];
                                case 1:
                                    orders = _a.sent();
                                    for (i = 0; i < orders.length; i++) {
                                        if (orders[i]['id'] === id)
                                            return [2, orders[i]];
                                    }
                                    throw new OrderNotCached(this.id + ' order id ' + id.toString() + ' is not in "open" state and not found in cache');
                            }
                        });
                    });
                };
                poloniex.prototype.filterOrdersByStatus = function (orders, status) {
                    var result = [];
                    for (var i = 0; i < orders.length; i++) {
                        if (orders[i]['status'] === status)
                            result.push(orders[i]);
                    }
                    return result;
                };
                poloniex.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.filterOrdersByStatus(orders, 'open')];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchOrders(symbol, since, limit, params)];
                                case 1:
                                    orders = _a.sent();
                                    return [2, this.filterOrdersByStatus(orders, 'closed')];
                            }
                        });
                    });
                };
                poloniex.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, market, response, timestamp, order, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    method = 'privatePost' + this.capitalize(side);
                                    market = this.market(symbol);
                                    price = parseFloat(price);
                                    amount = parseFloat(amount);
                                    return [4, this[method](this.extend({
                                            'currencyPair': market['id'],
                                            'rate': this.priceToPrecision(symbol, price),
                                            'amount': this.amountToPrecision(symbol, amount),
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    timestamp = this.milliseconds();
                                    order = this.parseOrder(this.extend({
                                        'timestamp': timestamp,
                                        'status': 'open',
                                        'type': type,
                                        'side': side,
                                        'price': price,
                                        'amount': amount,
                                    }, response), market);
                                    id = order['id'];
                                    this.orders[id] = order;
                                    return [2, this.extend({ 'info': response }, order)];
                            }
                        });
                    });
                };
                poloniex.prototype.editOrder = function (id, symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, result, newid, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    price = parseFloat(price);
                                    request = {
                                        'orderNumber': id,
                                        'rate': this.priceToPrecision(symbol, price),
                                    };
                                    if (typeof amount !== 'undefined') {
                                        amount = parseFloat(amount);
                                        request['amount'] = this.amountToPrecision(symbol, amount);
                                    }
                                    return [4, this.privatePostMoveOrder(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    result = undefined;
                                    if (id in this.orders) {
                                        this.orders[id]['status'] = 'canceled';
                                        newid = response['orderNumber'];
                                        this.orders[newid] = this.extend(this.orders[id], {
                                            'id': newid,
                                            'price': price,
                                            'status': 'open',
                                        });
                                        if (typeof amount !== 'undefined')
                                            this.orders[newid]['amount'] = amount;
                                        result = this.extend(this.orders[newid], { 'info': response });
                                    }
                                    else {
                                        market = undefined;
                                        if (symbol)
                                            market = this.market(symbol);
                                        result = this.parseOrder(response, market);
                                        this.orders[result['id']] = result;
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                poloniex.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, e_21;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    response = undefined;
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 4, , 5]);
                                    return [4, this.privatePostCancelOrder(this.extend({
                                            'orderNumber': id,
                                        }, params))];
                                case 3:
                                    response = _a.sent();
                                    return [3, 5];
                                case 4:
                                    e_21 = _a.sent();
                                    if (e_21 instanceof CancelPending) {
                                        if (id in this.orders)
                                            this.orders[id]['status'] = 'canceled';
                                    }
                                    throw e_21;
                                case 5:
                                    if (id in this.orders)
                                        this.orders[id]['status'] = 'canceled';
                                    return [2, response];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchOrderStatus = function (id, symbol) {
                    if (symbol === void 0) { symbol = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orders, indexed;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.fetchOpenOrders(symbol)];
                                case 2:
                                    orders = _a.sent();
                                    indexed = this.indexBy(orders, 'id');
                                    return [2, (id in indexed) ? 'open' : 'closed'];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchOrderTrades = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostReturnOrderTrades(this.extend({
                                            'orderNumber': id,
                                        }, params))];
                                case 2:
                                    trades = _a.sent();
                                    return [2, this.parseTrades(trades)];
                            }
                        });
                    });
                };
                poloniex.prototype.createDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencyId, response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    currencyId = this.currencyId(currency);
                                    return [4, this.privatePostGenerateNewAddress({
                                            'currency': currencyId,
                                        })];
                                case 1:
                                    response = _a.sent();
                                    address = undefined;
                                    if (response['success'] === 1)
                                        address = this.safeString(response, 'response');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                poloniex.prototype.fetchDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, currencyId, address, status;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostReturnDepositAddresses()];
                                case 1:
                                    response = _a.sent();
                                    currencyId = this.currencyId(currency);
                                    address = this.safeString(response, currencyId);
                                    this.checkAddress(address);
                                    status = address ? 'ok' : 'none';
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'status': status,
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                poloniex.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencyId, request, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currencyId = this.currencyId(currency);
                                    request = {
                                        'currency': currencyId,
                                        'amount': amount,
                                        'address': address,
                                    };
                                    if (tag)
                                        request['paymentId'] = tag;
                                    return [4, this.privatePostWithdraw(this.extend(request, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result['response'],
                                        }];
                            }
                        });
                    });
                };
                poloniex.prototype.nonce = function () {
                    return this.milliseconds();
                };
                poloniex.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    var query = this.extend({ 'command': path }, params);
                    if (api === 'public') {
                        url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        query['nonce'] = this.nonce();
                        body = this.urlencode(query);
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Key': this.apiKey,
                            'Sign': this.hmac(this.encode(body), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                poloniex.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    var response = undefined;
                    try {
                        response = JSON.parse(body);
                    }
                    catch (e) {
                        return;
                    }
                    if ('error' in response) {
                        var error = response['error'];
                        var feedback = this.id + ' ' + this.json(response);
                        if (error === 'Invalid order number, or you are not the person who placed the order.') {
                            throw new OrderNotFound(feedback);
                        }
                        else if (error === 'Order not found, or you are not the person who placed it.') {
                            throw new OrderNotFound(feedback);
                        }
                        else if (error === 'Invalid API key/secret pair.') {
                            throw new AuthenticationError(feedback);
                        }
                        else if (error === 'Please do not make more than 8 API calls per second.') {
                            throw new DDoSProtection(feedback);
                        }
                        else if (error.indexOf('Total must be at least') >= 0) {
                            throw new InvalidOrder(feedback);
                        }
                        else if (error.indexOf('Not enough') >= 0) {
                            throw new InsufficientFunds(feedback);
                        }
                        else if (error.indexOf('Nonce must be greater') >= 0) {
                            throw new InvalidNonce(feedback);
                        }
                        else if (error.indexOf('You have already called cancelOrder or moveOrder on this order.') >= 0) {
                            throw new CancelPending(feedback);
                        }
                        else {
                            throw new ExchangeError(this.id + ': unknown error: ' + this.json(response));
                        }
                    }
                };
                return poloniex;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 102: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), InvalidNonce = _a.InvalidNonce, OrderNotFound = _a.OrderNotFound, InvalidOrder = _a.InvalidOrder, InsufficientFunds = _a.InsufficientFunds, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(qryptos, _super);
                function qryptos() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                qryptos.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'qryptos',
                        'name': 'QRYPTOS',
                        'countries': ['CN', 'TW'],
                        'version': '2',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                            'fetchOrder': true,
                            'fetchOrders': true,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/30953915-b1611dc0-a436-11e7-8947-c95bd5a42086.jpg',
                            'api': 'https://api.qryptos.com',
                            'www': 'https://www.qryptos.com',
                            'doc': [
                                'https://developers.quoine.com',
                                'https://developers.quoine.com/v2',
                            ],
                            'fees': 'https://qryptos.zendesk.com/hc/en-us/articles/115007858167-Fees',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'products',
                                    'products/{id}',
                                    'products/{id}/price_levels',
                                    'executions',
                                    'ir_ladders/{currency}',
                                ],
                            },
                            'private': {
                                'get': [
                                    'accounts/balance',
                                    'accounts/main_asset',
                                    'crypto_accounts',
                                    'executions/me',
                                    'fiat_accounts',
                                    'loan_bids',
                                    'loans',
                                    'orders',
                                    'orders/{id}',
                                    'orders/{id}/trades',
                                    'orders/{id}/executions',
                                    'trades',
                                    'trades/{id}/loans',
                                    'trading_accounts',
                                    'trading_accounts/{id}',
                                ],
                                'post': [
                                    'fiat_accounts',
                                    'loan_bids',
                                    'orders',
                                ],
                                'put': [
                                    'loan_bids/{id}/close',
                                    'loans/{id}',
                                    'orders/{id}',
                                    'orders/{id}/cancel',
                                    'trades/{id}',
                                    'trades/{id}/close',
                                    'trades/close_all',
                                    'trading_accounts/{id}',
                                ],
                            },
                        },
                        'skipJsonOnStatusCodes': [401],
                        'exceptions': {
                            'messages': {
                                'API Authentication failed': AuthenticationError,
                                'Nonce is too small': InvalidNonce,
                                'Order not found': OrderNotFound,
                                'user': {
                                    'not_enough_free_balance': InsufficientFunds,
                                },
                                'quantity': {
                                    'less_than_order_size': InvalidOrder,
                                },
                            },
                        },
                    });
                };
                qryptos.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, base, quote, symbol, maker, taker, active, minAmount, minPrice, limits, precision;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetProducts()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['id'].toString();
                                        base = market['base_currency'];
                                        quote = market['quoted_currency'];
                                        symbol = base + '/' + quote;
                                        maker = this.safeFloat(market, 'maker_fee');
                                        taker = this.safeFloat(market, 'taker_fee');
                                        active = !market['disabled'];
                                        minAmount = undefined;
                                        minPrice = undefined;
                                        if (base === 'BTC') {
                                            minAmount = 0.001;
                                        }
                                        else if (base === 'ETH') {
                                            minAmount = 0.01;
                                        }
                                        if (quote === 'BTC') {
                                            minPrice = 0.00000001;
                                        }
                                        else if (quote === 'ETH' || quote === 'USD' || quote === 'JPY') {
                                            minPrice = 0.00001;
                                        }
                                        limits = {
                                            'amount': { 'min': minAmount },
                                            'price': { 'min': minPrice },
                                            'cost': { 'min': undefined },
                                        };
                                        if (typeof minPrice !== 'undefined')
                                            if (typeof minAmount !== 'undefined')
                                                limits['cost']['min'] = minPrice * minAmount;
                                        precision = {
                                            'amount': undefined,
                                            'price': undefined,
                                        };
                                        if (typeof minAmount !== 'undefined')
                                            precision['amount'] = -Math.log10(minAmount);
                                        if (typeof minPrice !== 'undefined')
                                            precision['price'] = -Math.log10(minPrice);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'maker': maker,
                                            'taker': taker,
                                            'limits': limits,
                                            'precision': precision,
                                            'active': active,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                qryptos.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, b, balance, currency, total, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetAccountsBalance(params)];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        total = parseFloat(balance['balance']);
                                        account = {
                                            'free': total,
                                            'used': 0.0,
                                            'total': total,
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                qryptos.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetProductsIdPriceLevels(this.extend({
                                            'id': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'buy_price_levels', 'sell_price_levels')];
                            }
                        });
                    });
                };
                qryptos.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var last = undefined;
                    if ('last_traded_price' in ticker) {
                        if (ticker['last_traded_price']) {
                            var length_2 = ticker['last_traded_price'].length;
                            if (length_2 > 0)
                                last = parseFloat(ticker['last_traded_price']);
                        }
                    }
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high_market_ask'),
                        'low': this.safeFloat(ticker, 'low_market_bid'),
                        'bid': this.safeFloat(ticker, 'market_bid'),
                        'ask': this.safeFloat(ticker, 'market_ask'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': last,
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'volume_24h'),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                qryptos.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, result, t, ticker, base, quote, symbol, market;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetProducts(params)];
                                case 2:
                                    tickers = _a.sent();
                                    result = {};
                                    for (t = 0; t < tickers.length; t++) {
                                        ticker = tickers[t];
                                        base = ticker['base_currency'];
                                        quote = ticker['quoted_currency'];
                                        symbol = base + '/' + quote;
                                        market = this.markets[symbol];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                qryptos.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetProductsId(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                qryptos.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['created_at'] * 1000;
                    return {
                        'info': trade,
                        'id': trade['id'].toString(),
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['taker_side'],
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['quantity']),
                    };
                };
                qryptos.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'product_id': market['id'],
                                    };
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.publicGetExecutions(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['models'], market, since, limit)];
                            }
                        });
                    });
                };
                qryptos.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'order_type': type,
                                        'product_id': this.marketId(symbol),
                                        'side': side,
                                        'quantity': amount,
                                    };
                                    if (type === 'limit')
                                        order['price'] = price;
                                    return [4, this.privatePostOrders(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response)];
                            }
                        });
                    });
                };
                qryptos.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var result, order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePutOrdersIdCancel(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2:
                                    result = _a.sent();
                                    order = this.parseOrder(result);
                                    if (order['status'] === 'closed')
                                        throw new OrderNotFound(this.id + ' ' + this.json(order));
                                    return [2, order];
                            }
                        });
                    });
                };
                qryptos.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = order['created_at'] * 1000;
                    var marketId = this.safeString(order, 'product_id');
                    if (typeof marketId !== 'undefined') {
                        if (marketId in this.markets_by_id)
                            market = this.markets_by_id[marketId];
                    }
                    var status = undefined;
                    if ('status' in order) {
                        if (order['status'] === 'live') {
                            status = 'open';
                        }
                        else if (order['status'] === 'filled') {
                            status = 'closed';
                        }
                        else if (order['status'] === 'cancelled') {
                            status = 'canceled';
                        }
                    }
                    var amount = parseFloat(order['quantity']);
                    var filled = parseFloat(order['filled_quantity']);
                    var price = parseFloat(order['price']);
                    var symbol = undefined;
                    if (market) {
                        symbol = market['symbol'];
                    }
                    return {
                        'id': order['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'type': order['order_type'],
                        'status': status,
                        'symbol': symbol,
                        'side': order['side'],
                        'price': price,
                        'amount': amount,
                        'filled': filled,
                        'remaining': amount - filled,
                        'trades': undefined,
                        'fee': {
                            'currency': undefined,
                            'cost': parseFloat(order['order_fee']),
                        },
                        'info': order,
                    };
                };
                qryptos.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetOrdersId(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2:
                                    order = _a.sent();
                                    return [2, this.parseOrder(order)];
                            }
                        });
                    });
                };
                qryptos.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, status, result, orders;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['product_id'] = market['id'];
                                    }
                                    status = this.safeValue(params, 'status');
                                    if (status) {
                                        params = this.omit(params, 'status');
                                        if (status === 'open') {
                                            request['status'] = 'live';
                                        }
                                        else if (status === 'closed') {
                                            request['status'] = 'filled';
                                        }
                                        else if (status === 'canceled') {
                                            request['status'] = 'cancelled';
                                        }
                                    }
                                    if (typeof limit !== 'undefined')
                                        request['limit'] = limit;
                                    return [4, this.privateGetOrders(this.extend(request, params))];
                                case 2:
                                    result = _a.sent();
                                    orders = result['models'];
                                    return [2, this.parseOrders(orders, market, since, limit)];
                            }
                        });
                    });
                };
                qryptos.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return this.fetchOrders(symbol, since, limit, this.extend({ 'status': 'open' }, params));
                };
                qryptos.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return this.fetchOrders(symbol, since, limit, this.extend({ 'status': 'closed' }, params));
                };
                qryptos.prototype.nonce = function () {
                    return this.milliseconds();
                };
                qryptos.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    headers = {
                        'X-Quoine-API-Version': this.version,
                        'Content-Type': 'application/json',
                    };
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        if (method === 'GET') {
                            if (Object.keys(query).length)
                                url += '?' + this.urlencode(query);
                        }
                        else if (Object.keys(query).length) {
                            body = this.json(query);
                        }
                        var nonce = this.nonce();
                        var request = {
                            'path': url,
                            'nonce': nonce,
                            'token_id': this.apiKey,
                            'iat': Math.floor(nonce / 1000),
                        };
                        headers['X-Quoine-Auth'] = this.jwt(request, this.secret);
                    }
                    url = this.urls['api'] + url;
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                qryptos.prototype.handleErrors = function (code, reason, url, method, headers, body, response) {
                    if (response === void 0) { response = undefined; }
                    if (code >= 200 && code <= 299)
                        return;
                    var messages = this.exceptions['messages'];
                    if (code === 401) {
                        if (body in messages)
                            throw new messages[body](this.id + ' ' + body);
                        else
                            return;
                    }
                    if (typeof response === 'undefined')
                        if ((body[0] === '{') || (body[0] === '['))
                            response = JSON.parse(body);
                        else
                            return;
                    var feedback = this.id + ' ' + this.json(response);
                    if (code === 404) {
                        var message = this.safeString(response, 'message');
                        if (message in messages)
                            throw new messages[message](feedback);
                    }
                    else if (code === 422) {
                        if ('errors' in response) {
                            var errors = response['errors'];
                            var errorTypes = ['user', 'quantity'];
                            for (var i = 0; i < errorTypes.length; i++) {
                                var errorType = errorTypes[i];
                                if (errorType in errors) {
                                    var errorMessages = errors[errorType];
                                    for (var j = 0; j < errorMessages.length; j++) {
                                        var message = errorMessages[j];
                                        if (message in messages[errorType])
                                            throw new messages[errorType][message](feedback);
                                    }
                                }
                            }
                        }
                    }
                };
                return qryptos;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 103: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(quadrigacx, _super);
                function quadrigacx() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                quadrigacx.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'quadrigacx',
                        'name': 'QuadrigaCX',
                        'countries': 'CA',
                        'rateLimit': 1000,
                        'version': 'v2',
                        'has': {
                            'fetchDepositAddress': true,
                            'CORS': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766825-98a6d0de-5ee7-11e7-9fa4-38e11a2c6f52.jpg',
                            'api': 'https://api.quadrigacx.com',
                            'www': 'https://www.quadrigacx.com',
                            'doc': 'https://www.quadrigacx.com/api_info',
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': true,
                            'uid': true,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'order_book',
                                    'ticker',
                                    'transactions',
                                ],
                            },
                            'private': {
                                'post': [
                                    'balance',
                                    'bitcoin_deposit_address',
                                    'bitcoin_withdrawal',
                                    'bitcoincash_deposit_address',
                                    'bitcoincash_withdrawal',
                                    'bitcoingold_deposit_address',
                                    'bitcoingold_withdrawal',
                                    'buy',
                                    'cancel_order',
                                    'ether_deposit_address',
                                    'ether_withdrawal',
                                    'litecoin_deposit_address',
                                    'litecoin_withdrawal',
                                    'lookup_order',
                                    'open_orders',
                                    'sell',
                                    'user_transactions',
                                ],
                            },
                        },
                        'markets': {
                            'BTC/CAD': { 'id': 'btc_cad', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                            'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'maker': 0.005, 'taker': 0.005 },
                            'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.002, 'taker': 0.002 },
                            'ETH/CAD': { 'id': 'eth_cad', 'symbol': 'ETH/CAD', 'base': 'ETH', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                            'LTC/CAD': { 'id': 'ltc_cad', 'symbol': 'LTC/CAD', 'base': 'LTC', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                            'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'maker': 0.005, 'taker': 0.005 },
                            'BCH/CAD': { 'id': 'bch_cad', 'symbol': 'BCH/CAD', 'base': 'BCH', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                            'BCH/BTC': { 'id': 'bch_btc', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'maker': 0.005, 'taker': 0.005 },
                            'BTG/CAD': { 'id': 'btg_cad', 'symbol': 'BTG/CAD', 'base': 'BTG', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                            'BTG/BTC': { 'id': 'btg_btc', 'symbol': 'BTG/BTC', 'base': 'BTG', 'quote': 'BTC', 'maker': 0.005, 'taker': 0.005 },
                        },
                    });
                };
                quadrigacx.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, currencies, i, currency, lowercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostBalance()];
                                case 1:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    currencies = Object.keys(this.currencies);
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        lowercase = currency.toLowerCase();
                                        account = {
                                            'free': parseFloat(balances[lowercase + '_available']),
                                            'used': parseFloat(balances[lowercase + '_reserved']),
                                            'total': parseFloat(balances[lowercase + '_balance']),
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                quadrigacx.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetOrderBook(this.extend({
                                        'book': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    orderbook = _a.sent();
                                    timestamp = parseInt(orderbook['timestamp']) * 1000;
                                    return [2, this.parseOrderBook(orderbook, timestamp)];
                            }
                        });
                    });
                };
                quadrigacx.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp, vwap, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetTicker(this.extend({
                                        'book': this.marketId(symbol),
                                    }, params))];
                                case 1:
                                    ticker = _a.sent();
                                    timestamp = parseInt(ticker['timestamp']) * 1000;
                                    vwap = parseFloat(ticker['vwap']);
                                    baseVolume = parseFloat(ticker['volume']);
                                    quoteVolume = baseVolume * vwap;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['bid']),
                                            'ask': parseFloat(ticker['ask']),
                                            'vwap': vwap,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                quadrigacx.prototype.parseTrade = function (trade, market) {
                    var timestamp = parseInt(trade['date']) * 1000;
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'id': trade['tid'].toString(),
                        'order': undefined,
                        'type': undefined,
                        'side': trade['side'],
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                quadrigacx.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    market = this.market(symbol);
                                    return [4, this.publicGetTransactions(this.extend({
                                            'book': market['id'],
                                        }, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                quadrigacx.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    method = 'privatePost' + this.capitalize(side);
                                    order = {
                                        'amount': amount,
                                        'book': this.marketId(symbol),
                                    };
                                    if (type === 'limit')
                                        order['price'] = price;
                                    return [4, this[method](this.extend(order, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                quadrigacx.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancelOrder(this.extend({
                                        'id': id,
                                    }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                quadrigacx.prototype.fetchDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var method, response, address, status;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    method = 'privatePost' + this.getCurrencyName(currency) + 'DepositAddress';
                                    return [4, this[method](params)];
                                case 1:
                                    response = _a.sent();
                                    address = undefined;
                                    status = undefined;
                                    if (response.indexOf('rror') >= 0) {
                                        status = 'error';
                                    }
                                    else {
                                        address = response;
                                        status = 'ok';
                                    }
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'status': status,
                                            'info': this.last_http_response,
                                        }];
                            }
                        });
                    });
                };
                quadrigacx.prototype.getCurrencyName = function (currency) {
                    var currencies = {
                        'ETH': 'Ether',
                        'BTC': 'Bitcoin',
                        'LTC': 'Litecoin',
                        'BCH': 'Bitcoincash',
                        'BTG': 'Bitcoingold',
                    };
                    return currencies[currency];
                };
                quadrigacx.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, method, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'amount': amount,
                                        'address': address,
                                    };
                                    method = 'privatePost' + this.getCurrencyName(currency) + 'Withdrawal';
                                    return [4, this[method](this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                quadrigacx.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + path;
                    if (api === 'public') {
                        url += '?' + this.urlencode(params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        var request = [nonce.toString(), this.uid, this.apiKey].join('');
                        var signature = this.hmac(this.encode(request), this.encode(this.secret));
                        var query = this.extend({
                            'key': this.apiKey,
                            'nonce': nonce,
                            'signature': signature,
                        }, params);
                        body = this.json(query);
                        headers = {
                            'Content-Type': 'application/json',
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                quadrigacx.prototype.handleErrors = function (statusCode, statusText, url, method, headers, body) {
                    if (typeof body !== 'string')
                        return;
                    if (body.length < 2)
                        return;
                    if (statusCode === 200 && body.indexOf('Invalid API Code or Invalid Signature') >= 0) {
                        throw new AuthenticationError(this.id + ' ' + body);
                    }
                };
                quadrigacx.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if (typeof response === 'string')
                                        return [2, response];
                                    if ('error' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return quadrigacx;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 104: [function (require, module, exports) {
            'use strict';
            var qryptos = require('./qryptos.js');
            module.exports = (function (_super) {
                __extends(quoinex, _super);
                function quoinex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                quoinex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'quoinex',
                        'name': 'QUOINEX',
                        'countries': ['JP', 'SG', 'VN'],
                        'version': '2',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/35047114-0e24ad4a-fbaa-11e7-96a9-69c1a756083b.jpg',
                            'api': 'https://api.quoine.com',
                            'www': 'https://quoinex.com/',
                            'doc': [
                                'https://developers.quoine.com',
                                'https://developers.quoine.com/v2',
                            ],
                            'fees': 'https://quoine.zendesk.com/hc/en-us/articles/115011281488-Fees',
                        },
                    });
                };
                return quoinex;
            }(qryptos));
        }, { "./qryptos.js": 102 }], 105: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(southxchange, _super);
                function southxchange() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                southxchange.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'southxchange',
                        'name': 'SouthXchange',
                        'countries': 'AR',
                        'rateLimit': 1000,
                        'has': {
                            'CORS': true,
                            'createDepositAddres': true,
                            'fetchOpenOrders': true,
                            'fetchTickers': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27838912-4f94ec8a-60f6-11e7-9e5d-bbf9bd50a559.jpg',
                            'api': 'https://www.southxchange.com/api',
                            'www': 'https://www.southxchange.com',
                            'doc': 'https://www.southxchange.com/Home/Api',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'markets',
                                    'price/{symbol}',
                                    'prices',
                                    'book/{symbol}',
                                    'trades/{symbol}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'cancelMarketOrders',
                                    'cancelOrder',
                                    'generatenewaddress',
                                    'listOrders',
                                    'listBalances',
                                    'placeOrder',
                                    'withdraw',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'maker': 0.2 / 100,
                                'taker': 0.2 / 100,
                            },
                        },
                    });
                };
                southxchange.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, base, quote, symbol, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetMarkets()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        base = market[0];
                                        quote = market[1];
                                        symbol = base + '/' + quote;
                                        id = symbol;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                southxchange.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, b, balance, currency, uppercase, free, used, total, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostListBalances()];
                                case 2:
                                    balances = _a.sent();
                                    if (!balances)
                                        throw new ExchangeError(this.id + ' fetchBalance got an unrecognized response');
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['Currency'];
                                        uppercase = currency.toUpperCase();
                                        free = parseFloat(balance['Available']);
                                        used = parseFloat(balance['Unconfirmed']);
                                        total = this.sum(free, used);
                                        account = {
                                            'free': free,
                                            'used': used,
                                            'total': total,
                                        };
                                        result[uppercase] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                southxchange.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetBookSymbol(this.extend({
                                            'symbol': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook, undefined, 'BuyOrders', 'SellOrders', 'Price', 'Amount')];
                            }
                        });
                    });
                };
                southxchange.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': undefined,
                        'low': undefined,
                        'bid': this.safeFloat(ticker, 'Bid'),
                        'ask': this.safeFloat(ticker, 'Ask'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'Last'),
                        'change': this.safeFloat(ticker, 'Variation24Hr'),
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': this.safeFloat(ticker, 'Volume24Hr'),
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                southxchange.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, ids, result, i, id, symbol, market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetPrices(params)];
                                case 2:
                                    response = _a.sent();
                                    tickers = this.indexBy(response, 'Market');
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        symbol = id;
                                        market = undefined;
                                        if (id in this.markets_by_id) {
                                            market = this.markets_by_id[id];
                                            symbol = market['symbol'];
                                        }
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                southxchange.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetPriceSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                southxchange.prototype.parseTrade = function (trade, market) {
                    var timestamp = trade['At'] * 1000;
                    return {
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'id': undefined,
                        'order': undefined,
                        'type': undefined,
                        'side': trade['Type'],
                        'price': trade['Price'],
                        'amount': trade['Amount'],
                    };
                };
                southxchange.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradesSymbol(this.extend({
                                            'symbol': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                southxchange.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var status = 'open';
                    var symbol = order['ListingCurrency'] + '/' + order['ReferenceCurrency'];
                    var timestamp = undefined;
                    var price = parseFloat(order['LimitPrice']);
                    var amount = this.safeFloat(order, 'OriginalAmount');
                    var remaining = this.safeFloat(order, 'Amount');
                    var filled = undefined;
                    var cost = undefined;
                    if (typeof amount !== 'undefined') {
                        cost = price * amount;
                        if (typeof remaining !== 'undefined')
                            filled = amount - remaining;
                    }
                    var orderType = order['Type'].toLowerCase();
                    var result = {
                        'info': order,
                        'id': order['Code'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': orderType,
                        'side': undefined,
                        'price': price,
                        'amount': amount,
                        'cost': cost,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': undefined,
                    };
                    return result;
                };
                southxchange.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    if (typeof symbol !== 'undefined')
                                        market = this.market(symbol);
                                    return [4, this.privatePostListOrders()];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                southxchange.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    order = {
                                        'listingCurrency': market['base'],
                                        'referenceCurrency': market['quote'],
                                        'type': side,
                                        'amount': amount,
                                    };
                                    if (type === 'limit')
                                        order['limitPrice'] = price;
                                    return [4, this.privatePostPlaceOrder(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response.toString(),
                                        }];
                            }
                        });
                    });
                };
                southxchange.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCancelOrder(this.extend({
                                            'orderCode': id,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                southxchange.prototype.createDepositAddress = function (code, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currency, response, parts, numParts, address, tag;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    currency = this.currency(code);
                                    return [4, this.privatePostGeneratenewaddress(this.extend({
                                            'currency': currency['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    parts = response.split('|');
                                    numParts = parts.length;
                                    address = parts[0];
                                    this.checkAddress(address);
                                    tag = undefined;
                                    if (numParts > 1)
                                        tag = parts[1];
                                    return [2, {
                                            'currency': code,
                                            'address': address,
                                            'tag': tag,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                southxchange.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    request = {
                                        'currency': currency,
                                        'address': address,
                                        'amount': amount,
                                    };
                                    if (typeof tag !== 'undefined')
                                        request['address'] = address + '|' + tag;
                                    return [4, this.privatePostWithdraw(this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                southxchange.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        query = this.extend({
                            'key': this.apiKey,
                            'nonce': nonce,
                        }, query);
                        body = this.json(query);
                        headers = {
                            'Content-Type': 'application/json',
                            'Hash': this.hmac(this.encode(body), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return southxchange;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 106: [function (require, module, exports) {
            'use strict';
            var foxbit = require('./foxbit.js');
            module.exports = (function (_super) {
                __extends(surbitcoin, _super);
                function surbitcoin() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                surbitcoin.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'surbitcoin',
                        'name': 'SurBitcoin',
                        'countries': 'VE',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27991511-f0a50194-6481-11e7-99b5-8f02932424cc.jpg',
                            'api': {
                                'public': 'https://api.blinktrade.com/api',
                                'private': 'https://api.blinktrade.com/tapi',
                            },
                            'www': 'https://surbitcoin.com',
                            'doc': 'https://blinktrade.com/docs',
                        },
                    });
                };
                return surbitcoin;
            }(foxbit));
        }, { "./foxbit.js": 70 }], 107: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(therock, _super);
                function therock() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                therock.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'therock',
                        'name': 'TheRockTrading',
                        'countries': 'MT',
                        'rateLimit': 1000,
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766869-75057fa2-5ee9-11e7-9a6f-13e641fa4707.jpg',
                            'api': 'https://api.therocktrading.com',
                            'www': 'https://therocktrading.com',
                            'doc': [
                                'https://api.therocktrading.com/doc/v1/index.html',
                                'https://api.therocktrading.com/doc/',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'funds/{id}/orderbook',
                                    'funds/{id}/ticker',
                                    'funds/{id}/trades',
                                    'funds/tickers',
                                ],
                            },
                            'private': {
                                'get': [
                                    'balances',
                                    'balances/{id}',
                                    'discounts',
                                    'discounts/{id}',
                                    'funds',
                                    'funds/{id}',
                                    'funds/{id}/trades',
                                    'funds/{fund_id}/orders',
                                    'funds/{fund_id}/orders/{id}',
                                    'funds/{fund_id}/position_balances',
                                    'funds/{fund_id}/positions',
                                    'funds/{fund_id}/positions/{id}',
                                    'transactions',
                                    'transactions/{id}',
                                    'withdraw_limits/{id}',
                                    'withdraw_limits',
                                ],
                                'post': [
                                    'atms/withdraw',
                                    'funds/{fund_id}/orders',
                                ],
                                'delete': [
                                    'funds/{fund_id}/orders/{id}',
                                    'funds/{fund_id}/orders/remove_all',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.02 / 100,
                                'taker': 0.2 / 100,
                            },
                            'funding': {
                                'tierBased': false,
                                'percentage': false,
                                'withdraw': {
                                    'BTC': 0.0005,
                                    'BCH': 0.0005,
                                    'PPC': 0.02,
                                    'ETH': 0.001,
                                    'ZEC': 0.001,
                                    'LTC': 0.002,
                                    'EUR': 2.5,
                                },
                                'deposit': {
                                    'BTC': 0,
                                    'BCH': 0,
                                    'PPC': 0,
                                    'ETH': 0,
                                    'ZEC': 0,
                                    'LTC': 0,
                                    'EUR': 0,
                                },
                            },
                        },
                    });
                };
                therock.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetFundsTickers()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets['tickers'].length; p++) {
                                        market = markets['tickers'][p];
                                        id = market['fund_id'];
                                        base = id.slice(0, 3);
                                        quote = id.slice(3);
                                        symbol = base + '/' + quote;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                therock.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, free, total, used, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetBalances()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['balances'];
                                    result = { 'info': response };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        free = balance['trading_balance'];
                                        total = balance['balance'];
                                        used = total - free;
                                        account = {
                                            'free': free,
                                            'used': used,
                                            'total': total,
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                therock.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetFundsIdOrderbook(this.extend({
                                            'id': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = this.parse8601(orderbook['date']);
                                    return [2, this.parseOrderBook(orderbook, timestamp, 'bids', 'asks', 'price', 'amount')];
                            }
                        });
                    });
                };
                therock.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = this.parse8601(ticker['date']);
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    var last = parseFloat(ticker['last']);
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': parseFloat(ticker['high']),
                        'low': parseFloat(ticker['low']),
                        'bid': parseFloat(ticker['bid']),
                        'ask': parseFloat(ticker['ask']),
                        'vwap': undefined,
                        'open': parseFloat(ticker['open']),
                        'close': last,
                        'last': last,
                        'previousClose': parseFloat(ticker['close']),
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': parseFloat(ticker['volume_traded']),
                        'quoteVolume': parseFloat(ticker['volume']),
                        'info': ticker,
                    };
                };
                therock.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, tickers, ids, result, i, id, market, symbol, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetFundsTickers(params)];
                                case 2:
                                    response = _a.sent();
                                    tickers = this.indexBy(response['tickers'], 'fund_id');
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = this.markets_by_id[id];
                                        symbol = market['symbol'];
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                therock.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetFundsIdTicker(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                therock.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    if (!market)
                        market = this.markets_by_id[trade['fund_id']];
                    var timestamp = this.parse8601(trade['date']);
                    return {
                        'info': trade,
                        'id': trade['id'].toString(),
                        'order': undefined,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': trade['side'],
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                therock.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetFundsIdTrades(this.extend({
                                            'id': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response['trades'], market, since, limit)];
                            }
                        });
                    });
                };
                therock.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (type === 'market')
                                        price = 0;
                                    return [4, this.privatePostFundsFundIdOrders(this.extend({
                                            'fund_id': this.marketId(symbol),
                                            'side': side,
                                            'amount': amount,
                                            'price': price,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                therock.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateDeleteFundsFundIdOrdersId(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                therock.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce().toString();
                        var auth = nonce + url;
                        headers = {
                            'X-TRT-KEY': this.apiKey,
                            'X-TRT-NONCE': nonce,
                            'X-TRT-SIGN': this.hmac(this.encode(auth), this.encode(this.secret), 'sha512'),
                        };
                        if (Object.keys(query).length) {
                            body = this.json(query);
                            headers['Content-Type'] = 'application/json';
                        }
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                therock.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('errors' in response)
                                        throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return therock;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 108: [function (require, module, exports) {
            'use strict';
            var liqui = require('./liqui.js');
            module.exports = (function (_super) {
                __extends(tidex, _super);
                function tidex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                tidex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'tidex',
                        'name': 'Tidex',
                        'countries': 'UK',
                        'rateLimit': 2000,
                        'version': '3',
                        'has': {
                            'fetchCurrencies': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/30781780-03149dc4-a12e-11e7-82bb-313b269d24d4.jpg',
                            'api': {
                                'web': 'https://web.tidex.com/api',
                                'public': 'https://api.tidex.com/api/3',
                                'private': 'https://api.tidex.com/tapi',
                            },
                            'www': 'https://tidex.com',
                            'doc': 'https://tidex.com/exchange/public-api',
                            'fees': [
                                'https://tidex.com/exchange/assets-spec',
                                'https://tidex.com/exchange/pairs-spec',
                            ],
                        },
                        'api': {
                            'web': {
                                'get': [
                                    'currency',
                                    'pairs',
                                    'tickers',
                                    'orders',
                                    'ordershistory',
                                    'trade-data',
                                    'trade-data/{id}',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'tierBased': false,
                                'percentage': true,
                                'taker': 0.1 / 100,
                                'maker': 0.1 / 100,
                            },
                        },
                    });
                };
                tidex.prototype.commonCurrencyCode = function (currency) {
                    if (!this.substituteCommonCurrencyCodes)
                        return currency;
                    if (currency === 'XBT')
                        return 'BTC';
                    if (currency === 'BCC')
                        return 'BCH';
                    if (currency === 'DRK')
                        return 'DASH';
                    if (currency === 'DSH')
                        return 'DASH';
                    if (currency === 'MGO')
                        return 'WMGO';
                    if (currency === 'EMGO')
                        return 'MGO';
                    return currency;
                };
                tidex.prototype.fetchCurrencies = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencies, result, i, currency, id, precision, code, active, status_8, canWithdraw, canDeposit;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.webGetCurrency(params)];
                                case 1:
                                    currencies = _a.sent();
                                    result = {};
                                    for (i = 0; i < currencies.length; i++) {
                                        currency = currencies[i];
                                        id = currency['Symbol'];
                                        precision = currency['AmountPoint'];
                                        code = this.commonCurrencyCode(id);
                                        active = currency['Visible'] === true;
                                        status_8 = 'ok';
                                        if (!active) {
                                            status_8 = 'disabled';
                                        }
                                        canWithdraw = currency['WithdrawEnable'] === true;
                                        canDeposit = currency['DepositEnable'] === true;
                                        if (!canWithdraw || !canDeposit) {
                                            active = false;
                                        }
                                        result[code] = {
                                            'id': id,
                                            'code': code,
                                            'name': currency['Name'],
                                            'active': active,
                                            'status': status_8,
                                            'precision': precision,
                                            'funding': {
                                                'withdraw': {
                                                    'active': canWithdraw,
                                                    'fee': currency['WithdrawFee'],
                                                },
                                                'deposit': {
                                                    'active': canDeposit,
                                                    'fee': 0.0,
                                                },
                                            },
                                            'limits': {
                                                'amount': {
                                                    'min': undefined,
                                                    'max': Math.pow(10, precision),
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision),
                                                    'max': Math.pow(10, precision),
                                                },
                                                'cost': {
                                                    'min': undefined,
                                                    'max': undefined,
                                                },
                                                'withdraw': {
                                                    'min': currency['WithdrawMinAmout'],
                                                    'max': undefined,
                                                },
                                                'deposit': {
                                                    'min': currency['DepositMinAmount'],
                                                    'max': undefined,
                                                },
                                            },
                                            'info': currency,
                                        };
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                tidex.prototype.getVersionString = function () {
                    return '';
                };
                return tidex;
            }(liqui));
        }, { "./liqui.js": 90 }], 109: [function (require, module, exports) {
            'use strict';
            var foxbit = require('./foxbit.js');
            module.exports = (function (_super) {
                __extends(urdubit, _super);
                function urdubit() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                urdubit.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'urdubit',
                        'name': 'UrduBit',
                        'countries': 'PK',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27991453-156bf3ae-6480-11e7-82eb-7295fe1b5bb4.jpg',
                            'api': {
                                'public': 'https://api.blinktrade.com/api',
                                'private': 'https://api.blinktrade.com/tapi',
                            },
                            'www': 'https://urdubit.com',
                            'doc': 'https://blinktrade.com/docs',
                        },
                    });
                };
                return urdubit;
            }(foxbit));
        }, { "./foxbit.js": 70 }], 110: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            module.exports = (function (_super) {
                __extends(vaultoro, _super);
                function vaultoro() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                vaultoro.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'vaultoro',
                        'name': 'Vaultoro',
                        'countries': 'CH',
                        'rateLimit': 1000,
                        'version': '1',
                        'has': {
                            'CORS': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766880-f205e870-5ee9-11e7-8fe2-0d5b15880752.jpg',
                            'api': 'https://api.vaultoro.com',
                            'www': 'https://www.vaultoro.com',
                            'doc': 'https://api.vaultoro.com',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'bidandask',
                                    'buyorders',
                                    'latest',
                                    'latesttrades',
                                    'markets',
                                    'orderbook',
                                    'sellorders',
                                    'transactions/day',
                                    'transactions/hour',
                                    'transactions/month',
                                ],
                            },
                            'private': {
                                'get': [
                                    'balance',
                                    'mytrades',
                                    'orders',
                                ],
                                'post': [
                                    'buy/{symbol}/{type}',
                                    'cancel/{id}',
                                    'sell/{symbol}/{type}',
                                    'withdraw',
                                ],
                            },
                        },
                    });
                };
                vaultoro.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var result, markets, market, base, quote, symbol, baseId, quoteId, id;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    result = [];
                                    return [4, this.publicGetMarkets()];
                                case 1:
                                    markets = _a.sent();
                                    market = markets['data'];
                                    base = market['BaseCurrency'];
                                    quote = market['MarketCurrency'];
                                    symbol = base + '/' + quote;
                                    baseId = base;
                                    quoteId = quote;
                                    id = market['MarketName'];
                                    result.push({
                                        'id': id,
                                        'symbol': symbol,
                                        'base': base,
                                        'quote': quote,
                                        'baseId': baseId,
                                        'quoteId': quoteId,
                                        'info': market,
                                    });
                                    return [2, result];
                            }
                        });
                    });
                };
                vaultoro.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, uppercase, free, used, total, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetBalance()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['data'];
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency_code'];
                                        uppercase = currency.toUpperCase();
                                        free = balance['cash'];
                                        used = balance['reserved'];
                                        total = this.sum(free, used);
                                        account = {
                                            'free': free,
                                            'used': used,
                                            'total': total,
                                        };
                                        result[uppercase] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                vaultoro.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, orderbook, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetOrderbook(params)];
                                case 2:
                                    response = _a.sent();
                                    orderbook = {
                                        'bids': response['data'][0]['b'],
                                        'asks': response['data'][1]['s'],
                                    };
                                    result = this.parseOrderBook(orderbook, undefined, 'bids', 'asks', 'Gold_Price', 'Gold_Amount');
                                    result['bids'] = this.sortBy(result['bids'], 0, true);
                                    return [2, result];
                            }
                        });
                    });
                };
                vaultoro.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var quote, bidsLength, bid, ask, response, ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetBidandask(params)];
                                case 2:
                                    quote = _a.sent();
                                    bidsLength = quote['bids'].length;
                                    bid = quote['bids'][bidsLength - 1];
                                    ask = quote['asks'][0];
                                    return [4, this.publicGetMarkets(params)];
                                case 3:
                                    response = _a.sent();
                                    ticker = response['data'];
                                    timestamp = this.milliseconds();
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['24hHigh']),
                                            'low': parseFloat(ticker['24hLow']),
                                            'bid': bid[0],
                                            'ask': ask[0],
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['LastPrice']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': undefined,
                                            'quoteVolume': parseFloat(ticker['24hVolume']),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                vaultoro.prototype.parseTrade = function (trade, market) {
                    var timestamp = this.parse8601(trade['Time']);
                    return {
                        'id': undefined,
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'order': undefined,
                        'type': undefined,
                        'side': undefined,
                        'price': trade['Gold_Price'],
                        'amount': trade['Gold_Amount'],
                    };
                };
                vaultoro.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTransactionsDay(params)];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                vaultoro.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, method, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    method = 'privatePost' + this.capitalize(side) + 'SymbolType';
                                    return [4, this[method](this.extend({
                                            'symbol': market['quoteId'].toLowerCase(),
                                            'type': type,
                                            'gld': amount,
                                            'price': price || 1,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['data']['Order_ID'],
                                        }];
                            }
                        });
                    });
                };
                vaultoro.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostCancelId(this.extend({
                                            'id': id,
                                        }, params))];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                vaultoro.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/';
                    if (api === 'public') {
                        url += path;
                    }
                    else {
                        this.checkRequiredCredentials();
                        var nonce = this.nonce();
                        url += this.version + '/' + this.implodeParams(path, params);
                        var query = this.extend({
                            'nonce': nonce,
                            'apikey': this.apiKey,
                        }, this.omit(params, this.extractParams(path)));
                        url += '?' + this.urlencode(query);
                        headers = {
                            'Content-Type': 'application/json',
                            'X-Signature': this.hmac(this.encode(url), this.encode(this.secret)),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return vaultoro;
            }(Exchange));
        }, { "./base/Exchange": 8 }], 111: [function (require, module, exports) {
            'use strict';
            var foxbit = require('./foxbit.js');
            module.exports = (function (_super) {
                __extends(vbtc, _super);
                function vbtc() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                vbtc.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'vbtc',
                        'name': 'VBTC',
                        'countries': 'VN',
                        'has': {
                            'CORS': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27991481-1f53d1d8-6481-11e7-884e-21d17e7939db.jpg',
                            'api': {
                                'public': 'https://api.blinktrade.com/api',
                                'private': 'https://api.blinktrade.com/tapi',
                            },
                            'www': 'https://vbtc.exchange',
                            'doc': 'https://blinktrade.com/docs',
                        },
                    });
                };
                return vbtc;
            }(foxbit));
        }, { "./foxbit.js": 70 }], 112: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(virwox, _super);
                function virwox() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                virwox.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'virwox',
                        'name': 'VirWoX',
                        'countries': ['AT', 'EU'],
                        'rateLimit': 1000,
                        'has': {
                            'CORS': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766894-6da9d360-5eea-11e7-90aa-41f2711b7405.jpg',
                            'api': {
                                'public': 'http://api.virwox.com/api/json.php',
                                'private': 'https://www.virwox.com/api/trading.php',
                            },
                            'www': 'https://www.virwox.com',
                            'doc': 'https://www.virwox.com/developers.php',
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': false,
                            'login': true,
                            'password': true,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'getInstruments',
                                    'getBestPrices',
                                    'getMarketDepth',
                                    'estimateMarketOrder',
                                    'getTradedPriceVolume',
                                    'getRawTradeData',
                                    'getStatistics',
                                    'getTerminalList',
                                    'getGridList',
                                    'getGridStatistics',
                                ],
                                'post': [
                                    'getInstruments',
                                    'getBestPrices',
                                    'getMarketDepth',
                                    'estimateMarketOrder',
                                    'getTradedPriceVolume',
                                    'getRawTradeData',
                                    'getStatistics',
                                    'getTerminalList',
                                    'getGridList',
                                    'getGridStatistics',
                                ],
                            },
                            'private': {
                                'get': [
                                    'cancelOrder',
                                    'getBalances',
                                    'getCommissionDiscount',
                                    'getOrders',
                                    'getTransactions',
                                    'placeOrder',
                                ],
                                'post': [
                                    'cancelOrder',
                                    'getBalances',
                                    'getCommissionDiscount',
                                    'getOrders',
                                    'getTransactions',
                                    'placeOrder',
                                ],
                            },
                        },
                    });
                };
                virwox.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, keys, result, p, market, id, symbol, base, quote;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.publicGetGetInstruments()];
                                case 1:
                                    markets = _a.sent();
                                    keys = Object.keys(markets['result']);
                                    result = [];
                                    for (p = 0; p < keys.length; p++) {
                                        market = markets['result'][keys[p]];
                                        id = market['instrumentID'];
                                        symbol = market['symbol'];
                                        base = market['longCurrency'];
                                        quote = market['shortCurrency'];
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                virwox.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, b, balance, currency, total, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetBalances()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['result']['accountList'];
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['currency'];
                                        total = balance['balance'];
                                        account = {
                                            'free': total,
                                            'used': 0.0,
                                            'total': total,
                                        };
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                virwox.prototype.fetchMarketPrice = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicPostGetBestPrices(this.extend({
                                            'symbols': [symbol],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    result = response['result'];
                                    return [2, {
                                            'bid': this.safeFloat(result[0], 'bestBuyPrice'),
                                            'ask': this.safeFloat(result[0], 'bestSellPrice'),
                                        }];
                            }
                        });
                    });
                };
                virwox.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var request, response, orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    request = {
                                        'symbols': [symbol],
                                    };
                                    if (typeof limit !== 'undefined') {
                                        request['buyDepth'] = limit;
                                        request['sellDepth'] = limit;
                                    }
                                    return [4, this.publicPostGetMarketDepth(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    orderbook = response['result'][0];
                                    return [2, this.parseOrderBook(orderbook, undefined, 'buy', 'sell', 'price', 'volume')];
                            }
                        });
                    });
                };
                virwox.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var end, start, response, tickers, keys, length, lastKey, ticker, timestamp, close;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    end = this.milliseconds();
                                    start = end - 86400000;
                                    return [4, this.publicGetGetTradedPriceVolume(this.extend({
                                            'instrument': symbol,
                                            'endDate': this.ymdhms(end),
                                            'startDate': this.ymdhms(start),
                                            'HLOC': 1,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    tickers = response['result']['priceVolumeList'];
                                    keys = Object.keys(tickers);
                                    length = keys.length;
                                    lastKey = keys[length - 1];
                                    ticker = tickers[lastKey];
                                    timestamp = this.milliseconds();
                                    close = parseFloat(ticker['close']);
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': undefined,
                                            'ask': undefined,
                                            'vwap': undefined,
                                            'open': parseFloat(ticker['open']),
                                            'close': close,
                                            'last': close,
                                            'previousClose': undefined,
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['longVolume']),
                                            'quoteVolume': parseFloat(ticker['shortVolume']),
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                virwox.prototype.parseTrade = function (trade, symbol) {
                    if (symbol === void 0) { symbol = undefined; }
                    var sec = this.safeInteger(trade, 'time');
                    var timestamp = sec * 1000;
                    return {
                        'id': trade['tid'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'order': undefined,
                        'symbol': symbol,
                        'type': undefined,
                        'side': undefined,
                        'price': this.safeFloat(trade, 'price'),
                        'amount': this.safeFloat(trade, 'vol'),
                        'fee': undefined,
                        'info': trade,
                    };
                };
                virwox.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response, result, trades;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetGetRawTradeData(this.extend({
                                            'instrument': symbol,
                                            'timespan': 3600,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    result = response['result'];
                                    trades = result['data'];
                                    return [2, this.parseTrades(trades, market)];
                            }
                        });
                    });
                };
                virwox.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    order = {
                                        'instrument': market['symbol'],
                                        'orderType': side.toUpperCase(),
                                        'amount': amount,
                                    };
                                    if (type === 'limit')
                                        order['price'] = price;
                                    return [4, this.privatePostPlaceOrder(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['result']['orderID'].toString(),
                                        }];
                            }
                        });
                    });
                };
                virwox.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancelOrder(this.extend({
                                        'orderID': id,
                                    }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                virwox.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    var auth = {};
                    if (api === 'private') {
                        this.checkRequiredCredentials();
                        auth['key'] = this.apiKey;
                        auth['user'] = this.login;
                        auth['pass'] = this.password;
                    }
                    var nonce = this.nonce();
                    if (method === 'GET') {
                        url += '?' + this.urlencode(this.extend({
                            'method': path,
                            'id': nonce,
                        }, auth, params));
                    }
                    else {
                        headers = { 'Content-Type': 'application/json' };
                        body = this.json({
                            'method': path,
                            'params': this.extend(auth, params),
                            'id': nonce,
                        });
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                virwox.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code === 200) {
                        if ((body[0] === '{') || (body[0] === '[')) {
                            var response = JSON.parse(body);
                            if ('result' in response) {
                                var result = response['result'];
                                if ('errorCode' in result) {
                                    var errorCode = result['errorCode'];
                                    if (errorCode !== 'OK') {
                                        throw new ExchangeError(this.id + ' error returned: ' + body);
                                    }
                                }
                            }
                            else {
                                throw new ExchangeError(this.id + ' malformed response: no result in response: ' + body);
                            }
                        }
                        else {
                            throw new ExchangeError(this.id + ' returned a non-JSON reply: ' + body);
                        }
                    }
                };
                return virwox;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 113: [function (require, module, exports) {
            'use strict';
            var liqui = require('./liqui.js');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound, DDoSProtection = _a.DDoSProtection;
            module.exports = (function (_super) {
                __extends(wex, _super);
                function wex() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                wex.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'wex',
                        'name': 'WEX',
                        'countries': 'NZ',
                        'version': '3',
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/30652751-d74ec8f8-9e31-11e7-98c5-71469fcef03e.jpg',
                            'api': {
                                'public': 'https://wex.nz/api',
                                'private': 'https://wex.nz/tapi',
                            },
                            'www': 'https://wex.nz',
                            'doc': [
                                'https://wex.nz/api/3/docs',
                                'https://wex.nz/tapi/docs',
                            ],
                            'fees': 'https://wex.nz/fees',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'info',
                                    'ticker/{pair}',
                                    'depth/{pair}',
                                    'trades/{pair}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'getInfo',
                                    'Trade',
                                    'ActiveOrders',
                                    'OrderInfo',
                                    'CancelOrder',
                                    'TradeHistory',
                                    'TransHistory',
                                    'CoinDepositAddress',
                                    'WithdrawCoin',
                                    'CreateCoupon',
                                    'RedeemCoupon',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.2 / 100,
                                'taker': 0.2 / 100,
                            },
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.001,
                                    'LTC': 0.001,
                                    'NMC': 0.1,
                                    'NVC': 0.1,
                                    'PPC': 0.1,
                                    'DASH': 0.001,
                                    'ETH': 0.003,
                                    'BCH': 0.001,
                                    'ZEC': 0.001,
                                },
                            },
                        },
                        'exceptions': {
                            'messages': {
                                'bad status': OrderNotFound,
                                'Requests too often': DDoSProtection,
                                'not available': DDoSProtection,
                                'external service unavailable': DDoSProtection,
                            },
                        },
                    });
                };
                wex.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = ticker['updated'] * 1000;
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': this.safeFloat(ticker, 'high'),
                        'low': this.safeFloat(ticker, 'low'),
                        'bid': this.safeFloat(ticker, 'sell'),
                        'ask': this.safeFloat(ticker, 'buy'),
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': this.safeFloat(ticker, 'last'),
                        'change': undefined,
                        'percentage': undefined,
                        'average': this.safeFloat(ticker, 'avg'),
                        'baseVolume': this.safeFloat(ticker, 'vol_cur'),
                        'quoteVolume': this.safeFloat(ticker, 'vol'),
                        'info': ticker,
                    };
                };
                wex.prototype.handleErrors = function (code, reason, url, method, headers, body) {
                    if (code === 200) {
                        if (body[0] !== '{') {
                            return;
                        }
                        var response = JSON.parse(body);
                        if ('success' in response) {
                            if (!response['success']) {
                                var error = this.safeString(response, 'error');
                                if (!error) {
                                    throw new ExchangeError(this.id + ' returned a malformed error: ' + body);
                                }
                                if (error === 'no orders') {
                                    return;
                                }
                                var feedback = this.id + ' ' + this.json(response);
                                var messages = this.exceptions.messages;
                                if (error in messages) {
                                    throw new messages[error](feedback);
                                }
                                if (error.indexOf('It is not enough') >= 0) {
                                    throw new InsufficientFunds(feedback);
                                }
                                else {
                                    throw new ExchangeError(feedback);
                                }
                            }
                        }
                    }
                };
                return wex;
            }(liqui));
        }, { "./base/errors": 10, "./liqui.js": 90 }], 114: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, NotSupported = _a.NotSupported, AuthenticationError = _a.AuthenticationError;
            module.exports = (function (_super) {
                __extends(xbtce, _super);
                function xbtce() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                xbtce.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'xbtce',
                        'name': 'xBTCe',
                        'countries': 'RU',
                        'rateLimit': 2000,
                        'version': 'v1',
                        'has': {
                            'publicAPI': false,
                            'CORS': false,
                            'fetchTickers': true,
                            'createMarketOrder': false,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28059414-e235970c-662c-11e7-8c3a-08e31f78684b.jpg',
                            'api': 'https://cryptottlivewebapi.xbtce.net:8443/api',
                            'www': 'https://www.xbtce.com',
                            'doc': [
                                'https://www.xbtce.com/tradeapi',
                                'https://support.xbtce.info/Knowledgebase/Article/View/52/25/xbtce-exchange-api',
                            ],
                        },
                        'requiredCredentials': {
                            'apiKey': true,
                            'secret': true,
                            'uid': true,
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'currency',
                                    'currency/{filter}',
                                    'level2',
                                    'level2/{filter}',
                                    'quotehistory/{symbol}/{periodicity}/bars/ask',
                                    'quotehistory/{symbol}/{periodicity}/bars/bid',
                                    'quotehistory/{symbol}/level2',
                                    'quotehistory/{symbol}/ticks',
                                    'symbol',
                                    'symbol/{filter}',
                                    'tick',
                                    'tick/{filter}',
                                    'ticker',
                                    'ticker/{filter}',
                                    'tradesession',
                                ],
                            },
                            'private': {
                                'get': [
                                    'tradeserverinfo',
                                    'tradesession',
                                    'currency',
                                    'currency/{filter}',
                                    'level2',
                                    'level2/{filter}',
                                    'symbol',
                                    'symbol/{filter}',
                                    'tick',
                                    'tick/{filter}',
                                    'account',
                                    'asset',
                                    'asset/{id}',
                                    'position',
                                    'position/{id}',
                                    'trade',
                                    'trade/{id}',
                                    'quotehistory/{symbol}/{periodicity}/bars/ask',
                                    'quotehistory/{symbol}/{periodicity}/bars/ask/info',
                                    'quotehistory/{symbol}/{periodicity}/bars/bid',
                                    'quotehistory/{symbol}/{periodicity}/bars/bid/info',
                                    'quotehistory/{symbol}/level2',
                                    'quotehistory/{symbol}/level2/info',
                                    'quotehistory/{symbol}/periodicities',
                                    'quotehistory/{symbol}/ticks',
                                    'quotehistory/{symbol}/ticks/info',
                                    'quotehistory/cache/{symbol}/{periodicity}/bars/ask',
                                    'quotehistory/cache/{symbol}/{periodicity}/bars/bid',
                                    'quotehistory/cache/{symbol}/level2',
                                    'quotehistory/cache/{symbol}/ticks',
                                    'quotehistory/symbols',
                                    'quotehistory/version',
                                ],
                                'post': [
                                    'trade',
                                    'tradehistory',
                                ],
                                'put': [
                                    'trade',
                                ],
                                'delete': [
                                    'trade',
                                ],
                            },
                        },
                    });
                };
                xbtce.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, base, quote, symbol;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateGetSymbol()];
                                case 1:
                                    markets = _a.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['Symbol'];
                                        base = market['MarginCurrency'];
                                        quote = market['ProfitCurrency'];
                                        if (base === 'DSH')
                                            base = 'DASH';
                                        symbol = base + '/' + quote;
                                        symbol = market['IsTradeAllowed'] ? symbol : id;
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                xbtce.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var balances, result, b, balance, currency, uppercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetAsset()];
                                case 2:
                                    balances = _a.sent();
                                    result = { 'info': balances };
                                    for (b = 0; b < balances.length; b++) {
                                        balance = balances[b];
                                        currency = balance['Currency'];
                                        uppercase = currency.toUpperCase();
                                        if (uppercase === 'DSH')
                                            uppercase = 'DASH';
                                        account = {
                                            'free': balance['FreeAmount'],
                                            'used': balance['LockedAmount'],
                                            'total': balance['Amount'],
                                        };
                                        result[uppercase] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                xbtce.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, orderbook, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.privateGetLevel2Filter(this.extend({
                                            'filter': market['id'],
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    orderbook = orderbook[0];
                                    timestamp = orderbook['Timestamp'];
                                    return [2, this.parseOrderBook(orderbook, timestamp, 'Bids', 'Asks', 'Price', 'Volume')];
                            }
                        });
                    });
                };
                xbtce.prototype.parseTicker = function (ticker, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = 0;
                    var last = undefined;
                    if ('LastBuyTimestamp' in ticker)
                        if (timestamp < ticker['LastBuyTimestamp']) {
                            timestamp = ticker['LastBuyTimestamp'];
                            last = ticker['LastBuyPrice'];
                        }
                    if ('LastSellTimestamp' in ticker)
                        if (timestamp < ticker['LastSellTimestamp']) {
                            timestamp = ticker['LastSellTimestamp'];
                            last = ticker['LastSellPrice'];
                        }
                    if (!timestamp)
                        timestamp = this.milliseconds();
                    var symbol = undefined;
                    if (market)
                        symbol = market['symbol'];
                    return {
                        'symbol': symbol,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'high': ticker['DailyBestBuyPrice'],
                        'low': ticker['DailyBestSellPrice'],
                        'bid': ticker['BestBid'],
                        'ask': ticker['BestAsk'],
                        'vwap': undefined,
                        'open': undefined,
                        'close': undefined,
                        'first': undefined,
                        'last': last,
                        'change': undefined,
                        'percentage': undefined,
                        'average': undefined,
                        'baseVolume': ticker['DailyTradedTotalVolume'],
                        'quoteVolume': undefined,
                        'info': ticker,
                    };
                };
                xbtce.prototype.fetchTickers = function (symbols, params) {
                    if (symbols === void 0) { symbols = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var tickers, ids, result, i, id, market, symbol, base, quote, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTicker(params)];
                                case 2:
                                    tickers = _a.sent();
                                    tickers = this.indexBy(tickers, 'Symbol');
                                    ids = Object.keys(tickers);
                                    result = {};
                                    for (i = 0; i < ids.length; i++) {
                                        id = ids[i];
                                        market = undefined;
                                        symbol = undefined;
                                        if (id in this.markets_by_id) {
                                            market = this.markets_by_id[id];
                                            symbol = market['symbol'];
                                        }
                                        else {
                                            base = id.slice(0, 3);
                                            quote = id.slice(3, 6);
                                            if (base === 'DSH')
                                                base = 'DASH';
                                            if (quote === 'DSH')
                                                quote = 'DASH';
                                            symbol = base + '/' + quote;
                                        }
                                        ticker = tickers[id];
                                        result[symbol] = this.parseTicker(ticker, market);
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                xbtce.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, tickers, length, ticker;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTickerFilter(this.extend({
                                            'filter': market['id'],
                                        }, params))];
                                case 2:
                                    tickers = _a.sent();
                                    length = tickers.length;
                                    if (length < 1)
                                        throw new ExchangeError(this.id + ' fetchTicker returned empty response, xBTCe public API error');
                                    tickers = this.indexBy(tickers, 'Symbol');
                                    ticker = tickers[market['id']];
                                    return [2, this.parseTicker(ticker, market)];
                            }
                        });
                    });
                };
                xbtce.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetTrade(params)];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                xbtce.prototype.parseOHLCV = function (ohlcv, market, timeframe, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    return [
                        ohlcv['Timestamp'],
                        ohlcv['Open'],
                        ohlcv['High'],
                        ohlcv['Low'],
                        ohlcv['Close'],
                        ohlcv['Volume'],
                    ];
                };
                xbtce.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new NotSupported(this.id + ' fetchOHLCV is disabled by the exchange');
                        });
                    });
                };
                xbtce.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.tapiPostTrade(this.extend({
                                            'pair': this.marketId(symbol),
                                            'type': side,
                                            'amount': amount,
                                            'rate': price,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['Id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                xbtce.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privateDeleteTrade(this.extend({
                                        'Type': 'Cancel',
                                        'Id': id,
                                    }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                xbtce.prototype.nonce = function () {
                    return this.milliseconds();
                };
                xbtce.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    if (!this.apiKey)
                        throw new AuthenticationError(this.id + ' requires apiKey for all requests, their public API is always busy');
                    if (!this.uid)
                        throw new AuthenticationError(this.id + ' requires uid property for authentication and trading, their public API is always busy');
                    var url = this.urls['api'] + '/' + this.version;
                    if (api === 'public')
                        url += '/' + api;
                    url += '/' + this.implodeParams(path, params);
                    var query = this.omit(params, this.extractParams(path));
                    if (api === 'public') {
                        if (Object.keys(query).length)
                            url += '?' + this.urlencode(query);
                    }
                    else {
                        this.checkRequiredCredentials();
                        headers = { 'Accept-Encoding': 'gzip, deflate' };
                        var nonce = this.nonce().toString();
                        if (method === 'POST') {
                            if (Object.keys(query).length) {
                                headers['Content-Type'] = 'application/json';
                                body = this.json(query);
                            }
                            else {
                                url += '?' + this.urlencode(query);
                            }
                        }
                        var auth = nonce + this.uid + this.apiKey + method + url;
                        if (body)
                            auth += body;
                        var signature = this.hmac(this.encode(auth), this.encode(this.secret), 'sha256', 'base64');
                        var credentials = this.uid + ':' + this.apiKey + ':' + nonce + ':' + this.binaryToString(signature);
                        headers['Authorization'] = 'HMAC ' + credentials;
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                return xbtce;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 115: [function (require, module, exports) {
            'use strict';
            var liqui = require('./liqui.js');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, InsufficientFunds = _a.InsufficientFunds, DDoSProtection = _a.DDoSProtection;
            module.exports = (function (_super) {
                __extends(yobit, _super);
                function yobit() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                yobit.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'yobit',
                        'name': 'YoBit',
                        'countries': 'RU',
                        'rateLimit': 3000,
                        'version': '3',
                        'has': {
                            'createDepositAddress': true,
                            'fetchDepositAddress': true,
                            'CORS': false,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg',
                            'api': {
                                'public': 'https://yobit.net/api',
                                'private': 'https://yobit.net/tapi',
                            },
                            'www': 'https://www.yobit.net',
                            'doc': 'https://www.yobit.net/en/api/',
                            'fees': 'https://www.yobit.net/en/fees/',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'depth/{pair}',
                                    'info',
                                    'ticker/{pair}',
                                    'trades/{pair}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'ActiveOrders',
                                    'CancelOrder',
                                    'GetDepositAddress',
                                    'getInfo',
                                    'OrderInfo',
                                    'Trade',
                                    'TradeHistory',
                                    'WithdrawCoinsToAddress',
                                ],
                            },
                        },
                        'fees': {
                            'trading': {
                                'maker': 0.002,
                                'taker': 0.002,
                            },
                            'funding': {
                                'withdraw': {},
                            },
                        },
                        'options': {
                            'fetchOrdersRequiresSymbol': true,
                        },
                    });
                };
                yobit.prototype.commonCurrencyCode = function (currency) {
                    var substitutions = {
                        'AIR': 'AirCoin',
                        'ANI': 'ANICoin',
                        'ANT': 'AntsCoin',
                        'ATM': 'Autumncoin',
                        'BCC': 'BCH',
                        'BCS': 'BitcoinStake',
                        'BTS': 'Bitshares2',
                        'DCT': 'Discount',
                        'DGD': 'DarkGoldCoin',
                        'ICN': 'iCoin',
                        'LIZI': 'LiZi',
                        'LUN': 'LunarCoin',
                        'MDT': 'Midnight',
                        'NAV': 'NavajoCoin',
                        'OMG': 'OMGame',
                        'PAY': 'EPAY',
                        'REP': 'Republicoin',
                    };
                    if (currency in substitutions)
                        return substitutions[currency];
                    return currency;
                };
                yobit.prototype.currencyId = function (commonCode) {
                    var substitutions = {
                        'AirCoin': 'AIR',
                        'ANICoin': 'ANI',
                        'AntsCoin': 'ANT',
                        'Autumncoin': 'ATM',
                        'BCH': 'BCC',
                        'BitcoinStake': 'BCS',
                        'Bitshares2': 'BTS',
                        'Discount': 'DCT',
                        'DarkGoldCoin': 'DGD',
                        'iCoin': 'ICN',
                        'LiZi': 'LIZI',
                        'LunarCoin': 'LUN',
                        'Midnight': 'MDT',
                        'NavajoCoin': 'NAV',
                        'OMGame': 'OMG',
                        'EPAY': 'PAY',
                        'Republicoin': 'REP',
                    };
                    if (commonCode in substitutions)
                        return substitutions[commonCode];
                    return commonCode;
                };
                yobit.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        '0': 'open',
                        '1': 'closed',
                        '2': 'canceled',
                        '3': 'open',
                    };
                    if (status in statuses)
                        return statuses[status];
                    return status;
                };
                yobit.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, sides, keys, i, key, side, currencies, j, lowercase, uppercase, currency, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetInfo()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['return'];
                                    result = { 'info': balances };
                                    sides = { 'free': 'funds', 'total': 'funds_incl_orders' };
                                    keys = Object.keys(sides);
                                    for (i = 0; i < keys.length; i++) {
                                        key = keys[i];
                                        side = sides[key];
                                        if (side in balances) {
                                            currencies = Object.keys(balances[side]);
                                            for (j = 0; j < currencies.length; j++) {
                                                lowercase = currencies[j];
                                                uppercase = lowercase.toUpperCase();
                                                currency = this.commonCurrencyCode(uppercase);
                                                account = undefined;
                                                if (currency in result) {
                                                    account = result[currency];
                                                }
                                                else {
                                                    account = this.account();
                                                }
                                                account[key] = balances[side][lowercase];
                                                if (account['total'] && account['free'])
                                                    account['used'] = account['total'] - account['free'];
                                                result[currency] = account;
                                            }
                                        }
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                yobit.prototype.createDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetchDepositAddress(currency, this.extend({
                                        'need_new': 1,
                                    }, params))];
                                case 1:
                                    response = _a.sent();
                                    address = this.safeString(response, 'address');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'status': 'ok',
                                            'info': response['info'],
                                        }];
                            }
                        });
                    });
                };
                yobit.prototype.fetchDepositAddress = function (currency, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var currencyId, request, response, address;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    currencyId = this.currencyId(currency);
                                    request = {
                                        'coinName': currencyId,
                                        'need_new': 0,
                                    };
                                    return [4, this.privatePostGetDepositAddress(this.extend(request, params))];
                                case 1:
                                    response = _a.sent();
                                    address = this.safeString(response['return'], 'address');
                                    this.checkAddress(address);
                                    return [2, {
                                            'currency': currency,
                                            'address': address,
                                            'status': 'ok',
                                            'info': response,
                                        }];
                            }
                        });
                    });
                };
                yobit.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostWithdrawCoinsToAddress(this.extend({
                                            'coinName': currency,
                                            'amount': amount,
                                            'address': address,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': undefined,
                                        }];
                            }
                        });
                    });
                };
                yobit.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('success' in response) {
                                        if (!response['success']) {
                                            if (response['error'].indexOf('Insufficient funds') >= 0) {
                                                throw new InsufficientFunds(this.id + ' ' + this.json(response));
                                            }
                                            else if (response['error'] === 'Requests too often') {
                                                throw new DDoSProtection(this.id + ' ' + this.json(response));
                                            }
                                            else if ((response['error'] === 'not available') || (response['error'] === 'external service unavailable')) {
                                                throw new DDoSProtection(this.id + ' ' + this.json(response));
                                            }
                                            else {
                                                throw new ExchangeError(this.id + ' ' + this.json(response));
                                            }
                                        }
                                    }
                                    return [2, response];
                            }
                        });
                    });
                };
                return yobit;
            }(liqui));
        }, { "./base/errors": 10, "./liqui.js": 90 }], 116: [function (require, module, exports) {
            'use strict';
            var acx = require('./acx.js');
            module.exports = (function (_super) {
                __extends(yunbi, _super);
                function yunbi() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                yunbi.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'yunbi',
                        'name': 'YUNBI',
                        'countries': 'CN',
                        'rateLimit': 1000,
                        'version': 'v2',
                        'has': {
                            'CORS': false,
                            'fetchTickers': true,
                            'fetchOHLCV': true,
                        },
                        'timeframes': {
                            '1m': '1',
                            '5m': '5',
                            '15m': '15',
                            '30m': '30',
                            '1h': '60',
                            '2h': '120',
                            '4h': '240',
                            '12h': '720',
                            '1d': '1440',
                            '3d': '4320',
                            '1w': '10080',
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/28570548-4d646c40-7147-11e7-9cf6-839b93e6d622.jpg',
                            'extension': '.json',
                            'api': 'https://yunbi.com',
                            'www': 'https://yunbi.com',
                            'doc': [
                                'https://yunbi.com/documents/api/guide',
                                'https://yunbi.com/swagger/',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'tickers',
                                    'tickers/{market}',
                                    'markets',
                                    'order_book',
                                    'k',
                                    'depth',
                                    'trades',
                                    'k_with_pending_trades',
                                    'timestamp',
                                    'addresses/{address}',
                                    'partners/orders/{id}/trades',
                                ],
                            },
                            'private': {
                                'get': [
                                    'deposits',
                                    'members/me',
                                    'deposit',
                                    'deposit_address',
                                    'order',
                                    'orders',
                                    'trades/my',
                                ],
                                'post': [
                                    'order/delete',
                                    'orders',
                                    'orders/multi',
                                    'orders/clear',
                                ],
                            },
                        },
                    });
                };
                return yunbi;
            }(acx));
        }, { "./acx.js": 5 }], 117: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var ExchangeError = require('./base/errors').ExchangeError;
            module.exports = (function (_super) {
                __extends(zaif, _super);
                function zaif() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                zaif.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'zaif',
                        'name': 'Zaif',
                        'countries': 'JP',
                        'rateLimit': 2000,
                        'version': '1',
                        'has': {
                            'CORS': false,
                            'createMarketOrder': false,
                            'fetchOpenOrders': true,
                            'fetchClosedOrders': true,
                            'withdraw': true,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg',
                            'api': 'https://api.zaif.jp',
                            'www': 'https://zaif.jp',
                            'doc': [
                                'http://techbureau-api-document.readthedocs.io/ja/latest/index.html',
                                'https://corp.zaif.jp/api-docs',
                                'https://corp.zaif.jp/api-docs/api_links',
                                'https://www.npmjs.com/package/zaif.jp',
                                'https://github.com/you21979/node-zaif',
                            ],
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'depth/{pair}',
                                    'currencies/{pair}',
                                    'currencies/all',
                                    'currency_pairs/{pair}',
                                    'currency_pairs/all',
                                    'last_price/{pair}',
                                    'ticker/{pair}',
                                    'trades/{pair}',
                                ],
                            },
                            'private': {
                                'post': [
                                    'active_orders',
                                    'cancel_order',
                                    'deposit_history',
                                    'get_id_info',
                                    'get_info',
                                    'get_info2',
                                    'get_personal_info',
                                    'trade',
                                    'trade_history',
                                    'withdraw',
                                    'withdraw_history',
                                ],
                            },
                            'ecapi': {
                                'post': [
                                    'createInvoice',
                                    'getInvoice',
                                    'getInvoiceIdsByOrderNumber',
                                    'cancelInvoice',
                                ],
                            },
                            'tlapi': {
                                'post': [
                                    'get_positions',
                                    'position_history',
                                    'active_positions',
                                    'create_position',
                                    'change_position',
                                    'cancel_position',
                                ],
                            },
                            'fapi': {
                                'get': [
                                    'groups/{group_id}',
                                    'last_price/{group_id}/{pair}',
                                    'ticker/{group_id}/{pair}',
                                    'trades/{group_id}/{pair}',
                                    'depth/{group_id}/{pair}',
                                ],
                            },
                        },
                    });
                };
                zaif.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, result, p, market, id, symbol, _a, base, quote;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetCurrencyPairsAll()];
                                case 1:
                                    markets = _c.sent();
                                    result = [];
                                    for (p = 0; p < markets.length; p++) {
                                        market = markets[p];
                                        id = market['currency_pair'];
                                        symbol = market['name'];
                                        _a = __read(symbol.split('/'), 2), base = _a[0], quote = _a[1];
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'base': base,
                                            'quote': quote,
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                zaif.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, currencies, c, currency, balance, uppercase, account;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privatePostGetInfo()];
                                case 2:
                                    response = _a.sent();
                                    balances = response['return'];
                                    result = { 'info': balances };
                                    currencies = Object.keys(balances['funds']);
                                    for (c = 0; c < currencies.length; c++) {
                                        currency = currencies[c];
                                        balance = balances['funds'][currency];
                                        uppercase = currency.toUpperCase();
                                        account = {
                                            'free': balance,
                                            'used': 0.0,
                                            'total': balance,
                                        };
                                        if ('deposit' in balances) {
                                            if (currency in balances['deposit']) {
                                                account['total'] = balances['deposit'][currency];
                                                account['used'] = account['total'] - account['free'];
                                            }
                                        }
                                        result[uppercase] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                zaif.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var orderbook;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetDepthPair(this.extend({
                                            'pair': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    return [2, this.parseOrderBook(orderbook)];
                            }
                        });
                    });
                };
                zaif.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var ticker, timestamp, vwap, baseVolume, quoteVolume;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.publicGetTickerPair(this.extend({
                                            'pair': this.marketId(symbol),
                                        }, params))];
                                case 2:
                                    ticker = _a.sent();
                                    timestamp = this.milliseconds();
                                    vwap = ticker['vwap'];
                                    baseVolume = ticker['volume'];
                                    quoteVolume = baseVolume * vwap;
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': ticker['high'],
                                            'low': ticker['low'],
                                            'bid': ticker['bid'],
                                            'ask': ticker['ask'],
                                            'vwap': vwap,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': ticker['last'],
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': baseVolume,
                                            'quoteVolume': quoteVolume,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                zaif.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var side = (trade['trade_type'] === 'bid') ? 'buy' : 'sell';
                    var timestamp = trade['date'] * 1000;
                    var id = this.safeString(trade, 'id');
                    id = this.safeString(trade, 'tid', id);
                    if (!market)
                        market = this.markets_by_id[trade['currency_pair']];
                    return {
                        'id': id.toString(),
                        'info': trade,
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': side,
                        'price': trade['price'],
                        'amount': trade['amount'],
                    };
                };
                zaif.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    return [4, this.publicGetTradesPair(this.extend({
                                            'pair': market['id'],
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                zaif.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (type === 'market')
                                        throw new ExchangeError(this.id + ' allows limit orders only');
                                    return [4, this.privatePostTrade(this.extend({
                                            'currency_pair': this.marketId(symbol),
                                            'action': (side === 'buy') ? 'bid' : 'ask',
                                            'amount': amount,
                                            'price': price,
                                        }, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['return']['order_id'].toString(),
                                        }];
                            }
                        });
                    });
                };
                zaif.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.privatePostCancelOrder(this.extend({
                                        'order_id': id,
                                    }, params))];
                                case 1: return [2, _a.sent()];
                            }
                        });
                    });
                };
                zaif.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = (order['action'] === 'bid') ? 'buy' : 'sell';
                    var timestamp = parseInt(order['timestamp']) * 1000;
                    if (!market)
                        market = this.markets_by_id[order['currency_pair']];
                    var price = order['price'];
                    var amount = order['amount'];
                    return {
                        'id': order['id'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'status': 'open',
                        'symbol': market['symbol'],
                        'type': 'limit',
                        'side': side,
                        'price': price,
                        'cost': price * amount,
                        'amount': amount,
                        'filled': undefined,
                        'remaining': undefined,
                        'trades': undefined,
                        'fee': undefined,
                    };
                };
                zaif.prototype.parseOrders = function (orders, market, since, limit) {
                    if (market === void 0) { market = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    var ids = Object.keys(orders);
                    var result = [];
                    for (var i = 0; i < ids.length; i++) {
                        var id = ids[i];
                        var order = orders[id];
                        var extended = this.extend(order, { 'id': id });
                        result.push(this.parseOrder(extended, market));
                    }
                    return this.filterBySinceLimit(result, since, limit);
                };
                zaif.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['currency_pair'] = market['id'];
                                    }
                                    return [4, this.privatePostActiveOrders(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response['return'], market, since, limit)];
                            }
                        });
                    });
                };
                zaif.prototype.fetchClosedOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = undefined;
                                    request = {};
                                    if (symbol) {
                                        market = this.market(symbol);
                                        request['currency_pair'] = market['id'];
                                    }
                                    return [4, this.privatePostTradeHistory(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrders(response['return'], market, since, limit)];
                            }
                        });
                    });
                };
                zaif.prototype.withdraw = function (currency, amount, address, tag, params) {
                    if (tag === void 0) { tag = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.checkAddress(address);
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    if (currency === 'JPY')
                                        throw new ExchangeError(this.id + ' does not allow ' + currency + ' withdrawals');
                                    return [4, this.privatePostWithdraw(this.extend({
                                            'currency': currency,
                                            'amount': amount,
                                            'address': address,
                                        }, params))];
                                case 2:
                                    result = _a.sent();
                                    return [2, {
                                            'info': result,
                                            'id': result['return']['txid'],
                                            'fee': result['return']['fee'],
                                        }];
                            }
                        });
                    });
                };
                zaif.prototype.nonce = function () {
                    var nonce = parseFloat(this.milliseconds() / 1000);
                    return nonce.toFixed(8);
                };
                zaif.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'] + '/';
                    if (api === 'public') {
                        url += 'api/' + this.version + '/' + this.implodeParams(path, params);
                    }
                    else if (api === 'fapi') {
                        url += 'fapi/' + this.version + '/' + this.implodeParams(path, params);
                    }
                    else {
                        this.checkRequiredCredentials();
                        if (api === 'ecapi') {
                            url += 'ecapi';
                        }
                        else if (api === 'tlapi') {
                            url += 'tlapi';
                        }
                        else {
                            url += 'tapi';
                        }
                        var nonce = this.nonce();
                        body = this.urlencode(this.extend({
                            'method': path,
                            'nonce': nonce,
                        }, params));
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Key': this.apiKey,
                            'Sign': this.hmac(this.encode(body), this.encode(this.secret), 'sha512'),
                        };
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                zaif.prototype.request = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'api'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.fetch2(path, api, method, params, headers, body)];
                                case 1:
                                    response = _a.sent();
                                    if ('error' in response)
                                        throw new ExchangeError(this.id + ' ' + response['error']);
                                    if ('success' in response)
                                        if (!response['success'])
                                            throw new ExchangeError(this.id + ' ' + this.json(response));
                                    return [2, response];
                            }
                        });
                    });
                };
                return zaif;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 118: [function (require, module, exports) {
            'use strict';
            var Exchange = require('./base/Exchange');
            var _a = require('./base/errors'), ExchangeError = _a.ExchangeError, AuthenticationError = _a.AuthenticationError, InsufficientFunds = _a.InsufficientFunds, OrderNotFound = _a.OrderNotFound, ExchangeNotAvailable = _a.ExchangeNotAvailable, DDoSProtection = _a.DDoSProtection, InvalidOrder = _a.InvalidOrder;
            module.exports = (function (_super) {
                __extends(zb, _super);
                function zb() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                zb.prototype.describe = function () {
                    return this.deepExtend(_super.prototype.describe.call(this), {
                        'id': 'zb',
                        'name': 'ZB',
                        'countries': 'CN',
                        'rateLimit': 1000,
                        'version': 'v1',
                        'has': {
                            'CORS': false,
                            'createMarketOrder': false,
                            'fetchOrder': true,
                            'fetchOrders': true,
                            'fetchOpenOrders': true,
                            'withdraw': true,
                        },
                        'timeframes': {
                            '1m': '1min',
                            '3m': '3min',
                            '5m': '5min',
                            '15m': '15min',
                            '30m': '30min',
                            '1h': '1hour',
                            '2h': '2hour',
                            '4h': '4hour',
                            '6h': '6hour',
                            '12h': '12hour',
                            '1d': '1day',
                            '3d': '3day',
                            '1w': '1week',
                        },
                        'exceptions': {
                            '1001': ExchangeError,
                            '1002': ExchangeError,
                            '1003': AuthenticationError,
                            '1004': AuthenticationError,
                            '1005': AuthenticationError,
                            '1006': AuthenticationError,
                            '1009': ExchangeNotAvailable,
                            '2001': InsufficientFunds,
                            '2002': InsufficientFunds,
                            '2003': InsufficientFunds,
                            '2005': InsufficientFunds,
                            '2006': InsufficientFunds,
                            '2007': InsufficientFunds,
                            '2009': InsufficientFunds,
                            '3001': OrderNotFound,
                            '3002': InvalidOrder,
                            '3003': InvalidOrder,
                            '3004': AuthenticationError,
                            '3005': ExchangeError,
                            '3006': AuthenticationError,
                            '3007': AuthenticationError,
                            '3008': OrderNotFound,
                            '4001': ExchangeNotAvailable,
                            '4002': DDoSProtection,
                        },
                        'urls': {
                            'logo': 'https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg',
                            'api': {
                                'public': 'http://api.zb.com/data',
                                'private': 'https://trade.zb.com/api',
                            },
                            'www': 'https://trade.zb.com/api',
                            'doc': 'https://www.zb.com/i/developer',
                            'fees': 'https://www.zb.com/i/rate',
                        },
                        'api': {
                            'public': {
                                'get': [
                                    'markets',
                                    'ticker',
                                    'depth',
                                    'trades',
                                    'kline',
                                ],
                            },
                            'private': {
                                'get': [
                                    'order',
                                    'cancelOrder',
                                    'getOrder',
                                    'getOrders',
                                    'getOrdersNew',
                                    'getOrdersIgnoreTradeType',
                                    'getUnfinishedOrdersIgnoreTradeType',
                                    'getAccountInfo',
                                    'getUserAddress',
                                    'getWithdrawAddress',
                                    'getWithdrawRecord',
                                    'getChargeRecord',
                                    'getCnyWithdrawRecord',
                                    'getCnyChargeRecord',
                                    'withdraw',
                                ],
                            },
                        },
                        'fees': {
                            'funding': {
                                'withdraw': {
                                    'BTC': 0.0001,
                                    'BCH': 0.0006,
                                    'LTC': 0.005,
                                    'ETH': 0.01,
                                    'ETC': 0.01,
                                    'BTS': 3,
                                    'EOS': 1,
                                    'QTUM': 0.01,
                                    'HSR': 0.001,
                                    'XRP': 0.1,
                                    'USDT': '0.1%',
                                    'QCASH': 5,
                                    'DASH': 0.002,
                                    'BCD': 0,
                                    'UBTC': 0,
                                    'SBTC': 0,
                                    'INK': 20,
                                    'TV': 0.1,
                                    'BTH': 0,
                                    'BCX': 0,
                                    'LBTC': 0,
                                    'CHAT': 20,
                                    'bitCNY': 20,
                                    'HLC': 20,
                                    'BTP': 0,
                                    'BCW': 0,
                                },
                            },
                            'trading': {
                                'maker': 0.2 / 100,
                                'taker': 0.2 / 100,
                            },
                        },
                    });
                };
                zb.prototype.fetchMarkets = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var markets, keys, result, i, id, market, _a, baseId, quoteId, base, quote, symbol, precision, lot;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4, this.publicGetMarkets()];
                                case 1:
                                    markets = _c.sent();
                                    keys = Object.keys(markets);
                                    result = [];
                                    for (i = 0; i < keys.length; i++) {
                                        id = keys[i];
                                        market = markets[id];
                                        _a = __read(id.split('_'), 2), baseId = _a[0], quoteId = _a[1];
                                        base = this.commonCurrencyCode(baseId.toUpperCase());
                                        quote = this.commonCurrencyCode(quoteId.toUpperCase());
                                        symbol = base + '/' + quote;
                                        precision = {
                                            'amount': market['amountScale'],
                                            'price': market['priceScale'],
                                        };
                                        lot = Math.pow(10, -precision['amount']);
                                        result.push({
                                            'id': id,
                                            'symbol': symbol,
                                            'baseId': baseId,
                                            'quoteId': quoteId,
                                            'base': base,
                                            'quote': quote,
                                            'lot': lot,
                                            'active': true,
                                            'precision': precision,
                                            'limits': {
                                                'amount': {
                                                    'min': lot,
                                                    'max': undefined,
                                                },
                                                'price': {
                                                    'min': Math.pow(10, -precision['price']),
                                                    'max': undefined,
                                                },
                                                'cost': {
                                                    'min': 0,
                                                    'max': undefined,
                                                },
                                            },
                                            'info': market,
                                        });
                                    }
                                    return [2, result];
                            }
                        });
                    });
                };
                zb.prototype.fetchBalance = function (params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var response, balances, result, i, balance, account, currency;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    return [4, this.privateGetGetAccountInfo(params)];
                                case 2:
                                    response = _a.sent();
                                    balances = response['result']['coins'];
                                    result = { 'info': response };
                                    for (i = 0; i < balances.length; i++) {
                                        balance = balances[i];
                                        account = this.account();
                                        currency = balance['key'];
                                        if (currency in this.currencies_by_id)
                                            currency = this.currencies_by_id[currency]['code'];
                                        else
                                            currency = this.commonCurrencyCode(balance['enName']);
                                        account['free'] = parseFloat(balance['available']);
                                        account['used'] = parseFloat(balance['freez']);
                                        account['total'] = this.sum(account['free'], account['used']);
                                        result[currency] = account;
                                    }
                                    return [2, this.parseBalance(result)];
                            }
                        });
                    });
                };
                zb.prototype.getMarketFieldName = function () {
                    return 'market';
                };
                zb.prototype.fetchOrderBook = function (symbol, limit, params) {
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, marketFieldName, request, orderbook, timestamp, bids, asks, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    marketFieldName = this.getMarketFieldName();
                                    request = {};
                                    request[marketFieldName] = market['id'];
                                    return [4, this.publicGetDepth(this.extend(request, params))];
                                case 2:
                                    orderbook = _a.sent();
                                    timestamp = this.milliseconds();
                                    bids = undefined;
                                    asks = undefined;
                                    if ('bids' in orderbook)
                                        bids = orderbook['bids'];
                                    if ('asks' in orderbook)
                                        asks = orderbook['asks'];
                                    result = {
                                        'bids': bids,
                                        'asks': asks,
                                        'timestamp': timestamp,
                                        'datetime': this.iso8601(timestamp),
                                    };
                                    if (result['bids'])
                                        result['bids'] = this.sortBy(result['bids'], 0, true);
                                    if (result['asks'])
                                        result['asks'] = this.sortBy(result['asks'], 0);
                                    return [2, result];
                            }
                        });
                    });
                };
                zb.prototype.fetchTicker = function (symbol, params) {
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, marketFieldName, request, response, ticker, timestamp;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    marketFieldName = this.getMarketFieldName();
                                    request = {};
                                    request[marketFieldName] = market['id'];
                                    return [4, this.publicGetTicker(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    ticker = response['ticker'];
                                    timestamp = this.milliseconds();
                                    return [2, {
                                            'symbol': symbol,
                                            'timestamp': timestamp,
                                            'datetime': this.iso8601(timestamp),
                                            'high': parseFloat(ticker['high']),
                                            'low': parseFloat(ticker['low']),
                                            'bid': parseFloat(ticker['buy']),
                                            'ask': parseFloat(ticker['sell']),
                                            'vwap': undefined,
                                            'open': undefined,
                                            'close': undefined,
                                            'first': undefined,
                                            'last': parseFloat(ticker['last']),
                                            'change': undefined,
                                            'percentage': undefined,
                                            'average': undefined,
                                            'baseVolume': parseFloat(ticker['vol']),
                                            'quoteVolume': undefined,
                                            'info': ticker,
                                        }];
                            }
                        });
                    });
                };
                zb.prototype.fetchOHLCV = function (symbol, timeframe, since, limit, params) {
                    if (timeframe === void 0) { timeframe = '1m'; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    if (typeof limit === 'undefined')
                                        limit = 1000;
                                    request = {
                                        'market': market['id'],
                                        'type': this.timeframes[timeframe],
                                        'limit': limit,
                                    };
                                    if (typeof since !== 'undefined')
                                        request['since'] = since;
                                    return [4, this.publicGetKline(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOHLCVs(response['data'], market, timeframe, since, limit)];
                            }
                        });
                    });
                };
                zb.prototype.parseTrade = function (trade, market) {
                    if (market === void 0) { market = undefined; }
                    var timestamp = trade['date'] * 1000;
                    var side = (trade['trade_type'] === 'bid') ? 'buy' : 'sell';
                    return {
                        'info': trade,
                        'id': trade['tid'].toString(),
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': market['symbol'],
                        'type': undefined,
                        'side': side,
                        'price': parseFloat(trade['price']),
                        'amount': parseFloat(trade['amount']),
                    };
                };
                zb.prototype.fetchTrades = function (symbol, since, limit, params) {
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, marketFieldName, request, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    marketFieldName = this.getMarketFieldName();
                                    request = {};
                                    request[marketFieldName] = market['id'];
                                    return [4, this.publicGetTrades(this.extend(request, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseTrades(response, market, since, limit)];
                            }
                        });
                    });
                };
                zb.prototype.createOrder = function (symbol, type, side, amount, price, params) {
                    if (price === void 0) { price = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (type !== 'limit')
                                        throw new InvalidOrder(this.id + ' allows limit orders only');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'price': this.priceToPrecision(symbol, price),
                                        'amount': this.amountToString(symbol, amount),
                                        'tradeType': (side === 'buy') ? '1' : '0',
                                        'currency': this.marketId(symbol),
                                    };
                                    return [4, this.privateGetOrder(this.extend(order, params))];
                                case 2:
                                    response = _a.sent();
                                    return [2, {
                                            'info': response,
                                            'id': response['id'],
                                        }];
                            }
                        });
                    });
                };
                zb.prototype.cancelOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'id': id.toString(),
                                        'currency': this.marketId(symbol),
                                    };
                                    order = this.extend(order, params);
                                    return [4, this.privateGetCancelOrder(order)];
                                case 2: return [2, _a.sent()];
                            }
                        });
                    });
                };
                zb.prototype.fetchOrder = function (id, symbol, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var order, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    order = {
                                        'id': id.toString(),
                                        'currency': this.marketId(symbol),
                                    };
                                    order = this.extend(order, params);
                                    return [4, this.privateGetGetOrder(order)];
                                case 2:
                                    response = _a.sent();
                                    return [2, this.parseOrder(response, undefined, true)];
                            }
                        });
                    });
                };
                zb.prototype.fetchOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 50; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, method, response, e_22, code;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + 'fetchOrders requires a symbol parameter');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'currency': market['id'],
                                        'pageIndex': 1,
                                        'pageSize': limit,
                                    };
                                    method = 'privateGetGetOrdersIgnoreTradeType';
                                    if ('tradeType' in params)
                                        method = 'privateGetGetOrdersNew';
                                    response = undefined;
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 4, , 5]);
                                    return [4, this[method](this.extend(request, params))];
                                case 3:
                                    response = _a.sent();
                                    return [3, 5];
                                case 4:
                                    e_22 = _a.sent();
                                    if (this.last_json_response) {
                                        code = this.safeString(this.last_json_response, 'code');
                                        if (code === '3001')
                                            return [2, []];
                                    }
                                    throw e_22;
                                case 5: return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                zb.prototype.fetchOpenOrders = function (symbol, since, limit, params) {
                    if (symbol === void 0) { symbol = undefined; }
                    if (since === void 0) { since = undefined; }
                    if (limit === void 0) { limit = 10; }
                    if (params === void 0) { params = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var market, request, method, response, e_23, code;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!symbol)
                                        throw new ExchangeError(this.id + 'fetchOpenOrders requires a symbol parameter');
                                    return [4, this.loadMarkets()];
                                case 1:
                                    _a.sent();
                                    market = this.market(symbol);
                                    request = {
                                        'currency': market['id'],
                                        'pageIndex': 1,
                                        'pageSize': limit,
                                    };
                                    method = 'privateGetGetUnfinishedOrdersIgnoreTradeType';
                                    if ('tradeType' in params)
                                        method = 'privateGetGetOrdersNew';
                                    response = undefined;
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 4, , 5]);
                                    return [4, this[method](this.extend(request, params))];
                                case 3:
                                    response = _a.sent();
                                    return [3, 5];
                                case 4:
                                    e_23 = _a.sent();
                                    if (this.last_json_response) {
                                        code = this.safeString(this.last_json_response, 'code');
                                        if (code === '3001')
                                            return [2, []];
                                    }
                                    throw e_23;
                                case 5: return [2, this.parseOrders(response, market, since, limit)];
                            }
                        });
                    });
                };
                zb.prototype.parseOrder = function (order, market) {
                    if (market === void 0) { market = undefined; }
                    var side = order['type'] === 1 ? 'buy' : 'sell';
                    var type = 'limit';
                    var timestamp = undefined;
                    var createDateField = this.getCreateDateField();
                    if (createDateField in order)
                        timestamp = order[createDateField];
                    var symbol = undefined;
                    if ('currency' in order) {
                        market = this.marketsById[order['currency']];
                    }
                    if (market)
                        symbol = market['symbol'];
                    var price = order['price'];
                    var average = order['trade_price'];
                    var filled = order['trade_amount'];
                    var amount = order['total_amount'];
                    var remaining = amount - filled;
                    var cost = order['trade_money'];
                    var status = this.safeString(order, 'status');
                    if (typeof status !== 'undefined')
                        status = this.parseOrderStatus(status);
                    var result = {
                        'info': order,
                        'id': order['id'],
                        'timestamp': timestamp,
                        'datetime': this.iso8601(timestamp),
                        'symbol': symbol,
                        'type': type,
                        'side': side,
                        'price': price,
                        'average': average,
                        'cost': cost,
                        'amount': amount,
                        'filled': filled,
                        'remaining': remaining,
                        'status': status,
                        'fee': undefined,
                    };
                    return result;
                };
                zb.prototype.parseOrderStatus = function (status) {
                    var statuses = {
                        '0': 'open',
                        '1': 'canceled',
                        '2': 'closed',
                        '3': 'open',
                    };
                    if (status in statuses)
                        return statuses[status];
                    return status;
                };
                zb.prototype.getCreateDateField = function () {
                    return 'trade_date';
                };
                zb.prototype.nonce = function () {
                    return this.milliseconds();
                };
                zb.prototype.sign = function (path, api, method, params, headers, body) {
                    if (api === void 0) { api = 'public'; }
                    if (method === void 0) { method = 'GET'; }
                    if (params === void 0) { params = {}; }
                    if (headers === void 0) { headers = undefined; }
                    if (body === void 0) { body = undefined; }
                    var url = this.urls['api'][api];
                    if (api === 'public') {
                        url += '/' + this.version + '/' + path;
                        if (Object.keys(params).length)
                            url += '?' + this.urlencode(params);
                    }
                    else {
                        var query = this.keysort(this.extend({
                            'method': path,
                            'accesskey': this.apiKey,
                        }, params));
                        var nonce = this.nonce();
                        query = this.keysort(query);
                        var auth = this.rawencode(query);
                        var secret = this.hash(this.encode(this.secret), 'sha1');
                        var signature = this.hmac(this.encode(auth), this.encode(secret), 'md5');
                        var suffix = 'sign=' + signature + '&reqTime=' + nonce.toString();
                        url += '/' + path + '?' + auth + '&' + suffix;
                    }
                    return { 'url': url, 'method': method, 'body': body, 'headers': headers };
                };
                zb.prototype.handleErrors = function (httpCode, reason, url, method, headers, body) {
                    if (typeof body !== 'string')
                        return;
                    if (body.length < 2)
                        return;
                    if (body[0] === '{') {
                        var response = JSON.parse(body);
                        if ('code' in response) {
                            var error = this.safeString(response, 'code');
                            var message = this.id + ' ' + this.json(response);
                            if (error in this.exceptions) {
                                var ExceptionClass = this.exceptions[error];
                                throw new ExceptionClass(message);
                            }
                            else if (error !== '1000') {
                                throw new ExchangeError(message);
                            }
                        }
                    }
                };
                return zb;
            }(Exchange));
        }, { "./base/Exchange": 8, "./base/errors": 10 }], 119: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var BlockCipher = C_lib.BlockCipher;
                    var C_algo = C.algo;
                    var SBOX = [];
                    var INV_SBOX = [];
                    var SUB_MIX_0 = [];
                    var SUB_MIX_1 = [];
                    var SUB_MIX_2 = [];
                    var SUB_MIX_3 = [];
                    var INV_SUB_MIX_0 = [];
                    var INV_SUB_MIX_1 = [];
                    var INV_SUB_MIX_2 = [];
                    var INV_SUB_MIX_3 = [];
                    (function () {
                        var d = [];
                        for (var i = 0; i < 256; i++) {
                            if (i < 128) {
                                d[i] = i << 1;
                            }
                            else {
                                d[i] = (i << 1) ^ 0x11b;
                            }
                        }
                        var x = 0;
                        var xi = 0;
                        for (var i = 0; i < 256; i++) {
                            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
                            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
                            SBOX[x] = sx;
                            INV_SBOX[sx] = x;
                            var x2 = d[x];
                            var x4 = d[x2];
                            var x8 = d[x4];
                            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
                            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
                            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
                            SUB_MIX_2[x] = (t << 8) | (t >>> 24);
                            SUB_MIX_3[x] = t;
                            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
                            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
                            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
                            INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);
                            INV_SUB_MIX_3[sx] = t;
                            if (!x) {
                                x = xi = 1;
                            }
                            else {
                                x = x2 ^ d[d[d[x8 ^ x2]]];
                                xi ^= d[d[xi]];
                            }
                        }
                    }());
                    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
                    var AES = C_algo.AES = BlockCipher.extend({
                        _doReset: function () {
                            if (this._nRounds && this._keyPriorReset === this._key) {
                                return;
                            }
                            var key = this._keyPriorReset = this._key;
                            var keyWords = key.words;
                            var keySize = key.sigBytes / 4;
                            var nRounds = this._nRounds = keySize + 6;
                            var ksRows = (nRounds + 1) * 4;
                            var keySchedule = this._keySchedule = [];
                            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                                if (ksRow < keySize) {
                                    keySchedule[ksRow] = keyWords[ksRow];
                                }
                                else {
                                    var t = keySchedule[ksRow - 1];
                                    if (!(ksRow % keySize)) {
                                        t = (t << 8) | (t >>> 24);
                                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                                        t ^= RCON[(ksRow / keySize) | 0] << 24;
                                    }
                                    else if (keySize > 6 && ksRow % keySize == 4) {
                                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                                    }
                                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                                }
                            }
                            var invKeySchedule = this._invKeySchedule = [];
                            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                                var ksRow = ksRows - invKsRow;
                                if (invKsRow % 4) {
                                    var t = keySchedule[ksRow];
                                }
                                else {
                                    var t = keySchedule[ksRow - 4];
                                }
                                if (invKsRow < 4 || ksRow <= 4) {
                                    invKeySchedule[invKsRow] = t;
                                }
                                else {
                                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                        INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                                }
                            }
                        },
                        encryptBlock: function (M, offset) {
                            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
                        },
                        decryptBlock: function (M, offset) {
                            var t = M[offset + 1];
                            M[offset + 1] = M[offset + 3];
                            M[offset + 3] = t;
                            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
                            var t = M[offset + 1];
                            M[offset + 1] = M[offset + 3];
                            M[offset + 3] = t;
                        },
                        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
                            var nRounds = this._nRounds;
                            var s0 = M[offset] ^ keySchedule[0];
                            var s1 = M[offset + 1] ^ keySchedule[1];
                            var s2 = M[offset + 2] ^ keySchedule[2];
                            var s3 = M[offset + 3] ^ keySchedule[3];
                            var ksRow = 4;
                            for (var round = 1; round < nRounds; round++) {
                                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];
                                s0 = t0;
                                s1 = t1;
                                s2 = t2;
                                s3 = t3;
                            }
                            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
                            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
                            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
                            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
                            M[offset] = t0;
                            M[offset + 1] = t1;
                            M[offset + 2] = t2;
                            M[offset + 3] = t3;
                        },
                        keySize: 256 / 32
                    });
                    C.AES = BlockCipher._createHelper(AES);
                }());
                return CryptoJS.AES;
            }));
        }, { "./cipher-core": 120, "./core": 121, "./enc-base64": 122, "./evpkdf": 124, "./md5": 129 }], 120: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./evpkdf"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./evpkdf"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.lib.Cipher || (function (undefined) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var WordArray = C_lib.WordArray;
                    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
                    var C_enc = C.enc;
                    var Utf8 = C_enc.Utf8;
                    var Base64 = C_enc.Base64;
                    var C_algo = C.algo;
                    var EvpKDF = C_algo.EvpKDF;
                    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
                        cfg: Base.extend(),
                        createEncryptor: function (key, cfg) {
                            return this.create(this._ENC_XFORM_MODE, key, cfg);
                        },
                        createDecryptor: function (key, cfg) {
                            return this.create(this._DEC_XFORM_MODE, key, cfg);
                        },
                        init: function (xformMode, key, cfg) {
                            this.cfg = this.cfg.extend(cfg);
                            this._xformMode = xformMode;
                            this._key = key;
                            this.reset();
                        },
                        reset: function () {
                            BufferedBlockAlgorithm.reset.call(this);
                            this._doReset();
                        },
                        process: function (dataUpdate) {
                            this._append(dataUpdate);
                            return this._process();
                        },
                        finalize: function (dataUpdate) {
                            if (dataUpdate) {
                                this._append(dataUpdate);
                            }
                            var finalProcessedData = this._doFinalize();
                            return finalProcessedData;
                        },
                        keySize: 128 / 32,
                        ivSize: 128 / 32,
                        _ENC_XFORM_MODE: 1,
                        _DEC_XFORM_MODE: 2,
                        _createHelper: (function () {
                            function selectCipherStrategy(key) {
                                if (typeof key == 'string') {
                                    return PasswordBasedCipher;
                                }
                                else {
                                    return SerializableCipher;
                                }
                            }
                            return function (cipher) {
                                return {
                                    encrypt: function (message, key, cfg) {
                                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                                    },
                                    decrypt: function (ciphertext, key, cfg) {
                                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                                    }
                                };
                            };
                        }())
                    });
                    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
                        _doFinalize: function () {
                            var finalProcessedBlocks = this._process(!!'flush');
                            return finalProcessedBlocks;
                        },
                        blockSize: 1
                    });
                    var C_mode = C.mode = {};
                    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
                        createEncryptor: function (cipher, iv) {
                            return this.Encryptor.create(cipher, iv);
                        },
                        createDecryptor: function (cipher, iv) {
                            return this.Decryptor.create(cipher, iv);
                        },
                        init: function (cipher, iv) {
                            this._cipher = cipher;
                            this._iv = iv;
                        }
                    });
                    var CBC = C_mode.CBC = (function () {
                        var CBC = BlockCipherMode.extend();
                        CBC.Encryptor = CBC.extend({
                            processBlock: function (words, offset) {
                                var cipher = this._cipher;
                                var blockSize = cipher.blockSize;
                                xorBlock.call(this, words, offset, blockSize);
                                cipher.encryptBlock(words, offset);
                                this._prevBlock = words.slice(offset, offset + blockSize);
                            }
                        });
                        CBC.Decryptor = CBC.extend({
                            processBlock: function (words, offset) {
                                var cipher = this._cipher;
                                var blockSize = cipher.blockSize;
                                var thisBlock = words.slice(offset, offset + blockSize);
                                cipher.decryptBlock(words, offset);
                                xorBlock.call(this, words, offset, blockSize);
                                this._prevBlock = thisBlock;
                            }
                        });
                        function xorBlock(words, offset, blockSize) {
                            var iv = this._iv;
                            if (iv) {
                                var block = iv;
                                this._iv = undefined;
                            }
                            else {
                                var block = this._prevBlock;
                            }
                            for (var i = 0; i < blockSize; i++) {
                                words[offset + i] ^= block[i];
                            }
                        }
                        return CBC;
                    }());
                    var C_pad = C.pad = {};
                    var Pkcs7 = C_pad.Pkcs7 = {
                        pad: function (data, blockSize) {
                            var blockSizeBytes = blockSize * 4;
                            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;
                            var paddingWords = [];
                            for (var i = 0; i < nPaddingBytes; i += 4) {
                                paddingWords.push(paddingWord);
                            }
                            var padding = WordArray.create(paddingWords, nPaddingBytes);
                            data.concat(padding);
                        },
                        unpad: function (data) {
                            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
                            data.sigBytes -= nPaddingBytes;
                        }
                    };
                    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
                        cfg: Cipher.cfg.extend({
                            mode: CBC,
                            padding: Pkcs7
                        }),
                        reset: function () {
                            Cipher.reset.call(this);
                            var cfg = this.cfg;
                            var iv = cfg.iv;
                            var mode = cfg.mode;
                            if (this._xformMode == this._ENC_XFORM_MODE) {
                                var modeCreator = mode.createEncryptor;
                            }
                            else {
                                var modeCreator = mode.createDecryptor;
                                this._minBufferSize = 1;
                            }
                            if (this._mode && this._mode.__creator == modeCreator) {
                                this._mode.init(this, iv && iv.words);
                            }
                            else {
                                this._mode = modeCreator.call(mode, this, iv && iv.words);
                                this._mode.__creator = modeCreator;
                            }
                        },
                        _doProcessBlock: function (words, offset) {
                            this._mode.processBlock(words, offset);
                        },
                        _doFinalize: function () {
                            var padding = this.cfg.padding;
                            if (this._xformMode == this._ENC_XFORM_MODE) {
                                padding.pad(this._data, this.blockSize);
                                var finalProcessedBlocks = this._process(!!'flush');
                            }
                            else {
                                var finalProcessedBlocks = this._process(!!'flush');
                                padding.unpad(finalProcessedBlocks);
                            }
                            return finalProcessedBlocks;
                        },
                        blockSize: 128 / 32
                    });
                    var CipherParams = C_lib.CipherParams = Base.extend({
                        init: function (cipherParams) {
                            this.mixIn(cipherParams);
                        },
                        toString: function (formatter) {
                            return (formatter || this.formatter).stringify(this);
                        }
                    });
                    var C_format = C.format = {};
                    var OpenSSLFormatter = C_format.OpenSSL = {
                        stringify: function (cipherParams) {
                            var ciphertext = cipherParams.ciphertext;
                            var salt = cipherParams.salt;
                            if (salt) {
                                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
                            }
                            else {
                                var wordArray = ciphertext;
                            }
                            return wordArray.toString(Base64);
                        },
                        parse: function (openSSLStr) {
                            var ciphertext = Base64.parse(openSSLStr);
                            var ciphertextWords = ciphertext.words;
                            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                                var salt = WordArray.create(ciphertextWords.slice(2, 4));
                                ciphertextWords.splice(0, 4);
                                ciphertext.sigBytes -= 16;
                            }
                            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
                        }
                    };
                    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
                        cfg: Base.extend({
                            format: OpenSSLFormatter
                        }),
                        encrypt: function (cipher, message, key, cfg) {
                            cfg = this.cfg.extend(cfg);
                            var encryptor = cipher.createEncryptor(key, cfg);
                            var ciphertext = encryptor.finalize(message);
                            var cipherCfg = encryptor.cfg;
                            return CipherParams.create({
                                ciphertext: ciphertext,
                                key: key,
                                iv: cipherCfg.iv,
                                algorithm: cipher,
                                mode: cipherCfg.mode,
                                padding: cipherCfg.padding,
                                blockSize: cipher.blockSize,
                                formatter: cfg.format
                            });
                        },
                        decrypt: function (cipher, ciphertext, key, cfg) {
                            cfg = this.cfg.extend(cfg);
                            ciphertext = this._parse(ciphertext, cfg.format);
                            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
                            return plaintext;
                        },
                        _parse: function (ciphertext, format) {
                            if (typeof ciphertext == 'string') {
                                return format.parse(ciphertext, this);
                            }
                            else {
                                return ciphertext;
                            }
                        }
                    });
                    var C_kdf = C.kdf = {};
                    var OpenSSLKdf = C_kdf.OpenSSL = {
                        execute: function (password, keySize, ivSize, salt) {
                            if (!salt) {
                                salt = WordArray.random(64 / 8);
                            }
                            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
                            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                            key.sigBytes = keySize * 4;
                            return CipherParams.create({ key: key, iv: iv, salt: salt });
                        }
                    };
                    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
                        cfg: SerializableCipher.cfg.extend({
                            kdf: OpenSSLKdf
                        }),
                        encrypt: function (cipher, message, password, cfg) {
                            cfg = this.cfg.extend(cfg);
                            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
                            cfg.iv = derivedParams.iv;
                            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
                            ciphertext.mixIn(derivedParams);
                            return ciphertext;
                        },
                        decrypt: function (cipher, ciphertext, password, cfg) {
                            cfg = this.cfg.extend(cfg);
                            ciphertext = this._parse(ciphertext, cfg.format);
                            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
                            cfg.iv = derivedParams.iv;
                            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
                            return plaintext;
                        }
                    });
                }());
            }));
        }, { "./core": 121, "./evpkdf": 124 }], 121: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory();
                }
                else if (typeof define === "function" && define.amd) {
                    define([], factory);
                }
                else {
                    root.CryptoJS = factory();
                }
            }(this, function () {
                var CryptoJS = CryptoJS || (function (Math, undefined) {
                    var create = Object.create || (function () {
                        function F() { }
                        ;
                        return function (obj) {
                            var subtype;
                            F.prototype = obj;
                            subtype = new F();
                            F.prototype = null;
                            return subtype;
                        };
                    }());
                    var C = {};
                    var C_lib = C.lib = {};
                    var Base = C_lib.Base = (function () {
                        return {
                            extend: function (overrides) {
                                var subtype = create(this);
                                if (overrides) {
                                    subtype.mixIn(overrides);
                                }
                                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                                    subtype.init = function () {
                                        subtype.$super.init.apply(this, arguments);
                                    };
                                }
                                subtype.init.prototype = subtype;
                                subtype.$super = this;
                                return subtype;
                            },
                            create: function () {
                                var instance = this.extend();
                                instance.init.apply(instance, arguments);
                                return instance;
                            },
                            init: function () {
                            },
                            mixIn: function (properties) {
                                for (var propertyName in properties) {
                                    if (properties.hasOwnProperty(propertyName)) {
                                        this[propertyName] = properties[propertyName];
                                    }
                                }
                                if (properties.hasOwnProperty('toString')) {
                                    this.toString = properties.toString;
                                }
                            },
                            clone: function () {
                                return this.init.prototype.extend(this);
                            }
                        };
                    }());
                    var WordArray = C_lib.WordArray = Base.extend({
                        init: function (words, sigBytes) {
                            words = this.words = words || [];
                            if (sigBytes != undefined) {
                                this.sigBytes = sigBytes;
                            }
                            else {
                                this.sigBytes = words.length * 4;
                            }
                        },
                        toString: function (encoder) {
                            return (encoder || Hex).stringify(this);
                        },
                        concat: function (wordArray) {
                            var thisWords = this.words;
                            var thatWords = wordArray.words;
                            var thisSigBytes = this.sigBytes;
                            var thatSigBytes = wordArray.sigBytes;
                            this.clamp();
                            if (thisSigBytes % 4) {
                                for (var i = 0; i < thatSigBytes; i++) {
                                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                                }
                            }
                            else {
                                for (var i = 0; i < thatSigBytes; i += 4) {
                                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                                }
                            }
                            this.sigBytes += thatSigBytes;
                            return this;
                        },
                        clamp: function () {
                            var words = this.words;
                            var sigBytes = this.sigBytes;
                            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
                            words.length = Math.ceil(sigBytes / 4);
                        },
                        clone: function () {
                            var clone = Base.clone.call(this);
                            clone.words = this.words.slice(0);
                            return clone;
                        },
                        random: function (nBytes) {
                            var words = [];
                            var r = (function (m_w) {
                                var m_w = m_w;
                                var m_z = 0x3ade68b1;
                                var mask = 0xffffffff;
                                return function () {
                                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
                                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
                                    var result = ((m_z << 0x10) + m_w) & mask;
                                    result /= 0x100000000;
                                    result += 0.5;
                                    return result * (Math.random() > .5 ? 1 : -1);
                                };
                            });
                            for (var i = 0, rcache; i < nBytes; i += 4) {
                                var _r = r((rcache || Math.random()) * 0x100000000);
                                rcache = _r() * 0x3ade67b7;
                                words.push((_r() * 0x100000000) | 0);
                            }
                            return new WordArray.init(words, nBytes);
                        }
                    });
                    var C_enc = C.enc = {};
                    var Hex = C_enc.Hex = {
                        stringify: function (wordArray) {
                            var words = wordArray.words;
                            var sigBytes = wordArray.sigBytes;
                            var hexChars = [];
                            for (var i = 0; i < sigBytes; i++) {
                                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                                hexChars.push((bite >>> 4).toString(16));
                                hexChars.push((bite & 0x0f).toString(16));
                            }
                            return hexChars.join('');
                        },
                        parse: function (hexStr) {
                            var hexStrLength = hexStr.length;
                            var words = [];
                            for (var i = 0; i < hexStrLength; i += 2) {
                                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
                            }
                            return new WordArray.init(words, hexStrLength / 2);
                        }
                    };
                    var Latin1 = C_enc.Latin1 = {
                        stringify: function (wordArray) {
                            var words = wordArray.words;
                            var sigBytes = wordArray.sigBytes;
                            var latin1Chars = [];
                            for (var i = 0; i < sigBytes; i++) {
                                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                                latin1Chars.push(String.fromCharCode(bite));
                            }
                            return latin1Chars.join('');
                        },
                        parse: function (latin1Str) {
                            var latin1StrLength = latin1Str.length;
                            var words = [];
                            for (var i = 0; i < latin1StrLength; i++) {
                                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
                            }
                            return new WordArray.init(words, latin1StrLength);
                        }
                    };
                    var Utf8 = C_enc.Utf8 = {
                        stringify: function (wordArray) {
                            try {
                                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                            }
                            catch (e) {
                                throw new Error('Malformed UTF-8 data');
                            }
                        },
                        parse: function (utf8Str) {
                            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                        }
                    };
                    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                        reset: function () {
                            this._data = new WordArray.init();
                            this._nDataBytes = 0;
                        },
                        _append: function (data) {
                            if (typeof data == 'string') {
                                data = Utf8.parse(data);
                            }
                            this._data.concat(data);
                            this._nDataBytes += data.sigBytes;
                        },
                        _process: function (doFlush) {
                            var data = this._data;
                            var dataWords = data.words;
                            var dataSigBytes = data.sigBytes;
                            var blockSize = this.blockSize;
                            var blockSizeBytes = blockSize * 4;
                            var nBlocksReady = dataSigBytes / blockSizeBytes;
                            if (doFlush) {
                                nBlocksReady = Math.ceil(nBlocksReady);
                            }
                            else {
                                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                            }
                            var nWordsReady = nBlocksReady * blockSize;
                            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
                            if (nWordsReady) {
                                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                                    this._doProcessBlock(dataWords, offset);
                                }
                                var processedWords = dataWords.splice(0, nWordsReady);
                                data.sigBytes -= nBytesReady;
                            }
                            return new WordArray.init(processedWords, nBytesReady);
                        },
                        clone: function () {
                            var clone = Base.clone.call(this);
                            clone._data = this._data.clone();
                            return clone;
                        },
                        _minBufferSize: 0
                    });
                    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                        cfg: Base.extend(),
                        init: function (cfg) {
                            this.cfg = this.cfg.extend(cfg);
                            this.reset();
                        },
                        reset: function () {
                            BufferedBlockAlgorithm.reset.call(this);
                            this._doReset();
                        },
                        update: function (messageUpdate) {
                            this._append(messageUpdate);
                            this._process();
                            return this;
                        },
                        finalize: function (messageUpdate) {
                            if (messageUpdate) {
                                this._append(messageUpdate);
                            }
                            var hash = this._doFinalize();
                            return hash;
                        },
                        blockSize: 512 / 32,
                        _createHelper: function (hasher) {
                            return function (message, cfg) {
                                return new hasher.init(cfg).finalize(message);
                            };
                        },
                        _createHmacHelper: function (hasher) {
                            return function (message, key) {
                                return new C_algo.HMAC.init(hasher, key).finalize(message);
                            };
                        }
                    });
                    var C_algo = C.algo = {};
                    return C;
                }(Math));
                return CryptoJS;
            }));
        }, {}], 122: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_enc = C.enc;
                    var Base64 = C_enc.Base64 = {
                        stringify: function (wordArray) {
                            var words = wordArray.words;
                            var sigBytes = wordArray.sigBytes;
                            var map = this._map;
                            wordArray.clamp();
                            var base64Chars = [];
                            for (var i = 0; i < sigBytes; i += 3) {
                                var byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;
                                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;
                                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                                }
                            }
                            var paddingChar = map.charAt(64);
                            if (paddingChar) {
                                while (base64Chars.length % 4) {
                                    base64Chars.push(paddingChar);
                                }
                            }
                            return base64Chars.join('');
                        },
                        parse: function (base64Str) {
                            var base64StrLength = base64Str.length;
                            var map = this._map;
                            var reverseMap = this._reverseMap;
                            if (!reverseMap) {
                                reverseMap = this._reverseMap = [];
                                for (var j = 0; j < map.length; j++) {
                                    reverseMap[map.charCodeAt(j)] = j;
                                }
                            }
                            var paddingChar = map.charAt(64);
                            if (paddingChar) {
                                var paddingIndex = base64Str.indexOf(paddingChar);
                                if (paddingIndex !== -1) {
                                    base64StrLength = paddingIndex;
                                }
                            }
                            return parseLoop(base64Str, base64StrLength, reverseMap);
                        },
                        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
                    };
                    function parseLoop(base64Str, base64StrLength, reverseMap) {
                        var words = [];
                        var nBytes = 0;
                        for (var i = 0; i < base64StrLength; i++) {
                            if (i % 4) {
                                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
                                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
                                words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                                nBytes++;
                            }
                        }
                        return WordArray.create(words, nBytes);
                    }
                }());
                return CryptoJS.enc.Base64;
            }));
        }, { "./core": 121 }], 123: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_enc = C.enc;
                    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
                        stringify: function (wordArray) {
                            var words = wordArray.words;
                            var sigBytes = wordArray.sigBytes;
                            var utf16Chars = [];
                            for (var i = 0; i < sigBytes; i += 2) {
                                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
                                utf16Chars.push(String.fromCharCode(codePoint));
                            }
                            return utf16Chars.join('');
                        },
                        parse: function (utf16Str) {
                            var utf16StrLength = utf16Str.length;
                            var words = [];
                            for (var i = 0; i < utf16StrLength; i++) {
                                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
                            }
                            return WordArray.create(words, utf16StrLength * 2);
                        }
                    };
                    C_enc.Utf16LE = {
                        stringify: function (wordArray) {
                            var words = wordArray.words;
                            var sigBytes = wordArray.sigBytes;
                            var utf16Chars = [];
                            for (var i = 0; i < sigBytes; i += 2) {
                                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
                                utf16Chars.push(String.fromCharCode(codePoint));
                            }
                            return utf16Chars.join('');
                        },
                        parse: function (utf16Str) {
                            var utf16StrLength = utf16Str.length;
                            var words = [];
                            for (var i = 0; i < utf16StrLength; i++) {
                                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
                            }
                            return WordArray.create(words, utf16StrLength * 2);
                        }
                    };
                    function swapEndian(word) {
                        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
                    }
                }());
                return CryptoJS.enc.Utf16;
            }));
        }, { "./core": 121 }], 124: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./sha1", "./hmac"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var WordArray = C_lib.WordArray;
                    var C_algo = C.algo;
                    var MD5 = C_algo.MD5;
                    var EvpKDF = C_algo.EvpKDF = Base.extend({
                        cfg: Base.extend({
                            keySize: 128 / 32,
                            hasher: MD5,
                            iterations: 1
                        }),
                        init: function (cfg) {
                            this.cfg = this.cfg.extend(cfg);
                        },
                        compute: function (password, salt) {
                            var cfg = this.cfg;
                            var hasher = cfg.hasher.create();
                            var derivedKey = WordArray.create();
                            var derivedKeyWords = derivedKey.words;
                            var keySize = cfg.keySize;
                            var iterations = cfg.iterations;
                            while (derivedKeyWords.length < keySize) {
                                if (block) {
                                    hasher.update(block);
                                }
                                var block = hasher.update(password).finalize(salt);
                                hasher.reset();
                                for (var i = 1; i < iterations; i++) {
                                    block = hasher.finalize(block);
                                    hasher.reset();
                                }
                                derivedKey.concat(block);
                            }
                            derivedKey.sigBytes = keySize * 4;
                            return derivedKey;
                        }
                    });
                    C.EvpKDF = function (password, salt, cfg) {
                        return EvpKDF.create(cfg).compute(password, salt);
                    };
                }());
                return CryptoJS.EvpKDF;
            }));
        }, { "./core": 121, "./hmac": 126, "./sha1": 145 }], 125: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function (undefined) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var CipherParams = C_lib.CipherParams;
                    var C_enc = C.enc;
                    var Hex = C_enc.Hex;
                    var C_format = C.format;
                    var HexFormatter = C_format.Hex = {
                        stringify: function (cipherParams) {
                            return cipherParams.ciphertext.toString(Hex);
                        },
                        parse: function (input) {
                            var ciphertext = Hex.parse(input);
                            return CipherParams.create({ ciphertext: ciphertext });
                        }
                    };
                }());
                return CryptoJS.format.Hex;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 126: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var C_enc = C.enc;
                    var Utf8 = C_enc.Utf8;
                    var C_algo = C.algo;
                    var HMAC = C_algo.HMAC = Base.extend({
                        init: function (hasher, key) {
                            hasher = this._hasher = new hasher.init();
                            if (typeof key == 'string') {
                                key = Utf8.parse(key);
                            }
                            var hasherBlockSize = hasher.blockSize;
                            var hasherBlockSizeBytes = hasherBlockSize * 4;
                            if (key.sigBytes > hasherBlockSizeBytes) {
                                key = hasher.finalize(key);
                            }
                            key.clamp();
                            var oKey = this._oKey = key.clone();
                            var iKey = this._iKey = key.clone();
                            var oKeyWords = oKey.words;
                            var iKeyWords = iKey.words;
                            for (var i = 0; i < hasherBlockSize; i++) {
                                oKeyWords[i] ^= 0x5c5c5c5c;
                                iKeyWords[i] ^= 0x36363636;
                            }
                            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
                            this.reset();
                        },
                        reset: function () {
                            var hasher = this._hasher;
                            hasher.reset();
                            hasher.update(this._iKey);
                        },
                        update: function (messageUpdate) {
                            this._hasher.update(messageUpdate);
                            return this;
                        },
                        finalize: function (messageUpdate) {
                            var hasher = this._hasher;
                            var innerHash = hasher.finalize(messageUpdate);
                            hasher.reset();
                            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
                            return hmac;
                        }
                    });
                }());
            }));
        }, { "./core": 121 }], 127: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./x64-core"), require("./lib-typedarrays"), require("./enc-utf16"), require("./enc-base64"), require("./md5"), require("./sha1"), require("./sha256"), require("./sha224"), require("./sha512"), require("./sha384"), require("./sha3"), require("./ripemd160"), require("./hmac"), require("./pbkdf2"), require("./evpkdf"), require("./cipher-core"), require("./mode-cfb"), require("./mode-ctr"), require("./mode-ctr-gladman"), require("./mode-ofb"), require("./mode-ecb"), require("./pad-ansix923"), require("./pad-iso10126"), require("./pad-iso97971"), require("./pad-zeropadding"), require("./pad-nopadding"), require("./format-hex"), require("./aes"), require("./tripledes"), require("./rc4"), require("./rabbit"), require("./rabbit-legacy"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
                }
                else {
                    root.CryptoJS = factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                return CryptoJS;
            }));
        }, { "./aes": 119, "./cipher-core": 120, "./core": 121, "./enc-base64": 122, "./enc-utf16": 123, "./evpkdf": 124, "./format-hex": 125, "./hmac": 126, "./lib-typedarrays": 128, "./md5": 129, "./mode-cfb": 130, "./mode-ctr": 132, "./mode-ctr-gladman": 131, "./mode-ecb": 133, "./mode-ofb": 134, "./pad-ansix923": 135, "./pad-iso10126": 136, "./pad-iso97971": 137, "./pad-nopadding": 138, "./pad-zeropadding": 139, "./pbkdf2": 140, "./rabbit": 142, "./rabbit-legacy": 141, "./rc4": 143, "./ripemd160": 144, "./sha1": 145, "./sha224": 146, "./sha256": 147, "./sha3": 148, "./sha384": 149, "./sha512": 150, "./tripledes": 151, "./x64-core": 152 }], 128: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    if (typeof ArrayBuffer != 'function') {
                        return;
                    }
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var superInit = WordArray.init;
                    var subInit = WordArray.init = function (typedArray) {
                        if (typedArray instanceof ArrayBuffer) {
                            typedArray = new Uint8Array(typedArray);
                        }
                        if (typedArray instanceof Int8Array ||
                            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
                            typedArray instanceof Int16Array ||
                            typedArray instanceof Uint16Array ||
                            typedArray instanceof Int32Array ||
                            typedArray instanceof Uint32Array ||
                            typedArray instanceof Float32Array ||
                            typedArray instanceof Float64Array) {
                            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
                        }
                        if (typedArray instanceof Uint8Array) {
                            var typedArrayByteLength = typedArray.byteLength;
                            var words = [];
                            for (var i = 0; i < typedArrayByteLength; i++) {
                                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
                            }
                            superInit.call(this, words, typedArrayByteLength);
                        }
                        else {
                            superInit.apply(this, arguments);
                        }
                    };
                    subInit.prototype = WordArray;
                }());
                return CryptoJS.lib.WordArray;
            }));
        }, { "./core": 121 }], 129: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function (Math) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var T = [];
                    (function () {
                        for (var i = 0; i < 64; i++) {
                            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
                        }
                    }());
                    var MD5 = C_algo.MD5 = Hasher.extend({
                        _doReset: function () {
                            this._hash = new WordArray.init([
                                0x67452301, 0xefcdab89,
                                0x98badcfe, 0x10325476
                            ]);
                        },
                        _doProcessBlock: function (M, offset) {
                            for (var i = 0; i < 16; i++) {
                                var offset_i = offset + i;
                                var M_offset_i = M[offset_i];
                                M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
                                    (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
                            }
                            var H = this._hash.words;
                            var M_offset_0 = M[offset + 0];
                            var M_offset_1 = M[offset + 1];
                            var M_offset_2 = M[offset + 2];
                            var M_offset_3 = M[offset + 3];
                            var M_offset_4 = M[offset + 4];
                            var M_offset_5 = M[offset + 5];
                            var M_offset_6 = M[offset + 6];
                            var M_offset_7 = M[offset + 7];
                            var M_offset_8 = M[offset + 8];
                            var M_offset_9 = M[offset + 9];
                            var M_offset_10 = M[offset + 10];
                            var M_offset_11 = M[offset + 11];
                            var M_offset_12 = M[offset + 12];
                            var M_offset_13 = M[offset + 13];
                            var M_offset_14 = M[offset + 14];
                            var M_offset_15 = M[offset + 15];
                            var a = H[0];
                            var b = H[1];
                            var c = H[2];
                            var d = H[3];
                            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                            a = II(a, b, c, d, M_offset_0, 6, T[48]);
                            d = II(d, a, b, c, M_offset_7, 10, T[49]);
                            c = II(c, d, a, b, M_offset_14, 15, T[50]);
                            b = II(b, c, d, a, M_offset_5, 21, T[51]);
                            a = II(a, b, c, d, M_offset_12, 6, T[52]);
                            d = II(d, a, b, c, M_offset_3, 10, T[53]);
                            c = II(c, d, a, b, M_offset_10, 15, T[54]);
                            b = II(b, c, d, a, M_offset_1, 21, T[55]);
                            a = II(a, b, c, d, M_offset_8, 6, T[56]);
                            d = II(d, a, b, c, M_offset_15, 10, T[57]);
                            c = II(c, d, a, b, M_offset_6, 15, T[58]);
                            b = II(b, c, d, a, M_offset_13, 21, T[59]);
                            a = II(a, b, c, d, M_offset_4, 6, T[60]);
                            d = II(d, a, b, c, M_offset_11, 10, T[61]);
                            c = II(c, d, a, b, M_offset_2, 15, T[62]);
                            b = II(b, c, d, a, M_offset_9, 21, T[63]);
                            H[0] = (H[0] + a) | 0;
                            H[1] = (H[1] + b) | 0;
                            H[2] = (H[2] + c) | 0;
                            H[3] = (H[3] + d) | 0;
                        },
                        _doFinalize: function () {
                            var data = this._data;
                            var dataWords = data.words;
                            var nBitsTotal = this._nDataBytes * 8;
                            var nBitsLeft = data.sigBytes * 8;
                            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
                            var nBitsTotalL = nBitsTotal;
                            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00));
                            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00));
                            data.sigBytes = (dataWords.length + 1) * 4;
                            this._process();
                            var hash = this._hash;
                            var H = hash.words;
                            for (var i = 0; i < 4; i++) {
                                var H_i = H[i];
                                H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
                                    (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
                            }
                            return hash;
                        },
                        clone: function () {
                            var clone = Hasher.clone.call(this);
                            clone._hash = this._hash.clone();
                            return clone;
                        }
                    });
                    function FF(a, b, c, d, x, s, t) {
                        var n = a + ((b & c) | (~b & d)) + x + t;
                        return ((n << s) | (n >>> (32 - s))) + b;
                    }
                    function GG(a, b, c, d, x, s, t) {
                        var n = a + ((b & d) | (c & ~d)) + x + t;
                        return ((n << s) | (n >>> (32 - s))) + b;
                    }
                    function HH(a, b, c, d, x, s, t) {
                        var n = a + (b ^ c ^ d) + x + t;
                        return ((n << s) | (n >>> (32 - s))) + b;
                    }
                    function II(a, b, c, d, x, s, t) {
                        var n = a + (c ^ (b | ~d)) + x + t;
                        return ((n << s) | (n >>> (32 - s))) + b;
                    }
                    C.MD5 = Hasher._createHelper(MD5);
                    C.HmacMD5 = Hasher._createHmacHelper(MD5);
                }(Math));
                return CryptoJS.MD5;
            }));
        }, { "./core": 121 }], 130: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.mode.CFB = (function () {
                    var CFB = CryptoJS.lib.BlockCipherMode.extend();
                    CFB.Encryptor = CFB.extend({
                        processBlock: function (words, offset) {
                            var cipher = this._cipher;
                            var blockSize = cipher.blockSize;
                            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                            this._prevBlock = words.slice(offset, offset + blockSize);
                        }
                    });
                    CFB.Decryptor = CFB.extend({
                        processBlock: function (words, offset) {
                            var cipher = this._cipher;
                            var blockSize = cipher.blockSize;
                            var thisBlock = words.slice(offset, offset + blockSize);
                            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                            this._prevBlock = thisBlock;
                        }
                    });
                    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
                        var iv = this._iv;
                        if (iv) {
                            var keystream = iv.slice(0);
                            this._iv = undefined;
                        }
                        else {
                            var keystream = this._prevBlock;
                        }
                        cipher.encryptBlock(keystream, 0);
                        for (var i = 0; i < blockSize; i++) {
                            words[offset + i] ^= keystream[i];
                        }
                    }
                    return CFB;
                }());
                return CryptoJS.mode.CFB;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 131: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.mode.CTRGladman = (function () {
                    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
                    function incWord(word) {
                        if (((word >> 24) & 0xff) === 0xff) {
                            var b1 = (word >> 16) & 0xff;
                            var b2 = (word >> 8) & 0xff;
                            var b3 = word & 0xff;
                            if (b1 === 0xff) {
                                b1 = 0;
                                if (b2 === 0xff) {
                                    b2 = 0;
                                    if (b3 === 0xff) {
                                        b3 = 0;
                                    }
                                    else {
                                        ++b3;
                                    }
                                }
                                else {
                                    ++b2;
                                }
                            }
                            else {
                                ++b1;
                            }
                            word = 0;
                            word += (b1 << 16);
                            word += (b2 << 8);
                            word += b3;
                        }
                        else {
                            word += (0x01 << 24);
                        }
                        return word;
                    }
                    function incCounter(counter) {
                        if ((counter[0] = incWord(counter[0])) === 0) {
                            counter[1] = incWord(counter[1]);
                        }
                        return counter;
                    }
                    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
                        processBlock: function (words, offset) {
                            var cipher = this._cipher;
                            var blockSize = cipher.blockSize;
                            var iv = this._iv;
                            var counter = this._counter;
                            if (iv) {
                                counter = this._counter = iv.slice(0);
                                this._iv = undefined;
                            }
                            incCounter(counter);
                            var keystream = counter.slice(0);
                            cipher.encryptBlock(keystream, 0);
                            for (var i = 0; i < blockSize; i++) {
                                words[offset + i] ^= keystream[i];
                            }
                        }
                    });
                    CTRGladman.Decryptor = Encryptor;
                    return CTRGladman;
                }());
                return CryptoJS.mode.CTRGladman;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 132: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.mode.CTR = (function () {
                    var CTR = CryptoJS.lib.BlockCipherMode.extend();
                    var Encryptor = CTR.Encryptor = CTR.extend({
                        processBlock: function (words, offset) {
                            var cipher = this._cipher;
                            var blockSize = cipher.blockSize;
                            var iv = this._iv;
                            var counter = this._counter;
                            if (iv) {
                                counter = this._counter = iv.slice(0);
                                this._iv = undefined;
                            }
                            var keystream = counter.slice(0);
                            cipher.encryptBlock(keystream, 0);
                            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;
                            for (var i = 0; i < blockSize; i++) {
                                words[offset + i] ^= keystream[i];
                            }
                        }
                    });
                    CTR.Decryptor = Encryptor;
                    return CTR;
                }());
                return CryptoJS.mode.CTR;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 133: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.mode.ECB = (function () {
                    var ECB = CryptoJS.lib.BlockCipherMode.extend();
                    ECB.Encryptor = ECB.extend({
                        processBlock: function (words, offset) {
                            this._cipher.encryptBlock(words, offset);
                        }
                    });
                    ECB.Decryptor = ECB.extend({
                        processBlock: function (words, offset) {
                            this._cipher.decryptBlock(words, offset);
                        }
                    });
                    return ECB;
                }());
                return CryptoJS.mode.ECB;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 134: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.mode.OFB = (function () {
                    var OFB = CryptoJS.lib.BlockCipherMode.extend();
                    var Encryptor = OFB.Encryptor = OFB.extend({
                        processBlock: function (words, offset) {
                            var cipher = this._cipher;
                            var blockSize = cipher.blockSize;
                            var iv = this._iv;
                            var keystream = this._keystream;
                            if (iv) {
                                keystream = this._keystream = iv.slice(0);
                                this._iv = undefined;
                            }
                            cipher.encryptBlock(keystream, 0);
                            for (var i = 0; i < blockSize; i++) {
                                words[offset + i] ^= keystream[i];
                            }
                        }
                    });
                    OFB.Decryptor = Encryptor;
                    return OFB;
                }());
                return CryptoJS.mode.OFB;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 135: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.pad.AnsiX923 = {
                    pad: function (data, blockSize) {
                        var dataSigBytes = data.sigBytes;
                        var blockSizeBytes = blockSize * 4;
                        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
                        var lastBytePos = dataSigBytes + nPaddingBytes - 1;
                        data.clamp();
                        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
                        data.sigBytes += nPaddingBytes;
                    },
                    unpad: function (data) {
                        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
                        data.sigBytes -= nPaddingBytes;
                    }
                };
                return CryptoJS.pad.Ansix923;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 136: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.pad.Iso10126 = {
                    pad: function (data, blockSize) {
                        var blockSizeBytes = blockSize * 4;
                        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
                            concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
                    },
                    unpad: function (data) {
                        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
                        data.sigBytes -= nPaddingBytes;
                    }
                };
                return CryptoJS.pad.Iso10126;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 137: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.pad.Iso97971 = {
                    pad: function (data, blockSize) {
                        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));
                        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
                    },
                    unpad: function (data) {
                        CryptoJS.pad.ZeroPadding.unpad(data);
                        data.sigBytes--;
                    }
                };
                return CryptoJS.pad.Iso97971;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 138: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.pad.NoPadding = {
                    pad: function () {
                    },
                    unpad: function () {
                    }
                };
                return CryptoJS.pad.NoPadding;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 139: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                CryptoJS.pad.ZeroPadding = {
                    pad: function (data, blockSize) {
                        var blockSizeBytes = blockSize * 4;
                        data.clamp();
                        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
                    },
                    unpad: function (data) {
                        var dataWords = data.words;
                        var i = data.sigBytes - 1;
                        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
                            i--;
                        }
                        data.sigBytes = i + 1;
                    }
                };
                return CryptoJS.pad.ZeroPadding;
            }));
        }, { "./cipher-core": 120, "./core": 121 }], 140: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./sha1", "./hmac"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var WordArray = C_lib.WordArray;
                    var C_algo = C.algo;
                    var SHA1 = C_algo.SHA1;
                    var HMAC = C_algo.HMAC;
                    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
                        cfg: Base.extend({
                            keySize: 128 / 32,
                            hasher: SHA1,
                            iterations: 1
                        }),
                        init: function (cfg) {
                            this.cfg = this.cfg.extend(cfg);
                        },
                        compute: function (password, salt) {
                            var cfg = this.cfg;
                            var hmac = HMAC.create(cfg.hasher, password);
                            var derivedKey = WordArray.create();
                            var blockIndex = WordArray.create([0x00000001]);
                            var derivedKeyWords = derivedKey.words;
                            var blockIndexWords = blockIndex.words;
                            var keySize = cfg.keySize;
                            var iterations = cfg.iterations;
                            while (derivedKeyWords.length < keySize) {
                                var block = hmac.update(salt).finalize(blockIndex);
                                hmac.reset();
                                var blockWords = block.words;
                                var blockWordsLength = blockWords.length;
                                var intermediate = block;
                                for (var i = 1; i < iterations; i++) {
                                    intermediate = hmac.finalize(intermediate);
                                    hmac.reset();
                                    var intermediateWords = intermediate.words;
                                    for (var j = 0; j < blockWordsLength; j++) {
                                        blockWords[j] ^= intermediateWords[j];
                                    }
                                }
                                derivedKey.concat(block);
                                blockIndexWords[0]++;
                            }
                            derivedKey.sigBytes = keySize * 4;
                            return derivedKey;
                        }
                    });
                    C.PBKDF2 = function (password, salt, cfg) {
                        return PBKDF2.create(cfg).compute(password, salt);
                    };
                }());
                return CryptoJS.PBKDF2;
            }));
        }, { "./core": 121, "./hmac": 126, "./sha1": 145 }], 141: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var StreamCipher = C_lib.StreamCipher;
                    var C_algo = C.algo;
                    var S = [];
                    var C_ = [];
                    var G = [];
                    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
                        _doReset: function () {
                            var K = this._key.words;
                            var iv = this.cfg.iv;
                            var X = this._X = [
                                K[0], (K[3] << 16) | (K[2] >>> 16),
                                K[1], (K[0] << 16) | (K[3] >>> 16),
                                K[2], (K[1] << 16) | (K[0] >>> 16),
                                K[3], (K[2] << 16) | (K[1] >>> 16)
                            ];
                            var C = this._C = [
                                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
                                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
                                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
                                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
                            ];
                            this._b = 0;
                            for (var i = 0; i < 4; i++) {
                                nextState.call(this);
                            }
                            for (var i = 0; i < 8; i++) {
                                C[i] ^= X[(i + 4) & 7];
                            }
                            if (iv) {
                                var IV = iv.words;
                                var IV_0 = IV[0];
                                var IV_1 = IV[1];
                                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
                                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
                                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
                                var i3 = (i2 << 16) | (i0 & 0x0000ffff);
                                C[0] ^= i0;
                                C[1] ^= i1;
                                C[2] ^= i2;
                                C[3] ^= i3;
                                C[4] ^= i0;
                                C[5] ^= i1;
                                C[6] ^= i2;
                                C[7] ^= i3;
                                for (var i = 0; i < 4; i++) {
                                    nextState.call(this);
                                }
                            }
                        },
                        _doProcessBlock: function (M, offset) {
                            var X = this._X;
                            nextState.call(this);
                            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
                            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
                            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
                            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);
                            for (var i = 0; i < 4; i++) {
                                S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff) |
                                    (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);
                                M[offset + i] ^= S[i];
                            }
                        },
                        blockSize: 128 / 32,
                        ivSize: 64 / 32
                    });
                    function nextState() {
                        var X = this._X;
                        var C = this._C;
                        for (var i = 0; i < 8; i++) {
                            C_[i] = C[i];
                        }
                        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
                        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
                        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
                        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
                        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
                        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
                        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
                        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
                        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;
                        for (var i = 0; i < 8; i++) {
                            var gx = X[i] + C[i];
                            var ga = gx & 0xffff;
                            var gb = gx >>> 16;
                            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
                            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);
                            G[i] = gh ^ gl;
                        }
                        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
                        X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;
                        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
                        X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;
                        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
                        X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;
                        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
                        X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;
                    }
                    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
                }());
                return CryptoJS.RabbitLegacy;
            }));
        }, { "./cipher-core": 120, "./core": 121, "./enc-base64": 122, "./evpkdf": 124, "./md5": 129 }], 142: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var StreamCipher = C_lib.StreamCipher;
                    var C_algo = C.algo;
                    var S = [];
                    var C_ = [];
                    var G = [];
                    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
                        _doReset: function () {
                            var K = this._key.words;
                            var iv = this.cfg.iv;
                            for (var i = 0; i < 4; i++) {
                                K[i] = (((K[i] << 8) | (K[i] >>> 24)) & 0x00ff00ff) |
                                    (((K[i] << 24) | (K[i] >>> 8)) & 0xff00ff00);
                            }
                            var X = this._X = [
                                K[0], (K[3] << 16) | (K[2] >>> 16),
                                K[1], (K[0] << 16) | (K[3] >>> 16),
                                K[2], (K[1] << 16) | (K[0] >>> 16),
                                K[3], (K[2] << 16) | (K[1] >>> 16)
                            ];
                            var C = this._C = [
                                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
                                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
                                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
                                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
                            ];
                            this._b = 0;
                            for (var i = 0; i < 4; i++) {
                                nextState.call(this);
                            }
                            for (var i = 0; i < 8; i++) {
                                C[i] ^= X[(i + 4) & 7];
                            }
                            if (iv) {
                                var IV = iv.words;
                                var IV_0 = IV[0];
                                var IV_1 = IV[1];
                                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
                                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
                                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
                                var i3 = (i2 << 16) | (i0 & 0x0000ffff);
                                C[0] ^= i0;
                                C[1] ^= i1;
                                C[2] ^= i2;
                                C[3] ^= i3;
                                C[4] ^= i0;
                                C[5] ^= i1;
                                C[6] ^= i2;
                                C[7] ^= i3;
                                for (var i = 0; i < 4; i++) {
                                    nextState.call(this);
                                }
                            }
                        },
                        _doProcessBlock: function (M, offset) {
                            var X = this._X;
                            nextState.call(this);
                            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
                            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
                            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
                            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);
                            for (var i = 0; i < 4; i++) {
                                S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff) |
                                    (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);
                                M[offset + i] ^= S[i];
                            }
                        },
                        blockSize: 128 / 32,
                        ivSize: 64 / 32
                    });
                    function nextState() {
                        var X = this._X;
                        var C = this._C;
                        for (var i = 0; i < 8; i++) {
                            C_[i] = C[i];
                        }
                        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
                        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
                        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
                        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
                        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
                        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
                        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
                        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
                        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;
                        for (var i = 0; i < 8; i++) {
                            var gx = X[i] + C[i];
                            var ga = gx & 0xffff;
                            var gb = gx >>> 16;
                            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
                            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);
                            G[i] = gh ^ gl;
                        }
                        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
                        X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;
                        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
                        X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;
                        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
                        X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;
                        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
                        X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;
                    }
                    C.Rabbit = StreamCipher._createHelper(Rabbit);
                }());
                return CryptoJS.Rabbit;
            }));
        }, { "./cipher-core": 120, "./core": 121, "./enc-base64": 122, "./evpkdf": 124, "./md5": 129 }], 143: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var StreamCipher = C_lib.StreamCipher;
                    var C_algo = C.algo;
                    var RC4 = C_algo.RC4 = StreamCipher.extend({
                        _doReset: function () {
                            var key = this._key;
                            var keyWords = key.words;
                            var keySigBytes = key.sigBytes;
                            var S = this._S = [];
                            for (var i = 0; i < 256; i++) {
                                S[i] = i;
                            }
                            for (var i = 0, j = 0; i < 256; i++) {
                                var keyByteIndex = i % keySigBytes;
                                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;
                                j = (j + S[i] + keyByte) % 256;
                                var t = S[i];
                                S[i] = S[j];
                                S[j] = t;
                            }
                            this._i = this._j = 0;
                        },
                        _doProcessBlock: function (M, offset) {
                            M[offset] ^= generateKeystreamWord.call(this);
                        },
                        keySize: 256 / 32,
                        ivSize: 0
                    });
                    function generateKeystreamWord() {
                        var S = this._S;
                        var i = this._i;
                        var j = this._j;
                        var keystreamWord = 0;
                        for (var n = 0; n < 4; n++) {
                            i = (i + 1) % 256;
                            j = (j + S[i]) % 256;
                            var t = S[i];
                            S[i] = S[j];
                            S[j] = t;
                            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
                        }
                        this._i = i;
                        this._j = j;
                        return keystreamWord;
                    }
                    C.RC4 = StreamCipher._createHelper(RC4);
                    var RC4Drop = C_algo.RC4Drop = RC4.extend({
                        cfg: RC4.cfg.extend({
                            drop: 192
                        }),
                        _doReset: function () {
                            RC4._doReset.call(this);
                            for (var i = this.cfg.drop; i > 0; i--) {
                                generateKeystreamWord.call(this);
                            }
                        }
                    });
                    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
                }());
                return CryptoJS.RC4;
            }));
        }, { "./cipher-core": 120, "./core": 121, "./enc-base64": 122, "./evpkdf": 124, "./md5": 129 }], 144: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function (Math) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var _zl = WordArray.create([
                        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                        7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
                        3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
                        1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
                        4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
                    ]);
                    var _zr = WordArray.create([
                        5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                        6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
                        15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
                        8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
                        12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
                    ]);
                    var _sl = WordArray.create([
                        11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
                        7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
                        11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                        11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
                        9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
                    ]);
                    var _sr = WordArray.create([
                        8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
                        9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
                        9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                        15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
                        8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
                    ]);
                    var _hl = WordArray.create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
                    var _hr = WordArray.create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);
                    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
                        _doReset: function () {
                            this._hash = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
                        },
                        _doProcessBlock: function (M, offset) {
                            for (var i = 0; i < 16; i++) {
                                var offset_i = offset + i;
                                var M_offset_i = M[offset_i];
                                M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
                                    (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
                            }
                            var H = this._hash.words;
                            var hl = _hl.words;
                            var hr = _hr.words;
                            var zl = _zl.words;
                            var zr = _zr.words;
                            var sl = _sl.words;
                            var sr = _sr.words;
                            var al, bl, cl, dl, el;
                            var ar, br, cr, dr, er;
                            ar = al = H[0];
                            br = bl = H[1];
                            cr = cl = H[2];
                            dr = dl = H[3];
                            er = el = H[4];
                            var t;
                            for (var i = 0; i < 80; i += 1) {
                                t = (al + M[offset + zl[i]]) | 0;
                                if (i < 16) {
                                    t += f1(bl, cl, dl) + hl[0];
                                }
                                else if (i < 32) {
                                    t += f2(bl, cl, dl) + hl[1];
                                }
                                else if (i < 48) {
                                    t += f3(bl, cl, dl) + hl[2];
                                }
                                else if (i < 64) {
                                    t += f4(bl, cl, dl) + hl[3];
                                }
                                else {
                                    t += f5(bl, cl, dl) + hl[4];
                                }
                                t = t | 0;
                                t = rotl(t, sl[i]);
                                t = (t + el) | 0;
                                al = el;
                                el = dl;
                                dl = rotl(cl, 10);
                                cl = bl;
                                bl = t;
                                t = (ar + M[offset + zr[i]]) | 0;
                                if (i < 16) {
                                    t += f5(br, cr, dr) + hr[0];
                                }
                                else if (i < 32) {
                                    t += f4(br, cr, dr) + hr[1];
                                }
                                else if (i < 48) {
                                    t += f3(br, cr, dr) + hr[2];
                                }
                                else if (i < 64) {
                                    t += f2(br, cr, dr) + hr[3];
                                }
                                else {
                                    t += f1(br, cr, dr) + hr[4];
                                }
                                t = t | 0;
                                t = rotl(t, sr[i]);
                                t = (t + er) | 0;
                                ar = er;
                                er = dr;
                                dr = rotl(cr, 10);
                                cr = br;
                                br = t;
                            }
                            t = (H[1] + cl + dr) | 0;
                            H[1] = (H[2] + dl + er) | 0;
                            H[2] = (H[3] + el + ar) | 0;
                            H[3] = (H[4] + al + br) | 0;
                            H[4] = (H[0] + bl + cr) | 0;
                            H[0] = t;
                        },
                        _doFinalize: function () {
                            var data = this._data;
                            var dataWords = data.words;
                            var nBitsTotal = this._nDataBytes * 8;
                            var nBitsLeft = data.sigBytes * 8;
                            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
                                (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00));
                            data.sigBytes = (dataWords.length + 1) * 4;
                            this._process();
                            var hash = this._hash;
                            var H = hash.words;
                            for (var i = 0; i < 5; i++) {
                                var H_i = H[i];
                                H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
                                    (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
                            }
                            return hash;
                        },
                        clone: function () {
                            var clone = Hasher.clone.call(this);
                            clone._hash = this._hash.clone();
                            return clone;
                        }
                    });
                    function f1(x, y, z) {
                        return ((x) ^ (y) ^ (z));
                    }
                    function f2(x, y, z) {
                        return (((x) & (y)) | ((~x) & (z)));
                    }
                    function f3(x, y, z) {
                        return (((x) | (~(y))) ^ (z));
                    }
                    function f4(x, y, z) {
                        return (((x) & (z)) | ((y) & (~(z))));
                    }
                    function f5(x, y, z) {
                        return ((x) ^ ((y) | (~(z))));
                    }
                    function rotl(x, n) {
                        return (x << n) | (x >>> (32 - n));
                    }
                    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
                    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
                }(Math));
                return CryptoJS.RIPEMD160;
            }));
        }, { "./core": 121 }], 145: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var W = [];
                    var SHA1 = C_algo.SHA1 = Hasher.extend({
                        _doReset: function () {
                            this._hash = new WordArray.init([
                                0x67452301, 0xefcdab89,
                                0x98badcfe, 0x10325476,
                                0xc3d2e1f0
                            ]);
                        },
                        _doProcessBlock: function (M, offset) {
                            var H = this._hash.words;
                            var a = H[0];
                            var b = H[1];
                            var c = H[2];
                            var d = H[3];
                            var e = H[4];
                            for (var i = 0; i < 80; i++) {
                                if (i < 16) {
                                    W[i] = M[offset + i] | 0;
                                }
                                else {
                                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                                    W[i] = (n << 1) | (n >>> 31);
                                }
                                var t = ((a << 5) | (a >>> 27)) + e + W[i];
                                if (i < 20) {
                                    t += ((b & c) | (~b & d)) + 0x5a827999;
                                }
                                else if (i < 40) {
                                    t += (b ^ c ^ d) + 0x6ed9eba1;
                                }
                                else if (i < 60) {
                                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
                                }
                                else {
                                    t += (b ^ c ^ d) - 0x359d3e2a;
                                }
                                e = d;
                                d = c;
                                c = (b << 30) | (b >>> 2);
                                b = a;
                                a = t;
                            }
                            H[0] = (H[0] + a) | 0;
                            H[1] = (H[1] + b) | 0;
                            H[2] = (H[2] + c) | 0;
                            H[3] = (H[3] + d) | 0;
                            H[4] = (H[4] + e) | 0;
                        },
                        _doFinalize: function () {
                            var data = this._data;
                            var dataWords = data.words;
                            var nBitsTotal = this._nDataBytes * 8;
                            var nBitsLeft = data.sigBytes * 8;
                            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
                            data.sigBytes = dataWords.length * 4;
                            this._process();
                            return this._hash;
                        },
                        clone: function () {
                            var clone = Hasher.clone.call(this);
                            clone._hash = this._hash.clone();
                            return clone;
                        }
                    });
                    C.SHA1 = Hasher._createHelper(SHA1);
                    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
                }());
                return CryptoJS.SHA1;
            }));
        }, { "./core": 121 }], 146: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./sha256"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./sha256"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_algo = C.algo;
                    var SHA256 = C_algo.SHA256;
                    var SHA224 = C_algo.SHA224 = SHA256.extend({
                        _doReset: function () {
                            this._hash = new WordArray.init([
                                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
                                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
                            ]);
                        },
                        _doFinalize: function () {
                            var hash = SHA256._doFinalize.call(this);
                            hash.sigBytes -= 4;
                            return hash;
                        }
                    });
                    C.SHA224 = SHA256._createHelper(SHA224);
                    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
                }());
                return CryptoJS.SHA224;
            }));
        }, { "./core": 121, "./sha256": 147 }], 147: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function (Math) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var H = [];
                    var K = [];
                    (function () {
                        function isPrime(n) {
                            var sqrtN = Math.sqrt(n);
                            for (var factor = 2; factor <= sqrtN; factor++) {
                                if (!(n % factor)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        function getFractionalBits(n) {
                            return ((n - (n | 0)) * 0x100000000) | 0;
                        }
                        var n = 2;
                        var nPrime = 0;
                        while (nPrime < 64) {
                            if (isPrime(n)) {
                                if (nPrime < 8) {
                                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                                }
                                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
                                nPrime++;
                            }
                            n++;
                        }
                    }());
                    var W = [];
                    var SHA256 = C_algo.SHA256 = Hasher.extend({
                        _doReset: function () {
                            this._hash = new WordArray.init(H.slice(0));
                        },
                        _doProcessBlock: function (M, offset) {
                            var H = this._hash.words;
                            var a = H[0];
                            var b = H[1];
                            var c = H[2];
                            var d = H[3];
                            var e = H[4];
                            var f = H[5];
                            var g = H[6];
                            var h = H[7];
                            for (var i = 0; i < 64; i++) {
                                if (i < 16) {
                                    W[i] = M[offset + i] | 0;
                                }
                                else {
                                    var gamma0x = W[i - 15];
                                    var gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^
                                        ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                        (gamma0x >>> 3);
                                    var gamma1x = W[i - 2];
                                    var gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                        ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                        (gamma1x >>> 10);
                                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                                }
                                var ch = (e & f) ^ (~e & g);
                                var maj = (a & b) ^ (a & c) ^ (b & c);
                                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));
                                var t1 = h + sigma1 + ch + K[i] + W[i];
                                var t2 = sigma0 + maj;
                                h = g;
                                g = f;
                                f = e;
                                e = (d + t1) | 0;
                                d = c;
                                c = b;
                                b = a;
                                a = (t1 + t2) | 0;
                            }
                            H[0] = (H[0] + a) | 0;
                            H[1] = (H[1] + b) | 0;
                            H[2] = (H[2] + c) | 0;
                            H[3] = (H[3] + d) | 0;
                            H[4] = (H[4] + e) | 0;
                            H[5] = (H[5] + f) | 0;
                            H[6] = (H[6] + g) | 0;
                            H[7] = (H[7] + h) | 0;
                        },
                        _doFinalize: function () {
                            var data = this._data;
                            var dataWords = data.words;
                            var nBitsTotal = this._nDataBytes * 8;
                            var nBitsLeft = data.sigBytes * 8;
                            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
                            data.sigBytes = dataWords.length * 4;
                            this._process();
                            return this._hash;
                        },
                        clone: function () {
                            var clone = Hasher.clone.call(this);
                            clone._hash = this._hash.clone();
                            return clone;
                        }
                    });
                    C.SHA256 = Hasher._createHelper(SHA256);
                    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
                }(Math));
                return CryptoJS.SHA256;
            }));
        }, { "./core": 121 }], 148: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./x64-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./x64-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function (Math) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_x64 = C.x64;
                    var X64Word = C_x64.Word;
                    var C_algo = C.algo;
                    var RHO_OFFSETS = [];
                    var PI_INDEXES = [];
                    var ROUND_CONSTANTS = [];
                    (function () {
                        var x = 1, y = 0;
                        for (var t = 0; t < 24; t++) {
                            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;
                            var newX = y % 5;
                            var newY = (2 * x + 3 * y) % 5;
                            x = newX;
                            y = newY;
                        }
                        for (var x = 0; x < 5; x++) {
                            for (var y = 0; y < 5; y++) {
                                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
                            }
                        }
                        var LFSR = 0x01;
                        for (var i = 0; i < 24; i++) {
                            var roundConstantMsw = 0;
                            var roundConstantLsw = 0;
                            for (var j = 0; j < 7; j++) {
                                if (LFSR & 0x01) {
                                    var bitPosition = (1 << j) - 1;
                                    if (bitPosition < 32) {
                                        roundConstantLsw ^= 1 << bitPosition;
                                    }
                                    else {
                                        roundConstantMsw ^= 1 << (bitPosition - 32);
                                    }
                                }
                                if (LFSR & 0x80) {
                                    LFSR = (LFSR << 1) ^ 0x71;
                                }
                                else {
                                    LFSR <<= 1;
                                }
                            }
                            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
                        }
                    }());
                    var T = [];
                    (function () {
                        for (var i = 0; i < 25; i++) {
                            T[i] = X64Word.create();
                        }
                    }());
                    var SHA3 = C_algo.SHA3 = Hasher.extend({
                        cfg: Hasher.cfg.extend({
                            outputLength: 512
                        }),
                        _doReset: function () {
                            var state = this._state = [];
                            for (var i = 0; i < 25; i++) {
                                state[i] = new X64Word.init();
                            }
                            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                        },
                        _doProcessBlock: function (M, offset) {
                            var state = this._state;
                            var nBlockSizeLanes = this.blockSize / 2;
                            for (var i = 0; i < nBlockSizeLanes; i++) {
                                var M2i = M[offset + 2 * i];
                                var M2i1 = M[offset + 2 * i + 1];
                                M2i = ((((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff) |
                                    (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00));
                                M2i1 = ((((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff) |
                                    (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00));
                                var lane = state[i];
                                lane.high ^= M2i1;
                                lane.low ^= M2i;
                            }
                            for (var round = 0; round < 24; round++) {
                                for (var x = 0; x < 5; x++) {
                                    var tMsw = 0, tLsw = 0;
                                    for (var y = 0; y < 5; y++) {
                                        var lane = state[x + 5 * y];
                                        tMsw ^= lane.high;
                                        tLsw ^= lane.low;
                                    }
                                    var Tx = T[x];
                                    Tx.high = tMsw;
                                    Tx.low = tLsw;
                                }
                                for (var x = 0; x < 5; x++) {
                                    var Tx4 = T[(x + 4) % 5];
                                    var Tx1 = T[(x + 1) % 5];
                                    var Tx1Msw = Tx1.high;
                                    var Tx1Lsw = Tx1.low;
                                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
                                    var tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
                                    for (var y = 0; y < 5; y++) {
                                        var lane = state[x + 5 * y];
                                        lane.high ^= tMsw;
                                        lane.low ^= tLsw;
                                    }
                                }
                                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                                    var lane = state[laneIndex];
                                    var laneMsw = lane.high;
                                    var laneLsw = lane.low;
                                    var rhoOffset = RHO_OFFSETS[laneIndex];
                                    if (rhoOffset < 32) {
                                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
                                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
                                    }
                                    else {
                                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
                                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
                                    }
                                    var TPiLane = T[PI_INDEXES[laneIndex]];
                                    TPiLane.high = tMsw;
                                    TPiLane.low = tLsw;
                                }
                                var T0 = T[0];
                                var state0 = state[0];
                                T0.high = state0.high;
                                T0.low = state0.low;
                                for (var x = 0; x < 5; x++) {
                                    for (var y = 0; y < 5; y++) {
                                        var laneIndex = x + 5 * y;
                                        var lane = state[laneIndex];
                                        var TLane = T[laneIndex];
                                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
                                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];
                                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
                                        lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);
                                    }
                                }
                                var lane = state[0];
                                var roundConstant = ROUND_CONSTANTS[round];
                                lane.high ^= roundConstant.high;
                                lane.low ^= roundConstant.low;
                                ;
                            }
                        },
                        _doFinalize: function () {
                            var data = this._data;
                            var dataWords = data.words;
                            var nBitsTotal = this._nDataBytes * 8;
                            var nBitsLeft = data.sigBytes * 8;
                            var blockSizeBits = this.blockSize * 32;
                            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
                            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
                            data.sigBytes = dataWords.length * 4;
                            this._process();
                            var state = this._state;
                            var outputLengthBytes = this.cfg.outputLength / 8;
                            var outputLengthLanes = outputLengthBytes / 8;
                            var hashWords = [];
                            for (var i = 0; i < outputLengthLanes; i++) {
                                var lane = state[i];
                                var laneMsw = lane.high;
                                var laneLsw = lane.low;
                                laneMsw = ((((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff) |
                                    (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00));
                                laneLsw = ((((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff) |
                                    (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00));
                                hashWords.push(laneLsw);
                                hashWords.push(laneMsw);
                            }
                            return new WordArray.init(hashWords, outputLengthBytes);
                        },
                        clone: function () {
                            var clone = Hasher.clone.call(this);
                            var state = clone._state = this._state.slice(0);
                            for (var i = 0; i < 25; i++) {
                                state[i] = state[i].clone();
                            }
                            return clone;
                        }
                    });
                    C.SHA3 = Hasher._createHelper(SHA3);
                    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
                }(Math));
                return CryptoJS.SHA3;
            }));
        }, { "./core": 121, "./x64-core": 152 }], 149: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha512"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./x64-core", "./sha512"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_x64 = C.x64;
                    var X64Word = C_x64.Word;
                    var X64WordArray = C_x64.WordArray;
                    var C_algo = C.algo;
                    var SHA512 = C_algo.SHA512;
                    var SHA384 = C_algo.SHA384 = SHA512.extend({
                        _doReset: function () {
                            this._hash = new X64WordArray.init([
                                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
                                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
                                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
                                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
                            ]);
                        },
                        _doFinalize: function () {
                            var hash = SHA512._doFinalize.call(this);
                            hash.sigBytes -= 16;
                            return hash;
                        }
                    });
                    C.SHA384 = SHA512._createHelper(SHA384);
                    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
                }());
                return CryptoJS.SHA384;
            }));
        }, { "./core": 121, "./sha512": 150, "./x64-core": 152 }], 150: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./x64-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./x64-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Hasher = C_lib.Hasher;
                    var C_x64 = C.x64;
                    var X64Word = C_x64.Word;
                    var X64WordArray = C_x64.WordArray;
                    var C_algo = C.algo;
                    function X64Word_create() {
                        return X64Word.create.apply(X64Word, arguments);
                    }
                    var K = [
                        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
                        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
                        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
                        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
                        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
                        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
                        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
                        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
                        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
                        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
                        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
                        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
                        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
                        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
                        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
                        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
                        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
                        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
                        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
                        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
                        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
                        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
                        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
                        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
                        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
                        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
                        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
                        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
                        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
                        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
                        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
                        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
                        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
                        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
                        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
                        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
                        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
                        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
                        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
                        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
                    ];
                    var W = [];
                    (function () {
                        for (var i = 0; i < 80; i++) {
                            W[i] = X64Word_create();
                        }
                    }());
                    var SHA512 = C_algo.SHA512 = Hasher.extend({
                        _doReset: function () {
                            this._hash = new X64WordArray.init([
                                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
                                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
                                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
                                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
                            ]);
                        },
                        _doProcessBlock: function (M, offset) {
                            var H = this._hash.words;
                            var H0 = H[0];
                            var H1 = H[1];
                            var H2 = H[2];
                            var H3 = H[3];
                            var H4 = H[4];
                            var H5 = H[5];
                            var H6 = H[6];
                            var H7 = H[7];
                            var H0h = H0.high;
                            var H0l = H0.low;
                            var H1h = H1.high;
                            var H1l = H1.low;
                            var H2h = H2.high;
                            var H2l = H2.low;
                            var H3h = H3.high;
                            var H3l = H3.low;
                            var H4h = H4.high;
                            var H4l = H4.low;
                            var H5h = H5.high;
                            var H5l = H5.low;
                            var H6h = H6.high;
                            var H6l = H6.low;
                            var H7h = H7.high;
                            var H7l = H7.low;
                            var ah = H0h;
                            var al = H0l;
                            var bh = H1h;
                            var bl = H1l;
                            var ch = H2h;
                            var cl = H2l;
                            var dh = H3h;
                            var dl = H3l;
                            var eh = H4h;
                            var el = H4l;
                            var fh = H5h;
                            var fl = H5l;
                            var gh = H6h;
                            var gl = H6l;
                            var hh = H7h;
                            var hl = H7l;
                            for (var i = 0; i < 80; i++) {
                                var Wi = W[i];
                                if (i < 16) {
                                    var Wih = Wi.high = M[offset + i * 2] | 0;
                                    var Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                                }
                                else {
                                    var gamma0x = W[i - 15];
                                    var gamma0xh = gamma0x.high;
                                    var gamma0xl = gamma0x.low;
                                    var gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
                                    var gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));
                                    var gamma1x = W[i - 2];
                                    var gamma1xh = gamma1x.high;
                                    var gamma1xl = gamma1x.low;
                                    var gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
                                    var gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));
                                    var Wi7 = W[i - 7];
                                    var Wi7h = Wi7.high;
                                    var Wi7l = Wi7.low;
                                    var Wi16 = W[i - 16];
                                    var Wi16h = Wi16.high;
                                    var Wi16l = Wi16.low;
                                    var Wil = gamma0l + Wi7l;
                                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
                                    var Wil = Wil + gamma1l;
                                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
                                    var Wil = Wil + Wi16l;
                                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);
                                    Wi.high = Wih;
                                    Wi.low = Wil;
                                }
                                var chh = (eh & fh) ^ (~eh & gh);
                                var chl = (el & fl) ^ (~el & gl);
                                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
                                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);
                                var sigma0h = ((ah >>> 28) | (al << 4)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
                                var sigma0l = ((al >>> 28) | (ah << 4)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
                                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
                                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));
                                var Ki = K[i];
                                var Kih = Ki.high;
                                var Kil = Ki.low;
                                var t1l = hl + sigma1l;
                                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
                                var t1l = t1l + chl;
                                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
                                var t1l = t1l + Kil;
                                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
                                var t1l = t1l + Wil;
                                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);
                                var t2l = sigma0l + majl;
                                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);
                                hh = gh;
                                hl = gl;
                                gh = fh;
                                gl = fl;
                                fh = eh;
                                fl = el;
                                el = (dl + t1l) | 0;
                                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
                                dh = ch;
                                dl = cl;
                                ch = bh;
                                cl = bl;
                                bh = ah;
                                bl = al;
                                al = (t1l + t2l) | 0;
                                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
                            }
                            H0l = H0.low = (H0l + al);
                            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
                            H1l = H1.low = (H1l + bl);
                            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
                            H2l = H2.low = (H2l + cl);
                            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
                            H3l = H3.low = (H3l + dl);
                            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
                            H4l = H4.low = (H4l + el);
                            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
                            H5l = H5.low = (H5l + fl);
                            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
                            H6l = H6.low = (H6l + gl);
                            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
                            H7l = H7.low = (H7l + hl);
                            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
                        },
                        _doFinalize: function () {
                            var data = this._data;
                            var dataWords = data.words;
                            var nBitsTotal = this._nDataBytes * 8;
                            var nBitsLeft = data.sigBytes * 8;
                            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
                            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
                            data.sigBytes = dataWords.length * 4;
                            this._process();
                            var hash = this._hash.toX32();
                            return hash;
                        },
                        clone: function () {
                            var clone = Hasher.clone.call(this);
                            clone._hash = this._hash.clone();
                            return clone;
                        },
                        blockSize: 1024 / 32
                    });
                    C.SHA512 = Hasher._createHelper(SHA512);
                    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
                }());
                return CryptoJS.SHA512;
            }));
        }, { "./core": 121, "./x64-core": 152 }], 151: [function (require, module, exports) {
            ;
            (function (root, factory, undef) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function () {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var BlockCipher = C_lib.BlockCipher;
                    var C_algo = C.algo;
                    var PC1 = [
                        57, 49, 41, 33, 25, 17, 9, 1,
                        58, 50, 42, 34, 26, 18, 10, 2,
                        59, 51, 43, 35, 27, 19, 11, 3,
                        60, 52, 44, 36, 63, 55, 47, 39,
                        31, 23, 15, 7, 62, 54, 46, 38,
                        30, 22, 14, 6, 61, 53, 45, 37,
                        29, 21, 13, 5, 28, 20, 12, 4
                    ];
                    var PC2 = [
                        14, 17, 11, 24, 1, 5,
                        3, 28, 15, 6, 21, 10,
                        23, 19, 12, 4, 26, 8,
                        16, 7, 27, 20, 13, 2,
                        41, 52, 31, 37, 47, 55,
                        30, 40, 51, 45, 33, 48,
                        44, 49, 39, 56, 34, 53,
                        46, 42, 50, 36, 29, 32
                    ];
                    var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
                    var SBOX_P = [
                        {
                            0x0: 0x808200,
                            0x10000000: 0x8000,
                            0x20000000: 0x808002,
                            0x30000000: 0x2,
                            0x40000000: 0x200,
                            0x50000000: 0x808202,
                            0x60000000: 0x800202,
                            0x70000000: 0x800000,
                            0x80000000: 0x202,
                            0x90000000: 0x800200,
                            0xa0000000: 0x8200,
                            0xb0000000: 0x808000,
                            0xc0000000: 0x8002,
                            0xd0000000: 0x800002,
                            0xe0000000: 0x0,
                            0xf0000000: 0x8202,
                            0x8000000: 0x0,
                            0x18000000: 0x808202,
                            0x28000000: 0x8202,
                            0x38000000: 0x8000,
                            0x48000000: 0x808200,
                            0x58000000: 0x200,
                            0x68000000: 0x808002,
                            0x78000000: 0x2,
                            0x88000000: 0x800200,
                            0x98000000: 0x8200,
                            0xa8000000: 0x808000,
                            0xb8000000: 0x800202,
                            0xc8000000: 0x800002,
                            0xd8000000: 0x8002,
                            0xe8000000: 0x202,
                            0xf8000000: 0x800000,
                            0x1: 0x8000,
                            0x10000001: 0x2,
                            0x20000001: 0x808200,
                            0x30000001: 0x800000,
                            0x40000001: 0x808002,
                            0x50000001: 0x8200,
                            0x60000001: 0x200,
                            0x70000001: 0x800202,
                            0x80000001: 0x808202,
                            0x90000001: 0x808000,
                            0xa0000001: 0x800002,
                            0xb0000001: 0x8202,
                            0xc0000001: 0x202,
                            0xd0000001: 0x800200,
                            0xe0000001: 0x8002,
                            0xf0000001: 0x0,
                            0x8000001: 0x808202,
                            0x18000001: 0x808000,
                            0x28000001: 0x800000,
                            0x38000001: 0x200,
                            0x48000001: 0x8000,
                            0x58000001: 0x800002,
                            0x68000001: 0x2,
                            0x78000001: 0x8202,
                            0x88000001: 0x8002,
                            0x98000001: 0x800202,
                            0xa8000001: 0x202,
                            0xb8000001: 0x808200,
                            0xc8000001: 0x800200,
                            0xd8000001: 0x0,
                            0xe8000001: 0x8200,
                            0xf8000001: 0x808002
                        },
                        {
                            0x0: 0x40084010,
                            0x1000000: 0x4000,
                            0x2000000: 0x80000,
                            0x3000000: 0x40080010,
                            0x4000000: 0x40000010,
                            0x5000000: 0x40084000,
                            0x6000000: 0x40004000,
                            0x7000000: 0x10,
                            0x8000000: 0x84000,
                            0x9000000: 0x40004010,
                            0xa000000: 0x40000000,
                            0xb000000: 0x84010,
                            0xc000000: 0x80010,
                            0xd000000: 0x0,
                            0xe000000: 0x4010,
                            0xf000000: 0x40080000,
                            0x800000: 0x40004000,
                            0x1800000: 0x84010,
                            0x2800000: 0x10,
                            0x3800000: 0x40004010,
                            0x4800000: 0x40084010,
                            0x5800000: 0x40000000,
                            0x6800000: 0x80000,
                            0x7800000: 0x40080010,
                            0x8800000: 0x80010,
                            0x9800000: 0x0,
                            0xa800000: 0x4000,
                            0xb800000: 0x40080000,
                            0xc800000: 0x40000010,
                            0xd800000: 0x84000,
                            0xe800000: 0x40084000,
                            0xf800000: 0x4010,
                            0x10000000: 0x0,
                            0x11000000: 0x40080010,
                            0x12000000: 0x40004010,
                            0x13000000: 0x40084000,
                            0x14000000: 0x40080000,
                            0x15000000: 0x10,
                            0x16000000: 0x84010,
                            0x17000000: 0x4000,
                            0x18000000: 0x4010,
                            0x19000000: 0x80000,
                            0x1a000000: 0x80010,
                            0x1b000000: 0x40000010,
                            0x1c000000: 0x84000,
                            0x1d000000: 0x40004000,
                            0x1e000000: 0x40000000,
                            0x1f000000: 0x40084010,
                            0x10800000: 0x84010,
                            0x11800000: 0x80000,
                            0x12800000: 0x40080000,
                            0x13800000: 0x4000,
                            0x14800000: 0x40004000,
                            0x15800000: 0x40084010,
                            0x16800000: 0x10,
                            0x17800000: 0x40000000,
                            0x18800000: 0x40084000,
                            0x19800000: 0x40000010,
                            0x1a800000: 0x40004010,
                            0x1b800000: 0x80010,
                            0x1c800000: 0x0,
                            0x1d800000: 0x4010,
                            0x1e800000: 0x40080010,
                            0x1f800000: 0x84000
                        },
                        {
                            0x0: 0x104,
                            0x100000: 0x0,
                            0x200000: 0x4000100,
                            0x300000: 0x10104,
                            0x400000: 0x10004,
                            0x500000: 0x4000004,
                            0x600000: 0x4010104,
                            0x700000: 0x4010000,
                            0x800000: 0x4000000,
                            0x900000: 0x4010100,
                            0xa00000: 0x10100,
                            0xb00000: 0x4010004,
                            0xc00000: 0x4000104,
                            0xd00000: 0x10000,
                            0xe00000: 0x4,
                            0xf00000: 0x100,
                            0x80000: 0x4010100,
                            0x180000: 0x4010004,
                            0x280000: 0x0,
                            0x380000: 0x4000100,
                            0x480000: 0x4000004,
                            0x580000: 0x10000,
                            0x680000: 0x10004,
                            0x780000: 0x104,
                            0x880000: 0x4,
                            0x980000: 0x100,
                            0xa80000: 0x4010000,
                            0xb80000: 0x10104,
                            0xc80000: 0x10100,
                            0xd80000: 0x4000104,
                            0xe80000: 0x4010104,
                            0xf80000: 0x4000000,
                            0x1000000: 0x4010100,
                            0x1100000: 0x10004,
                            0x1200000: 0x10000,
                            0x1300000: 0x4000100,
                            0x1400000: 0x100,
                            0x1500000: 0x4010104,
                            0x1600000: 0x4000004,
                            0x1700000: 0x0,
                            0x1800000: 0x4000104,
                            0x1900000: 0x4000000,
                            0x1a00000: 0x4,
                            0x1b00000: 0x10100,
                            0x1c00000: 0x4010000,
                            0x1d00000: 0x104,
                            0x1e00000: 0x10104,
                            0x1f00000: 0x4010004,
                            0x1080000: 0x4000000,
                            0x1180000: 0x104,
                            0x1280000: 0x4010100,
                            0x1380000: 0x0,
                            0x1480000: 0x10004,
                            0x1580000: 0x4000100,
                            0x1680000: 0x100,
                            0x1780000: 0x4010004,
                            0x1880000: 0x10000,
                            0x1980000: 0x4010104,
                            0x1a80000: 0x10104,
                            0x1b80000: 0x4000004,
                            0x1c80000: 0x4000104,
                            0x1d80000: 0x4010000,
                            0x1e80000: 0x4,
                            0x1f80000: 0x10100
                        },
                        {
                            0x0: 0x80401000,
                            0x10000: 0x80001040,
                            0x20000: 0x401040,
                            0x30000: 0x80400000,
                            0x40000: 0x0,
                            0x50000: 0x401000,
                            0x60000: 0x80000040,
                            0x70000: 0x400040,
                            0x80000: 0x80000000,
                            0x90000: 0x400000,
                            0xa0000: 0x40,
                            0xb0000: 0x80001000,
                            0xc0000: 0x80400040,
                            0xd0000: 0x1040,
                            0xe0000: 0x1000,
                            0xf0000: 0x80401040,
                            0x8000: 0x80001040,
                            0x18000: 0x40,
                            0x28000: 0x80400040,
                            0x38000: 0x80001000,
                            0x48000: 0x401000,
                            0x58000: 0x80401040,
                            0x68000: 0x0,
                            0x78000: 0x80400000,
                            0x88000: 0x1000,
                            0x98000: 0x80401000,
                            0xa8000: 0x400000,
                            0xb8000: 0x1040,
                            0xc8000: 0x80000000,
                            0xd8000: 0x400040,
                            0xe8000: 0x401040,
                            0xf8000: 0x80000040,
                            0x100000: 0x400040,
                            0x110000: 0x401000,
                            0x120000: 0x80000040,
                            0x130000: 0x0,
                            0x140000: 0x1040,
                            0x150000: 0x80400040,
                            0x160000: 0x80401000,
                            0x170000: 0x80001040,
                            0x180000: 0x80401040,
                            0x190000: 0x80000000,
                            0x1a0000: 0x80400000,
                            0x1b0000: 0x401040,
                            0x1c0000: 0x80001000,
                            0x1d0000: 0x400000,
                            0x1e0000: 0x40,
                            0x1f0000: 0x1000,
                            0x108000: 0x80400000,
                            0x118000: 0x80401040,
                            0x128000: 0x0,
                            0x138000: 0x401000,
                            0x148000: 0x400040,
                            0x158000: 0x80000000,
                            0x168000: 0x80001040,
                            0x178000: 0x40,
                            0x188000: 0x80000040,
                            0x198000: 0x1000,
                            0x1a8000: 0x80001000,
                            0x1b8000: 0x80400040,
                            0x1c8000: 0x1040,
                            0x1d8000: 0x80401000,
                            0x1e8000: 0x400000,
                            0x1f8000: 0x401040
                        },
                        {
                            0x0: 0x80,
                            0x1000: 0x1040000,
                            0x2000: 0x40000,
                            0x3000: 0x20000000,
                            0x4000: 0x20040080,
                            0x5000: 0x1000080,
                            0x6000: 0x21000080,
                            0x7000: 0x40080,
                            0x8000: 0x1000000,
                            0x9000: 0x20040000,
                            0xa000: 0x20000080,
                            0xb000: 0x21040080,
                            0xc000: 0x21040000,
                            0xd000: 0x0,
                            0xe000: 0x1040080,
                            0xf000: 0x21000000,
                            0x800: 0x1040080,
                            0x1800: 0x21000080,
                            0x2800: 0x80,
                            0x3800: 0x1040000,
                            0x4800: 0x40000,
                            0x5800: 0x20040080,
                            0x6800: 0x21040000,
                            0x7800: 0x20000000,
                            0x8800: 0x20040000,
                            0x9800: 0x0,
                            0xa800: 0x21040080,
                            0xb800: 0x1000080,
                            0xc800: 0x20000080,
                            0xd800: 0x21000000,
                            0xe800: 0x1000000,
                            0xf800: 0x40080,
                            0x10000: 0x40000,
                            0x11000: 0x80,
                            0x12000: 0x20000000,
                            0x13000: 0x21000080,
                            0x14000: 0x1000080,
                            0x15000: 0x21040000,
                            0x16000: 0x20040080,
                            0x17000: 0x1000000,
                            0x18000: 0x21040080,
                            0x19000: 0x21000000,
                            0x1a000: 0x1040000,
                            0x1b000: 0x20040000,
                            0x1c000: 0x40080,
                            0x1d000: 0x20000080,
                            0x1e000: 0x0,
                            0x1f000: 0x1040080,
                            0x10800: 0x21000080,
                            0x11800: 0x1000000,
                            0x12800: 0x1040000,
                            0x13800: 0x20040080,
                            0x14800: 0x20000000,
                            0x15800: 0x1040080,
                            0x16800: 0x80,
                            0x17800: 0x21040000,
                            0x18800: 0x40080,
                            0x19800: 0x21040080,
                            0x1a800: 0x0,
                            0x1b800: 0x21000000,
                            0x1c800: 0x1000080,
                            0x1d800: 0x40000,
                            0x1e800: 0x20040000,
                            0x1f800: 0x20000080
                        },
                        {
                            0x0: 0x10000008,
                            0x100: 0x2000,
                            0x200: 0x10200000,
                            0x300: 0x10202008,
                            0x400: 0x10002000,
                            0x500: 0x200000,
                            0x600: 0x200008,
                            0x700: 0x10000000,
                            0x800: 0x0,
                            0x900: 0x10002008,
                            0xa00: 0x202000,
                            0xb00: 0x8,
                            0xc00: 0x10200008,
                            0xd00: 0x202008,
                            0xe00: 0x2008,
                            0xf00: 0x10202000,
                            0x80: 0x10200000,
                            0x180: 0x10202008,
                            0x280: 0x8,
                            0x380: 0x200000,
                            0x480: 0x202008,
                            0x580: 0x10000008,
                            0x680: 0x10002000,
                            0x780: 0x2008,
                            0x880: 0x200008,
                            0x980: 0x2000,
                            0xa80: 0x10002008,
                            0xb80: 0x10200008,
                            0xc80: 0x0,
                            0xd80: 0x10202000,
                            0xe80: 0x202000,
                            0xf80: 0x10000000,
                            0x1000: 0x10002000,
                            0x1100: 0x10200008,
                            0x1200: 0x10202008,
                            0x1300: 0x2008,
                            0x1400: 0x200000,
                            0x1500: 0x10000000,
                            0x1600: 0x10000008,
                            0x1700: 0x202000,
                            0x1800: 0x202008,
                            0x1900: 0x0,
                            0x1a00: 0x8,
                            0x1b00: 0x10200000,
                            0x1c00: 0x2000,
                            0x1d00: 0x10002008,
                            0x1e00: 0x10202000,
                            0x1f00: 0x200008,
                            0x1080: 0x8,
                            0x1180: 0x202000,
                            0x1280: 0x200000,
                            0x1380: 0x10000008,
                            0x1480: 0x10002000,
                            0x1580: 0x2008,
                            0x1680: 0x10202008,
                            0x1780: 0x10200000,
                            0x1880: 0x10202000,
                            0x1980: 0x10200008,
                            0x1a80: 0x2000,
                            0x1b80: 0x202008,
                            0x1c80: 0x200008,
                            0x1d80: 0x0,
                            0x1e80: 0x10000000,
                            0x1f80: 0x10002008
                        },
                        {
                            0x0: 0x100000,
                            0x10: 0x2000401,
                            0x20: 0x400,
                            0x30: 0x100401,
                            0x40: 0x2100401,
                            0x50: 0x0,
                            0x60: 0x1,
                            0x70: 0x2100001,
                            0x80: 0x2000400,
                            0x90: 0x100001,
                            0xa0: 0x2000001,
                            0xb0: 0x2100400,
                            0xc0: 0x2100000,
                            0xd0: 0x401,
                            0xe0: 0x100400,
                            0xf0: 0x2000000,
                            0x8: 0x2100001,
                            0x18: 0x0,
                            0x28: 0x2000401,
                            0x38: 0x2100400,
                            0x48: 0x100000,
                            0x58: 0x2000001,
                            0x68: 0x2000000,
                            0x78: 0x401,
                            0x88: 0x100401,
                            0x98: 0x2000400,
                            0xa8: 0x2100000,
                            0xb8: 0x100001,
                            0xc8: 0x400,
                            0xd8: 0x2100401,
                            0xe8: 0x1,
                            0xf8: 0x100400,
                            0x100: 0x2000000,
                            0x110: 0x100000,
                            0x120: 0x2000401,
                            0x130: 0x2100001,
                            0x140: 0x100001,
                            0x150: 0x2000400,
                            0x160: 0x2100400,
                            0x170: 0x100401,
                            0x180: 0x401,
                            0x190: 0x2100401,
                            0x1a0: 0x100400,
                            0x1b0: 0x1,
                            0x1c0: 0x0,
                            0x1d0: 0x2100000,
                            0x1e0: 0x2000001,
                            0x1f0: 0x400,
                            0x108: 0x100400,
                            0x118: 0x2000401,
                            0x128: 0x2100001,
                            0x138: 0x1,
                            0x148: 0x2000000,
                            0x158: 0x100000,
                            0x168: 0x401,
                            0x178: 0x2100400,
                            0x188: 0x2000001,
                            0x198: 0x2100000,
                            0x1a8: 0x0,
                            0x1b8: 0x2100401,
                            0x1c8: 0x100401,
                            0x1d8: 0x400,
                            0x1e8: 0x2000400,
                            0x1f8: 0x100001
                        },
                        {
                            0x0: 0x8000820,
                            0x1: 0x20000,
                            0x2: 0x8000000,
                            0x3: 0x20,
                            0x4: 0x20020,
                            0x5: 0x8020820,
                            0x6: 0x8020800,
                            0x7: 0x800,
                            0x8: 0x8020000,
                            0x9: 0x8000800,
                            0xa: 0x20800,
                            0xb: 0x8020020,
                            0xc: 0x820,
                            0xd: 0x0,
                            0xe: 0x8000020,
                            0xf: 0x20820,
                            0x80000000: 0x800,
                            0x80000001: 0x8020820,
                            0x80000002: 0x8000820,
                            0x80000003: 0x8000000,
                            0x80000004: 0x8020000,
                            0x80000005: 0x20800,
                            0x80000006: 0x20820,
                            0x80000007: 0x20,
                            0x80000008: 0x8000020,
                            0x80000009: 0x820,
                            0x8000000a: 0x20020,
                            0x8000000b: 0x8020800,
                            0x8000000c: 0x0,
                            0x8000000d: 0x8020020,
                            0x8000000e: 0x8000800,
                            0x8000000f: 0x20000,
                            0x10: 0x20820,
                            0x11: 0x8020800,
                            0x12: 0x20,
                            0x13: 0x800,
                            0x14: 0x8000800,
                            0x15: 0x8000020,
                            0x16: 0x8020020,
                            0x17: 0x20000,
                            0x18: 0x0,
                            0x19: 0x20020,
                            0x1a: 0x8020000,
                            0x1b: 0x8000820,
                            0x1c: 0x8020820,
                            0x1d: 0x20800,
                            0x1e: 0x820,
                            0x1f: 0x8000000,
                            0x80000010: 0x20000,
                            0x80000011: 0x800,
                            0x80000012: 0x8020020,
                            0x80000013: 0x20820,
                            0x80000014: 0x20,
                            0x80000015: 0x8020000,
                            0x80000016: 0x8000000,
                            0x80000017: 0x8000820,
                            0x80000018: 0x8020820,
                            0x80000019: 0x8000020,
                            0x8000001a: 0x8000800,
                            0x8000001b: 0x0,
                            0x8000001c: 0x20800,
                            0x8000001d: 0x820,
                            0x8000001e: 0x20020,
                            0x8000001f: 0x8020800
                        }
                    ];
                    var SBOX_MASK = [
                        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
                        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
                    ];
                    var DES = C_algo.DES = BlockCipher.extend({
                        _doReset: function () {
                            var key = this._key;
                            var keyWords = key.words;
                            var keyBits = [];
                            for (var i = 0; i < 56; i++) {
                                var keyBitPos = PC1[i] - 1;
                                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
                            }
                            var subKeys = this._subKeys = [];
                            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                                var subKey = subKeys[nSubKey] = [];
                                var bitShift = BIT_SHIFTS[nSubKey];
                                for (var i = 0; i < 24; i++) {
                                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);
                                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
                                }
                                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
                                for (var i = 1; i < 7; i++) {
                                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
                                }
                                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
                            }
                            var invSubKeys = this._invSubKeys = [];
                            for (var i = 0; i < 16; i++) {
                                invSubKeys[i] = subKeys[15 - i];
                            }
                        },
                        encryptBlock: function (M, offset) {
                            this._doCryptBlock(M, offset, this._subKeys);
                        },
                        decryptBlock: function (M, offset) {
                            this._doCryptBlock(M, offset, this._invSubKeys);
                        },
                        _doCryptBlock: function (M, offset, subKeys) {
                            this._lBlock = M[offset];
                            this._rBlock = M[offset + 1];
                            exchangeLR.call(this, 4, 0x0f0f0f0f);
                            exchangeLR.call(this, 16, 0x0000ffff);
                            exchangeRL.call(this, 2, 0x33333333);
                            exchangeRL.call(this, 8, 0x00ff00ff);
                            exchangeLR.call(this, 1, 0x55555555);
                            for (var round = 0; round < 16; round++) {
                                var subKey = subKeys[round];
                                var lBlock = this._lBlock;
                                var rBlock = this._rBlock;
                                var f = 0;
                                for (var i = 0; i < 8; i++) {
                                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                                }
                                this._lBlock = rBlock;
                                this._rBlock = lBlock ^ f;
                            }
                            var t = this._lBlock;
                            this._lBlock = this._rBlock;
                            this._rBlock = t;
                            exchangeLR.call(this, 1, 0x55555555);
                            exchangeRL.call(this, 8, 0x00ff00ff);
                            exchangeRL.call(this, 2, 0x33333333);
                            exchangeLR.call(this, 16, 0x0000ffff);
                            exchangeLR.call(this, 4, 0x0f0f0f0f);
                            M[offset] = this._lBlock;
                            M[offset + 1] = this._rBlock;
                        },
                        keySize: 64 / 32,
                        ivSize: 64 / 32,
                        blockSize: 64 / 32
                    });
                    function exchangeLR(offset, mask) {
                        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
                        this._rBlock ^= t;
                        this._lBlock ^= t << offset;
                    }
                    function exchangeRL(offset, mask) {
                        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
                        this._lBlock ^= t;
                        this._rBlock ^= t << offset;
                    }
                    C.DES = BlockCipher._createHelper(DES);
                    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
                        _doReset: function () {
                            var key = this._key;
                            var keyWords = key.words;
                            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
                            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
                            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
                        },
                        encryptBlock: function (M, offset) {
                            this._des1.encryptBlock(M, offset);
                            this._des2.decryptBlock(M, offset);
                            this._des3.encryptBlock(M, offset);
                        },
                        decryptBlock: function (M, offset) {
                            this._des3.decryptBlock(M, offset);
                            this._des2.encryptBlock(M, offset);
                            this._des1.decryptBlock(M, offset);
                        },
                        keySize: 192 / 32,
                        ivSize: 64 / 32,
                        blockSize: 64 / 32
                    });
                    C.TripleDES = BlockCipher._createHelper(TripleDES);
                }());
                return CryptoJS.TripleDES;
            }));
        }, { "./cipher-core": 120, "./core": 121, "./enc-base64": 122, "./evpkdf": 124, "./md5": 129 }], 152: [function (require, module, exports) {
            ;
            (function (root, factory) {
                if (typeof exports === "object") {
                    module.exports = exports = factory(require("./core"));
                }
                else if (typeof define === "function" && define.amd) {
                    define(["./core"], factory);
                }
                else {
                    factory(root.CryptoJS);
                }
            }(this, function (CryptoJS) {
                (function (undefined) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var X32WordArray = C_lib.WordArray;
                    var C_x64 = C.x64 = {};
                    var X64Word = C_x64.Word = Base.extend({
                        init: function (high, low) {
                            this.high = high;
                            this.low = low;
                        }
                    });
                    var X64WordArray = C_x64.WordArray = Base.extend({
                        init: function (words, sigBytes) {
                            words = this.words = words || [];
                            if (sigBytes != undefined) {
                                this.sigBytes = sigBytes;
                            }
                            else {
                                this.sigBytes = words.length * 8;
                            }
                        },
                        toX32: function () {
                            var x64Words = this.words;
                            var x64WordsLength = x64Words.length;
                            var x32Words = [];
                            for (var i = 0; i < x64WordsLength; i++) {
                                var x64Word = x64Words[i];
                                x32Words.push(x64Word.high);
                                x32Words.push(x64Word.low);
                            }
                            return X32WordArray.create(x32Words, this.sigBytes);
                        },
                        clone: function () {
                            var clone = Base.clone.call(this);
                            var words = clone.words = this.words.slice(0);
                            var wordsLength = words.length;
                            for (var i = 0; i < wordsLength; i++) {
                                words[i] = words[i].clone();
                            }
                            return clone;
                        }
                    });
                }());
                return CryptoJS;
            }));
        }, { "./core": 121 }], 153: [function (require, module, exports) {
            (function (self) {
                'use strict';
                function fetchPonyfill(options) {
                    var Promise = options && options.Promise || self.Promise;
                    var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;
                    var global = self;
                    return (function () {
                        var self = Object.create(global, {
                            fetch: {
                                value: undefined,
                                writable: true
                            }
                        });
                        (function (self) {
                            'use strict';
                            if (self.fetch) {
                                return;
                            }
                            var support = {
                                searchParams: 'URLSearchParams' in self,
                                iterable: 'Symbol' in self && 'iterator' in Symbol,
                                blob: 'FileReader' in self && 'Blob' in self && (function () {
                                    try {
                                        new Blob();
                                        return true;
                                    }
                                    catch (e) {
                                        return false;
                                    }
                                })(),
                                formData: 'FormData' in self,
                                arrayBuffer: 'ArrayBuffer' in self
                            };
                            if (support.arrayBuffer) {
                                var viewClasses = [
                                    '[object Int8Array]',
                                    '[object Uint8Array]',
                                    '[object Uint8ClampedArray]',
                                    '[object Int16Array]',
                                    '[object Uint16Array]',
                                    '[object Int32Array]',
                                    '[object Uint32Array]',
                                    '[object Float32Array]',
                                    '[object Float64Array]'
                                ];
                                var isDataView = function (obj) {
                                    return obj && DataView.prototype.isPrototypeOf(obj);
                                };
                                var isArrayBufferView = ArrayBuffer.isView || function (obj) {
                                    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
                                };
                            }
                            function normalizeName(name) {
                                if (typeof name !== 'string') {
                                    name = String(name);
                                }
                                if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                                    throw new TypeError('Invalid character in header field name');
                                }
                                return name.toLowerCase();
                            }
                            function normalizeValue(value) {
                                if (typeof value !== 'string') {
                                    value = String(value);
                                }
                                return value;
                            }
                            function iteratorFor(items) {
                                var iterator = {
                                    next: function () {
                                        var value = items.shift();
                                        return { done: value === undefined, value: value };
                                    }
                                };
                                if (support.iterable) {
                                    iterator[Symbol.iterator] = function () {
                                        return iterator;
                                    };
                                }
                                return iterator;
                            }
                            function Headers(headers) {
                                this.map = {};
                                if (headers instanceof Headers) {
                                    headers.forEach(function (value, name) {
                                        this.append(name, value);
                                    }, this);
                                }
                                else if (Array.isArray(headers)) {
                                    headers.forEach(function (header) {
                                        this.append(header[0], header[1]);
                                    }, this);
                                }
                                else if (headers) {
                                    Object.getOwnPropertyNames(headers).forEach(function (name) {
                                        this.append(name, headers[name]);
                                    }, this);
                                }
                            }
                            Headers.prototype.append = function (name, value) {
                                name = normalizeName(name);
                                value = normalizeValue(value);
                                var oldValue = this.map[name];
                                this.map[name] = oldValue ? oldValue + ',' + value : value;
                            };
                            Headers.prototype['delete'] = function (name) {
                                delete this.map[normalizeName(name)];
                            };
                            Headers.prototype.get = function (name) {
                                name = normalizeName(name);
                                return this.has(name) ? this.map[name] : null;
                            };
                            Headers.prototype.has = function (name) {
                                return this.map.hasOwnProperty(normalizeName(name));
                            };
                            Headers.prototype.set = function (name, value) {
                                this.map[normalizeName(name)] = normalizeValue(value);
                            };
                            Headers.prototype.forEach = function (callback, thisArg) {
                                for (var name in this.map) {
                                    if (this.map.hasOwnProperty(name)) {
                                        callback.call(thisArg, this.map[name], name, this);
                                    }
                                }
                            };
                            Headers.prototype.keys = function () {
                                var items = [];
                                this.forEach(function (value, name) { items.push(name); });
                                return iteratorFor(items);
                            };
                            Headers.prototype.values = function () {
                                var items = [];
                                this.forEach(function (value) { items.push(value); });
                                return iteratorFor(items);
                            };
                            Headers.prototype.entries = function () {
                                var items = [];
                                this.forEach(function (value, name) { items.push([name, value]); });
                                return iteratorFor(items);
                            };
                            if (support.iterable) {
                                Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
                            }
                            function consumed(body) {
                                if (body.bodyUsed) {
                                    return Promise.reject(new TypeError('Already read'));
                                }
                                body.bodyUsed = true;
                            }
                            function fileReaderReady(reader) {
                                return new Promise(function (resolve, reject) {
                                    reader.onload = function () {
                                        resolve(reader.result);
                                    };
                                    reader.onerror = function () {
                                        reject(reader.error);
                                    };
                                });
                            }
                            function readBlobAsArrayBuffer(blob) {
                                var reader = new FileReader();
                                var promise = fileReaderReady(reader);
                                reader.readAsArrayBuffer(blob);
                                return promise;
                            }
                            function readBlobAsText(blob) {
                                var reader = new FileReader();
                                var promise = fileReaderReady(reader);
                                reader.readAsText(blob);
                                return promise;
                            }
                            function readArrayBufferAsText(buf) {
                                var view = new Uint8Array(buf);
                                var chars = new Array(view.length);
                                for (var i = 0; i < view.length; i++) {
                                    chars[i] = String.fromCharCode(view[i]);
                                }
                                return chars.join('');
                            }
                            function bufferClone(buf) {
                                if (buf.slice) {
                                    return buf.slice(0);
                                }
                                else {
                                    var view = new Uint8Array(buf.byteLength);
                                    view.set(new Uint8Array(buf));
                                    return view.buffer;
                                }
                            }
                            function Body() {
                                this.bodyUsed = false;
                                this._initBody = function (body) {
                                    this._bodyInit = body;
                                    if (!body) {
                                        this._bodyText = '';
                                    }
                                    else if (typeof body === 'string') {
                                        this._bodyText = body;
                                    }
                                    else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                                        this._bodyBlob = body;
                                    }
                                    else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                                        this._bodyFormData = body;
                                    }
                                    else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                                        this._bodyText = body.toString();
                                    }
                                    else if (support.arrayBuffer && support.blob && isDataView(body)) {
                                        this._bodyArrayBuffer = bufferClone(body.buffer);
                                        this._bodyInit = new Blob([this._bodyArrayBuffer]);
                                    }
                                    else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                                        this._bodyArrayBuffer = bufferClone(body);
                                    }
                                    else {
                                        throw new Error('unsupported BodyInit type');
                                    }
                                    if (!this.headers.get('content-type')) {
                                        if (typeof body === 'string') {
                                            this.headers.set('content-type', 'text/plain;charset=UTF-8');
                                        }
                                        else if (this._bodyBlob && this._bodyBlob.type) {
                                            this.headers.set('content-type', this._bodyBlob.type);
                                        }
                                        else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                                            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                                        }
                                    }
                                };
                                if (support.blob) {
                                    this.blob = function () {
                                        var rejected = consumed(this);
                                        if (rejected) {
                                            return rejected;
                                        }
                                        if (this._bodyBlob) {
                                            return Promise.resolve(this._bodyBlob);
                                        }
                                        else if (this._bodyArrayBuffer) {
                                            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                                        }
                                        else if (this._bodyFormData) {
                                            throw new Error('could not read FormData body as blob');
                                        }
                                        else {
                                            return Promise.resolve(new Blob([this._bodyText]));
                                        }
                                    };
                                    this.arrayBuffer = function () {
                                        if (this._bodyArrayBuffer) {
                                            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                                        }
                                        else {
                                            return this.blob().then(readBlobAsArrayBuffer);
                                        }
                                    };
                                }
                                this.text = function () {
                                    var rejected = consumed(this);
                                    if (rejected) {
                                        return rejected;
                                    }
                                    if (this._bodyBlob) {
                                        return readBlobAsText(this._bodyBlob);
                                    }
                                    else if (this._bodyArrayBuffer) {
                                        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                                    }
                                    else if (this._bodyFormData) {
                                        throw new Error('could not read FormData body as text');
                                    }
                                    else {
                                        return Promise.resolve(this._bodyText);
                                    }
                                };
                                if (support.formData) {
                                    this.formData = function () {
                                        return this.text().then(decode);
                                    };
                                }
                                this.json = function () {
                                    return this.text().then(JSON.parse);
                                };
                                return this;
                            }
                            var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
                            function normalizeMethod(method) {
                                var upcased = method.toUpperCase();
                                return (methods.indexOf(upcased) > -1) ? upcased : method;
                            }
                            function Request(input, options) {
                                options = options || {};
                                var body = options.body;
                                if (input instanceof Request) {
                                    if (input.bodyUsed) {
                                        throw new TypeError('Already read');
                                    }
                                    this.url = input.url;
                                    this.credentials = input.credentials;
                                    if (!options.headers) {
                                        this.headers = new Headers(input.headers);
                                    }
                                    this.method = input.method;
                                    this.mode = input.mode;
                                    if (!body && input._bodyInit != null) {
                                        body = input._bodyInit;
                                        input.bodyUsed = true;
                                    }
                                }
                                else {
                                    this.url = String(input);
                                }
                                this.credentials = options.credentials || this.credentials || 'omit';
                                if (options.headers || !this.headers) {
                                    this.headers = new Headers(options.headers);
                                }
                                this.method = normalizeMethod(options.method || this.method || 'GET');
                                this.mode = options.mode || this.mode || null;
                                this.referrer = null;
                                if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                                    throw new TypeError('Body not allowed for GET or HEAD requests');
                                }
                                this._initBody(body);
                            }
                            Request.prototype.clone = function () {
                                return new Request(this, { body: this._bodyInit });
                            };
                            function decode(body) {
                                var form = new FormData();
                                body.trim().split('&').forEach(function (bytes) {
                                    if (bytes) {
                                        var split = bytes.split('=');
                                        var name = split.shift().replace(/\+/g, ' ');
                                        var value = split.join('=').replace(/\+/g, ' ');
                                        form.append(decodeURIComponent(name), decodeURIComponent(value));
                                    }
                                });
                                return form;
                            }
                            function parseHeaders(rawHeaders) {
                                var headers = new Headers();
                                rawHeaders.split(/\r?\n/).forEach(function (line) {
                                    var parts = line.split(':');
                                    var key = parts.shift().trim();
                                    if (key) {
                                        var value = parts.join(':').trim();
                                        headers.append(key, value);
                                    }
                                });
                                return headers;
                            }
                            Body.call(Request.prototype);
                            function Response(bodyInit, options) {
                                if (!options) {
                                    options = {};
                                }
                                this.type = 'default';
                                this.status = 'status' in options ? options.status : 200;
                                this.ok = this.status >= 200 && this.status < 300;
                                this.statusText = 'statusText' in options ? options.statusText : 'OK';
                                this.headers = new Headers(options.headers);
                                this.url = options.url || '';
                                this._initBody(bodyInit);
                            }
                            Body.call(Response.prototype);
                            Response.prototype.clone = function () {
                                return new Response(this._bodyInit, {
                                    status: this.status,
                                    statusText: this.statusText,
                                    headers: new Headers(this.headers),
                                    url: this.url
                                });
                            };
                            Response.error = function () {
                                var response = new Response(null, { status: 0, statusText: '' });
                                response.type = 'error';
                                return response;
                            };
                            var redirectStatuses = [301, 302, 303, 307, 308];
                            Response.redirect = function (url, status) {
                                if (redirectStatuses.indexOf(status) === -1) {
                                    throw new RangeError('Invalid status code');
                                }
                                return new Response(null, { status: status, headers: { location: url } });
                            };
                            self.Headers = Headers;
                            self.Request = Request;
                            self.Response = Response;
                            self.fetch = function (input, init) {
                                return new Promise(function (resolve, reject) {
                                    var request = new Request(input, init);
                                    var xhr = new XMLHttpRequest();
                                    xhr.onload = function () {
                                        var options = {
                                            status: xhr.status,
                                            statusText: xhr.statusText,
                                            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                                        };
                                        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                                        var body = 'response' in xhr ? xhr.response : xhr.responseText;
                                        resolve(new Response(body, options));
                                    };
                                    xhr.onerror = function () {
                                        reject(new TypeError('Network request failed'));
                                    };
                                    xhr.ontimeout = function () {
                                        reject(new TypeError('Network request failed'));
                                    };
                                    xhr.open(request.method, request.url, true);
                                    if (request.credentials === 'include') {
                                        xhr.withCredentials = true;
                                    }
                                    if ('responseType' in xhr && support.blob) {
                                        xhr.responseType = 'blob';
                                    }
                                    request.headers.forEach(function (value, name) {
                                        xhr.setRequestHeader(name, value);
                                    });
                                    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
                                });
                            };
                            self.fetch.polyfill = true;
                        })(typeof self !== 'undefined' ? self : this);
                        return {
                            fetch: self.fetch,
                            Headers: self.Headers,
                            Request: self.Request,
                            Response: self.Response
                        };
                    }());
                }
                if (typeof define === 'function' && define.amd) {
                    define(function () {
                        return fetchPonyfill;
                    });
                }
                else if (typeof exports === 'object') {
                    module.exports = fetchPonyfill;
                }
                else {
                    self.fetchPonyfill = fetchPonyfill;
                }
            }(typeof self === 'undefined' ? this : self));
        }, {}], 154: [function (require, module, exports) {
            var process = module.exports = {};
            var cachedSetTimeout;
            var cachedClearTimeout;
            function defaultSetTimout() {
                throw new Error('setTimeout has not been defined');
            }
            function defaultClearTimeout() {
                throw new Error('clearTimeout has not been defined');
            }
            (function () {
                try {
                    if (typeof setTimeout === 'function') {
                        cachedSetTimeout = setTimeout;
                    }
                    else {
                        cachedSetTimeout = defaultSetTimout;
                    }
                }
                catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === 'function') {
                        cachedClearTimeout = clearTimeout;
                    }
                    else {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                }
                catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            }());
            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                    return setTimeout(fun, 0);
                }
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    return cachedSetTimeout(fun, 0);
                }
                catch (e) {
                    try {
                        return cachedSetTimeout.call(null, fun, 0);
                    }
                    catch (e) {
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }
            }
            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                    return clearTimeout(marker);
                }
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    return cachedClearTimeout(marker);
                }
                catch (e) {
                    try {
                        return cachedClearTimeout.call(null, marker);
                    }
                    catch (e) {
                        return cachedClearTimeout.call(this, marker);
                    }
                }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;
            function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                    return;
                }
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                }
                else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }
            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;
                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }
            process.nextTick = function (fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                }
            };
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = '';
            process.versions = {};
            function noop() { }
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;
            process.listeners = function (name) { return []; };
            process.binding = function (name) {
                throw new Error('process.binding is not supported');
            };
            process.cwd = function () { return '/'; };
            process.chdir = function (dir) {
                throw new Error('process.chdir is not supported');
            };
            process.umask = function () { return 0; };
        }, {}], 155: [function (require, module, exports) {
            'use strict';
            var replace = String.prototype.replace;
            var percentTwenties = /%20/g;
            module.exports = {
                'default': 'RFC3986',
                formatters: {
                    RFC1738: function (value) {
                        return replace.call(value, percentTwenties, '+');
                    },
                    RFC3986: function (value) {
                        return value;
                    }
                },
                RFC1738: 'RFC1738',
                RFC3986: 'RFC3986'
            };
        }, {}], 156: [function (require, module, exports) {
            'use strict';
            var stringify = require('./stringify');
            var parse = require('./parse');
            var formats = require('./formats');
            module.exports = {
                formats: formats,
                parse: parse,
                stringify: stringify
            };
        }, { "./formats": 155, "./parse": 157, "./stringify": 158 }], 157: [function (require, module, exports) {
            'use strict';
            var utils = require('./utils');
            var has = Object.prototype.hasOwnProperty;
            var defaults = {
                allowDots: false,
                allowPrototypes: false,
                arrayLimit: 20,
                decoder: utils.decode,
                delimiter: '&',
                depth: 5,
                parameterLimit: 1000,
                plainObjects: false,
                strictNullHandling: false
            };
            var parseValues = function parseQueryStringValues(str, options) {
                var obj = {};
                var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
                var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
                var parts = cleanStr.split(options.delimiter, limit);
                for (var i = 0; i < parts.length; ++i) {
                    var part = parts[i];
                    var bracketEqualsPos = part.indexOf(']=');
                    var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
                    var key, val;
                    if (pos === -1) {
                        key = options.decoder(part, defaults.decoder);
                        val = options.strictNullHandling ? null : '';
                    }
                    else {
                        key = options.decoder(part.slice(0, pos), defaults.decoder);
                        val = options.decoder(part.slice(pos + 1), defaults.decoder);
                    }
                    if (has.call(obj, key)) {
                        obj[key] = [].concat(obj[key]).concat(val);
                    }
                    else {
                        obj[key] = val;
                    }
                }
                return obj;
            };
            var parseObject = function (chain, val, options) {
                var leaf = val;
                for (var i = chain.length - 1; i >= 0; --i) {
                    var obj;
                    var root = chain[i];
                    if (root === '[]') {
                        obj = [];
                        obj = obj.concat(leaf);
                    }
                    else {
                        obj = options.plainObjects ? Object.create(null) : {};
                        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
                        var index = parseInt(cleanRoot, 10);
                        if (!isNaN(index)
                            && root !== cleanRoot
                            && String(index) === cleanRoot
                            && index >= 0
                            && (options.parseArrays && index <= options.arrayLimit)) {
                            obj = [];
                            obj[index] = leaf;
                        }
                        else {
                            obj[cleanRoot] = leaf;
                        }
                    }
                    leaf = obj;
                }
                return leaf;
            };
            var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
                if (!givenKey) {
                    return;
                }
                var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
                var brackets = /(\[[^[\]]*])/;
                var child = /(\[[^[\]]*])/g;
                var segment = brackets.exec(key);
                var parent = segment ? key.slice(0, segment.index) : key;
                var keys = [];
                if (parent) {
                    if (!options.plainObjects && has.call(Object.prototype, parent)) {
                        if (!options.allowPrototypes) {
                            return;
                        }
                    }
                    keys.push(parent);
                }
                var i = 0;
                while ((segment = child.exec(key)) !== null && i < options.depth) {
                    i += 1;
                    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
                        if (!options.allowPrototypes) {
                            return;
                        }
                    }
                    keys.push(segment[1]);
                }
                if (segment) {
                    keys.push('[' + key.slice(segment.index) + ']');
                }
                return parseObject(keys, val, options);
            };
            module.exports = function (str, opts) {
                var options = opts ? utils.assign({}, opts) : {};
                if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
                    throw new TypeError('Decoder has to be a function.');
                }
                options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
                options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
                options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
                options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
                options.parseArrays = options.parseArrays !== false;
                options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
                options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
                options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
                options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
                options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
                options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
                if (str === '' || str === null || typeof str === 'undefined') {
                    return options.plainObjects ? Object.create(null) : {};
                }
                var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
                var obj = options.plainObjects ? Object.create(null) : {};
                var keys = Object.keys(tempObj);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    var newObj = parseKeys(key, tempObj[key], options);
                    obj = utils.merge(obj, newObj, options);
                }
                return utils.compact(obj);
            };
        }, { "./utils": 159 }], 158: [function (require, module, exports) {
            'use strict';
            var utils = require('./utils');
            var formats = require('./formats');
            var arrayPrefixGenerators = {
                brackets: function brackets(prefix) {
                    return prefix + '[]';
                },
                indices: function indices(prefix, key) {
                    return prefix + '[' + key + ']';
                },
                repeat: function repeat(prefix) {
                    return prefix;
                }
            };
            var toISO = Date.prototype.toISOString;
            var defaults = {
                delimiter: '&',
                encode: true,
                encoder: utils.encode,
                encodeValuesOnly: false,
                serializeDate: function serializeDate(date) {
                    return toISO.call(date);
                },
                skipNulls: false,
                strictNullHandling: false
            };
            var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
                var obj = object;
                if (typeof filter === 'function') {
                    obj = filter(prefix, obj);
                }
                else if (obj instanceof Date) {
                    obj = serializeDate(obj);
                }
                else if (obj === null) {
                    if (strictNullHandling) {
                        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
                    }
                    obj = '';
                }
                if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
                    if (encoder) {
                        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
                        return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
                    }
                    return [formatter(prefix) + '=' + formatter(String(obj))];
                }
                var values = [];
                if (typeof obj === 'undefined') {
                    return values;
                }
                var objKeys;
                if (Array.isArray(filter)) {
                    objKeys = filter;
                }
                else {
                    var keys = Object.keys(obj);
                    objKeys = sort ? keys.sort(sort) : keys;
                }
                for (var i = 0; i < objKeys.length; ++i) {
                    var key = objKeys[i];
                    if (skipNulls && obj[key] === null) {
                        continue;
                    }
                    if (Array.isArray(obj)) {
                        values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
                    }
                    else {
                        values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
                    }
                }
                return values;
            };
            module.exports = function (object, opts) {
                var obj = object;
                var options = opts ? utils.assign({}, opts) : {};
                if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
                    throw new TypeError('Encoder has to be a function.');
                }
                var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
                var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
                var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
                var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
                var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
                var sort = typeof options.sort === 'function' ? options.sort : null;
                var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
                var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
                var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
                if (typeof options.format === 'undefined') {
                    options.format = formats['default'];
                }
                else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
                    throw new TypeError('Unknown format option provided.');
                }
                var formatter = formats.formatters[options.format];
                var objKeys;
                var filter;
                if (typeof options.filter === 'function') {
                    filter = options.filter;
                    obj = filter('', obj);
                }
                else if (Array.isArray(options.filter)) {
                    filter = options.filter;
                    objKeys = filter;
                }
                var keys = [];
                if (typeof obj !== 'object' || obj === null) {
                    return '';
                }
                var arrayFormat;
                if (options.arrayFormat in arrayPrefixGenerators) {
                    arrayFormat = options.arrayFormat;
                }
                else if ('indices' in options) {
                    arrayFormat = options.indices ? 'indices' : 'repeat';
                }
                else {
                    arrayFormat = 'indices';
                }
                var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
                if (!objKeys) {
                    objKeys = Object.keys(obj);
                }
                if (sort) {
                    objKeys.sort(sort);
                }
                for (var i = 0; i < objKeys.length; ++i) {
                    var key = objKeys[i];
                    if (skipNulls && obj[key] === null) {
                        continue;
                    }
                    keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
                }
                var joined = keys.join(delimiter);
                var prefix = options.addQueryPrefix === true ? '?' : '';
                return joined.length > 0 ? prefix + joined : '';
            };
        }, { "./formats": 155, "./utils": 159 }], 159: [function (require, module, exports) {
            'use strict';
            var has = Object.prototype.hasOwnProperty;
            var hexTable = (function () {
                var array = [];
                for (var i = 0; i < 256; ++i) {
                    array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
                }
                return array;
            }());
            var compactQueue = function compactQueue(queue) {
                var obj;
                while (queue.length) {
                    var item = queue.pop();
                    obj = item.obj[item.prop];
                    if (Array.isArray(obj)) {
                        var compacted = [];
                        for (var j = 0; j < obj.length; ++j) {
                            if (typeof obj[j] !== 'undefined') {
                                compacted.push(obj[j]);
                            }
                        }
                        item.obj[item.prop] = compacted;
                    }
                }
                return obj;
            };
            exports.arrayToObject = function arrayToObject(source, options) {
                var obj = options && options.plainObjects ? Object.create(null) : {};
                for (var i = 0; i < source.length; ++i) {
                    if (typeof source[i] !== 'undefined') {
                        obj[i] = source[i];
                    }
                }
                return obj;
            };
            exports.merge = function merge(target, source, options) {
                if (!source) {
                    return target;
                }
                if (typeof source !== 'object') {
                    if (Array.isArray(target)) {
                        target.push(source);
                    }
                    else if (typeof target === 'object') {
                        if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                            target[source] = true;
                        }
                    }
                    else {
                        return [target, source];
                    }
                    return target;
                }
                if (typeof target !== 'object') {
                    return [target].concat(source);
                }
                var mergeTarget = target;
                if (Array.isArray(target) && !Array.isArray(source)) {
                    mergeTarget = exports.arrayToObject(target, options);
                }
                if (Array.isArray(target) && Array.isArray(source)) {
                    source.forEach(function (item, i) {
                        if (has.call(target, i)) {
                            if (target[i] && typeof target[i] === 'object') {
                                target[i] = exports.merge(target[i], item, options);
                            }
                            else {
                                target.push(item);
                            }
                        }
                        else {
                            target[i] = item;
                        }
                    });
                    return target;
                }
                return Object.keys(source).reduce(function (acc, key) {
                    var value = source[key];
                    if (has.call(acc, key)) {
                        acc[key] = exports.merge(acc[key], value, options);
                    }
                    else {
                        acc[key] = value;
                    }
                    return acc;
                }, mergeTarget);
            };
            exports.assign = function assignSingleSource(target, source) {
                return Object.keys(source).reduce(function (acc, key) {
                    acc[key] = source[key];
                    return acc;
                }, target);
            };
            exports.decode = function (str) {
                try {
                    return decodeURIComponent(str.replace(/\+/g, ' '));
                }
                catch (e) {
                    return str;
                }
            };
            exports.encode = function encode(str) {
                if (str.length === 0) {
                    return str;
                }
                var string = typeof str === 'string' ? str : String(str);
                var out = '';
                for (var i = 0; i < string.length; ++i) {
                    var c = string.charCodeAt(i);
                    if (c === 0x2D
                        || c === 0x2E
                        || c === 0x5F
                        || c === 0x7E
                        || (c >= 0x30 && c <= 0x39)
                        || (c >= 0x41 && c <= 0x5A)
                        || (c >= 0x61 && c <= 0x7A)) {
                        out += string.charAt(i);
                        continue;
                    }
                    if (c < 0x80) {
                        out = out + hexTable[c];
                        continue;
                    }
                    if (c < 0x800) {
                        out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
                        continue;
                    }
                    if (c < 0xD800 || c >= 0xE000) {
                        out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
                        continue;
                    }
                    i += 1;
                    c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
                    out += hexTable[0xF0 | (c >> 18)]
                        + hexTable[0x80 | ((c >> 12) & 0x3F)]
                        + hexTable[0x80 | ((c >> 6) & 0x3F)]
                        + hexTable[0x80 | (c & 0x3F)];
                }
                return out;
            };
            exports.compact = function compact(value) {
                var queue = [{ obj: { o: value }, prop: 'o' }];
                var refs = [];
                for (var i = 0; i < queue.length; ++i) {
                    var item = queue[i];
                    var obj = item.obj[item.prop];
                    var keys = Object.keys(obj);
                    for (var j = 0; j < keys.length; ++j) {
                        var key = keys[j];
                        var val = obj[key];
                        if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                            queue.push({ obj: obj, prop: key });
                            refs.push(val);
                        }
                    }
                }
                return compactQueue(queue);
            };
            exports.isRegExp = function isRegExp(obj) {
                return Object.prototype.toString.call(obj) === '[object RegExp]';
            };
            exports.isBuffer = function isBuffer(obj) {
                if (obj === null || typeof obj === 'undefined') {
                    return false;
                }
                return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
            };
        }, {}] }, {}, [1]);
//# sourceMappingURL=ccxt.browser.js.map